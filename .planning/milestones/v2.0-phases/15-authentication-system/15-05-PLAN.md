---
phase: 15-authentication-system
plan: 05
type: tdd
wave: 3
depends_on:
  - 15-03
files_modified:
  - apps/devcollab-api/vitest.config.ts
  - apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-04

must_haves:
  truths:
    - "Every devcollab-api controller method is either @Public() or @CheckAbility() — verified by Vitest unit test"
    - "The unit test is a structural reflection test (no HTTP, no database, no DI container)"
    - "vitest run in devcollab-api exits 0 with all tests passing"
    - "Adding a new controller method without @Public() or @CheckAbility() would cause this test to FAIL — invariant is actively enforced"
  artifacts:
    - path: "apps/devcollab-api/vitest.config.ts"
      provides: "Vitest configuration for devcollab-api unit tests"
      contains: "vitest"
    - path: "apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts"
      provides: "Structural meta-test enumerating all controller methods"
      contains: "controller-coverage"
  key_links:
    - from: "apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts"
      to: "apps/devcollab-api/src/auth/auth.controller.ts"
      via: "Direct import of AuthController class"
      pattern: "AuthController"
    - from: "apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts"
      to: "apps/devcollab-api/src/common/decorators/check-ability.decorator.ts"
      via: "Import of CHECK_ABILITY_KEY for Reflect.getMetadata lookup"
      pattern: "CHECK_ABILITY_KEY"
---

<objective>
Set up Vitest for devcollab-api and implement the deny-by-default meta-test: a structural unit test that imports all controller classes, enumerates their route handler methods via `Reflect.getMetadata`, and asserts that every non-public method has `@CheckAbility` defined.

Purpose: This test is the CI-time enforcement mechanism for the deny-by-default security invariant. Phase 14 established the invariant at the guard level; this plan proves it structurally before any feature routes exist. Any future controller method added without proper decoration fails this test immediately.
Output: `npm test` in devcollab-api passes; the invariant is in CI.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-authentication-system/15-RESEARCH.md
@.planning/phases/15-authentication-system/15-03-SUMMARY.md
</context>

<feature>
  <name>Controller Deny-By-Default Invariant Test</name>
  <files>
    apps/devcollab-api/vitest.config.ts
    apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts
  </files>
  <behavior>
    The test imports controller classes directly (not via HTTP/DI), uses `Reflect.getMetadata` to inspect decorator metadata on each method, and asserts that every non-constructor function on the prototype is either:
    - Decorated with `@Public()` (IS_PUBLIC_KEY metadata truthy on handler or class), OR
    - Decorated with `@CheckAbility(...)` (CHECK_ABILITY_KEY metadata truthy on handler)

    Cases:
    - HealthController.health → has @Public() → test passes for this method
    - AuthController.signup → has @Public() → test passes
    - AuthController.login → has @Public() → test passes
    - AuthController.logout → has @Public() → test passes
    - AuthController.me → has @CheckAbility('read','User') → test passes
    - Hypothetical: AuthController.someNewMethod (no decorator) → test FAILS with clear message

    The test MUST import `reflect-metadata` as its very first line — without this, Reflect.getMetadata returns undefined for everything.
  </behavior>
  <implementation>
    1. RED: Write the spec file → run vitest → MUST FAIL initially if any method is missing decoration (or fail with import errors if reflect-metadata missing). Fix reflection import first, then verify all current methods pass.
    2. GREEN: All existing controller methods have correct decorators from Plan 03 → tests all pass.
    3. REFACTOR: None needed — this is a structural test with no implementation logic.

    The test discovers methods at runtime via `Object.getOwnPropertyNames(prototype)` filtered to non-constructor functions. This means when AuthController gains new methods in Phase 16+, they must be decorated OR the test fails in CI.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: Create Vitest config and install vite-tsconfig-paths in devcollab-api</name>
  <files>
    apps/devcollab-api/vitest.config.ts
    apps/devcollab-api/package.json
  </files>
  <action>
    **File 1: `apps/devcollab-api/vitest.config.ts`** — Create:
    ```typescript
    import { defineConfig } from 'vitest/config';
    import tsconfigPaths from 'vite-tsconfig-paths';

    export default defineConfig({
      plugins: [tsconfigPaths()],
      test: {
        globals: true,
        environment: 'node',
        include: ['test/**/*.spec.ts'],
      },
    });
    ```

    `tsconfigPaths` is needed so the test file can import `@devcollab/database` and `../../../src/...` paths using the TypeScript path aliases defined in `tsconfig.json`.

    **Update `apps/devcollab-api/package.json`** — add `vite-tsconfig-paths` to devDependencies (it's installed at monorepo root already from TeamFlow API setup, but must be declared in devcollab-api for turbo prune):
    ```json
    "vite-tsconfig-paths": "^6.0.0"
    ```

    Also add `vitest` to devDependencies if not already present:
    ```json
    "vitest": "^3.0.0"
    ```

    The `test` and `test:watch` scripts were added to package.json in Plan 02. If they are not present, add them now:
    ```json
    "test": "vitest run",
    "test:watch": "vitest"
    ```

    After updating package.json, run `npm install` from the monorepo root:
    ```bash
    cd /home/doctor/fernandomillan && npm install
    ```
  </action>
  <verify>
    1. `ls apps/devcollab-api/vitest.config.ts` — file exists.
    2. `grep "vite-tsconfig-paths" apps/devcollab-api/package.json` — dependency declared.
    3. `grep "vitest" apps/devcollab-api/package.json` — vitest in devDependencies.
    4. `grep "test.*vitest" apps/devcollab-api/package.json` — test script present.
  </verify>
  <done>Vitest config created with tsconfigPaths plugin; dependencies declared in package.json; test scripts present.</done>
</task>

<task type="auto">
  <name>Task 2: RED → GREEN — Write and run controller coverage meta-test</name>
  <files>
    apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts
  </files>
  <action>
    Create the directory and file: `apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts`

    **RED phase — Write the test first:**
    ```typescript
    // CRITICAL: reflect-metadata MUST be the FIRST import.
    // Without it, Reflect.getMetadata returns undefined for all decorator metadata.
    import 'reflect-metadata';
    import { describe, it, expect } from 'vitest';

    import { IS_PUBLIC_KEY } from '../../../src/common/decorators/public.decorator';
    import { CHECK_ABILITY_KEY } from '../../../src/common/decorators/check-ability.decorator';
    import { HealthController } from '../../../src/health/health.controller';
    import { AuthController } from '../../../src/auth/auth.controller';

    // MAINTAINABILITY NOTE: When a new controller is added to devcollab-api, add its class here.
    // The test will then automatically enforce the deny-by-default invariant on all its methods.
    const ALL_CONTROLLERS = [HealthController, AuthController] as const;

    describe('DevCollab deny-by-default invariant', () => {
      for (const Controller of ALL_CONTROLLERS) {
        const proto = Controller.prototype;
        // Get all own methods except the constructor
        const methods = Object.getOwnPropertyNames(proto).filter(
          (name) => name !== 'constructor' && typeof proto[name] === 'function',
        );

        describe(`${Controller.name}`, () => {
          for (const methodName of methods) {
            it(`"${methodName}" must have @Public() or @CheckAbility()`, () => {
              const handler = proto[methodName] as unknown;

              // Check @Public() at method level
              const isPublicOnMethod = Reflect.getMetadata(IS_PUBLIC_KEY, handler as object);
              // Check @Public() at class level (applies to all methods)
              const isPublicOnClass = Reflect.getMetadata(IS_PUBLIC_KEY, Controller);
              // Check @CheckAbility() at method level
              const hasCheckAbility = Reflect.getMetadata(CHECK_ABILITY_KEY, handler as object);

              expect(
                isPublicOnMethod || isPublicOnClass || hasCheckAbility,
                `\n\nVIOLATION: ${Controller.name}.${methodName}() has neither @Public() nor @CheckAbility().\n` +
                `This violates the deny-by-default security invariant.\n` +
                `Fix: Add @Public() if this is a public endpoint, or @CheckAbility(action, subject) if it requires authentication.\n`,
              ).toBeTruthy();
            });
          }
        });
      }
    });
    ```

    **GREEN phase — Run the test:**
    ```bash
    cd /home/doctor/fernandomillan && npx vitest run --project apps/devcollab-api
    ```
    OR:
    ```bash
    cd /home/doctor/fernandomillan/apps/devcollab-api && npx vitest run
    ```

    Expected outcome: ALL tests pass because:
    - HealthController.health() → has @Public()
    - AuthController.signup() → has @Public()
    - AuthController.login() → has @Public()
    - AuthController.logout() → has @Public()
    - AuthController.me() → has @CheckAbility('read', 'User')
    - The private `setAuthCookie` method on AuthController: this is a private method. `Object.getOwnPropertyNames(prototype)` includes it. However, private TypeScript methods are compiled as regular prototype methods. Check if it has @Public() — if not, it will fail the test.

    For `setAuthCookie`: it is a private helper that is NOT a route handler. It has no HTTP method decorator, so the guard never sees it. But the meta-test checks all prototype functions. To handle this, add a check: only test methods that have HTTP method metadata (are route handlers). Route handlers have `path` metadata from @Get/@Post decorators.

    Update the test to only enumerate route handler methods:
    ```typescript
    // Only test methods that are NestJS route handlers (have HTTP method metadata)
    const HTTP_METHODS = ['get', 'post', 'put', 'patch', 'delete', 'options', 'head', 'all'];
    const methods = Object.getOwnPropertyNames(proto).filter((name) => {
      if (name === 'constructor' || typeof proto[name] !== 'function') return false;
      // Check if this method has a route path metadata (i.e., is decorated with @Get/@Post/etc.)
      const hasRoutePath = Reflect.getMetadata('path', proto[name]) !== undefined;
      return hasRoutePath;
    });
    ```

    This is more precise: only methods that are NestJS route handlers (have `path` metadata from @Get/@Post) need the security invariant. Private helpers, lifecycle hooks, etc. are excluded.

    Use this refined version in the final file.
  </action>
  <verify>
    1. `ls apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts` — file exists.
    2. `grep "reflect-metadata" apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts` — first import line.
    3. `grep "ALL_CONTROLLERS" apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts` — array contains HealthController and AuthController.
    4. Run the test from monorepo root:
       ```bash
       cd /home/doctor/fernandomillan/apps/devcollab-api && npx vitest run 2>&1
       ```
       Output must show: all tests PASSED (0 failures). If any test fails, fix the controller decorator (not the test).
    5. Confirm test count: should have at least 5 passing tests (health + 4 auth methods).
  </verify>
  <done>controller-coverage.spec.ts passes with vitest run; reflect-metadata imported first; all current route handler methods have correct decorators; test fails if a new undecorated method is added (invariant is live).</done>
</task>

</tasks>

<verification>
Final verification after both tasks:
1. `cd /home/doctor/fernandomillan/apps/devcollab-api && npx vitest run` exits with code 0
2. Test output shows all tests pass with explicit method names: HealthController."health", AuthController."signup", AuthController."login", AuthController."logout", AuthController."me"
3. `grep "reflect-metadata" apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts | head -1` — first line is the import
4. `wc -l apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts` — file has reasonable length (>30 lines, not a stub)
</verification>

<success_criteria>
- `apps/devcollab-api/vitest.config.ts` exists with tsconfigPaths and node environment
- `apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts` exists with reflect-metadata as first import
- `npx vitest run` in devcollab-api directory exits 0 with all tests passing
- The test enumerates route handler methods (not private helpers) via Reflect.getMetadata('path', ...) filter
- Test failure message clearly identifies the violation controller and method name
- HealthController and AuthController are both in ALL_CONTROLLERS array
</success_criteria>

<output>
After completion, create `.planning/phases/15-authentication-system/15-05-SUMMARY.md`
</output>
