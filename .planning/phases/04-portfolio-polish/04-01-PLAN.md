---
phase: 04-portfolio-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/app/layout.tsx
  - apps/web/app/globals.css
  - apps/web/package.json
  - apps/web/lib/auth.ts
  - apps/web/lib/auth.config.ts
  - apps/web/app/(dashboard)/layout.tsx
  - apps/api/src/websocket/websocket.gateway.ts
  - apps/web/components/ui/theme-toggle.tsx
  - apps/web/components/providers/theme-provider.tsx
autonomous: true

must_haves:
  truths:
    - "Server Components can access session via auth() without errors"
    - "WebSocket connections authenticate successfully and stay connected"
    - "Dark mode toggle switches between light and dark themes without flash"
    - "Theme preference persists across page reloads"
  artifacts:
    - path: "apps/web/components/providers/theme-provider.tsx"
      provides: "ThemeProvider wrapper using next-themes"
    - path: "apps/web/components/ui/theme-toggle.tsx"
      provides: "Dark mode toggle button"
    - path: "apps/web/app/globals.css"
      provides: "CSS custom properties for dark mode"
  key_links:
    - from: "apps/web/app/layout.tsx"
      to: "ThemeProvider"
      via: "wraps children with theme context"
      pattern: "ThemeProvider.*attribute.*class"
    - from: "apps/web/app/(dashboard)/layout.tsx"
      to: "auth()"
      via: "session retrieval in Server Component"
      pattern: "const session = await auth"
---

<objective>
Fix the two auth blockers from Phase 3 (SSR session + WebSocket auth) and establish dark mode theming infrastructure for the entire application.

Purpose: Auth must work for any feature to be testable. Dark mode is needed before building portfolio pages so they're styled correctly from the start.
Output: Working authentication, dark mode toggle, themed globals.css with CSS variables.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-portfolio-polish/04-RESEARCH.md
@apps/web/app/layout.tsx
@apps/web/app/globals.css
@apps/web/lib/auth.ts
@apps/web/lib/auth.config.ts
@apps/web/app/(dashboard)/layout.tsx
@apps/api/src/websocket/websocket.gateway.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Auth Blockers (SSR Session + WebSocket Auth)</name>
  <files>
    apps/web/lib/auth.ts
    apps/web/lib/auth.config.ts
    apps/web/app/(dashboard)/layout.tsx
    apps/api/src/websocket/websocket.gateway.ts
  </files>
  <action>
    Diagnose and fix two Phase 3 auth blockers:

    1. **NextAuth SSR session issue**: Server Components can't access session via `auth()`.
       - Check that `auth.ts` properly exports `auth` from NextAuth v5 configuration
       - Verify the auth callback chain (jwt callback → session callback) correctly populates session
       - Ensure `auth()` works in Server Components (not just middleware)
       - Test by calling `const session = await auth()` in dashboard layout and confirming session.user is populated

    2. **WebSocket authentication failure**: Immediate disconnect with "Invalid token".
       - Check the WebSocket gateway's `handleConnection` method for how it extracts/validates JWT
       - The token should be the NextAuth session token from cookies or passed as auth handshake
       - Verify the JWT secret used for validation matches what NextAuth signs with
       - Check if the gateway tries to verify using NestJS JWT module vs NextAuth's own secret
       - Fix token extraction: NextAuth v5 beta uses `authjs.session-token` or `__Secure-authjs.session-token` cookie
       - If WebSocket gateway validates JWT directly, it needs to use the same NEXTAUTH_SECRET

    After fixes, verify:
    - Dashboard layout's `auth()` returns valid session with user.id, user.email, user.role
    - WebSocket connects without immediate disconnect (check API logs for connection events)
  </action>
  <verify>
    Start Docker containers (check if already running first). Start both dev servers.
    - Run `curl -s http://localhost:3000/api/auth/session` to verify auth endpoint responds
    - Check `apps/web/app/(dashboard)/layout.tsx` compiles without errors
    - Check API logs for WebSocket connection attempts (should not show "Invalid token")
    - `npm run build --filter=web` succeeds without type errors
  </verify>
  <done>
    Dashboard layout successfully retrieves session in Server Component. WebSocket gateway accepts connections with valid auth tokens. No "Invalid token" errors in API logs during normal operation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Install Dark Mode Dependencies and Configure Theming</name>
  <files>
    apps/web/package.json
    apps/web/app/layout.tsx
    apps/web/app/globals.css
    apps/web/components/providers/theme-provider.tsx
    apps/web/components/ui/theme-toggle.tsx
  </files>
  <action>
    Install dark mode infrastructure and configure application-wide theming.

    1. **Install dependencies**: `npm install next-themes` in apps/web

    2. **Create ThemeProvider wrapper** (apps/web/components/providers/theme-provider.tsx):
       - Export a client component wrapping `ThemeProvider` from next-themes
       - Configure: `attribute="class"`, `defaultTheme="system"`, `enableSystem`
       - Add `disableTransitionOnChange` to prevent transition flash

    3. **Update root layout** (apps/web/app/layout.tsx):
       - Add `suppressHydrationMismatch` to `<html>` tag
       - Wrap children with ThemeProvider (inside SessionProvider)
       - Keep existing Inter font and metadata

    4. **Update globals.css** with CSS custom properties for theming:
       - Keep existing `@import "tailwindcss"` and slide-in animation
       - Add `@theme` block with design tokens (background, foreground, primary, muted, border, card, destructive, etc.)
       - Add `.dark` class overrides for dark theme colors
       - Use neutral color palette (slate/gray tones) — NO purple anywhere
       - Primary color: blue-based (e.g., oklch-based blue)
       - Destructive: red, Warning: orange/amber, Success: green

    5. **Create theme toggle** (apps/web/components/ui/theme-toggle.tsx):
       - Client component using `useTheme()` from next-themes
       - Button that cycles: light → dark → system
       - Use lucide-react icons (Sun, Moon, Monitor)
       - Style with Tailwind classes that respond to dark mode

    6. **Add theme toggle to dashboard Header** component:
       - Import and render ThemeToggle in the header bar

    IMPORTANT: No purple colors anywhere per user requirement. Use blue as primary accent.
  </action>
  <verify>
    - `npm run build --filter=web` succeeds
    - ThemeProvider wraps the application in root layout
    - globals.css contains both light and dark CSS variables
    - No purple color values exist in globals.css (grep for "purple", "hsl(270", "oklch.*0.3")
    - Theme toggle component exists and is a client component ('use client' directive)
  </verify>
  <done>
    Application has working dark mode with light/dark/system toggle. Theme persists across reloads. No flash of incorrect theme. CSS variables define consistent color palette for both themes. Dashboard header shows theme toggle button.
  </done>
</task>

</tasks>

<verification>
- Auth: Dashboard loads with valid session, no SSR errors
- Auth: WebSocket connects without "Invalid token" errors
- Dark mode: Toggle cycles light/dark/system
- Dark mode: Theme persists on reload
- Dark mode: No flash of wrong theme on page load
- No purple colors in any CSS
- `npm run build --filter=web` succeeds
</verification>

<success_criteria>
Authentication works end-to-end (login → session → Server Components → WebSocket). Dark mode theming is configured with CSS variables and next-themes. Theme toggle is accessible in the dashboard. Application builds without errors.
</success_criteria>

<output>
After completion, create `.planning/phases/04-portfolio-polish/04-01-SUMMARY.md`
</output>
