---
phase: 04-portfolio-polish
plan: 10
type: execute
wave: 5
depends_on: ["04-03", "04-04", "04-05", "04-06", "04-07", "04-08", "04-09"]
files_modified:
  - apps/web/Dockerfile
  - apps/api/Dockerfile
  - .dockerignore
  - .github/workflows/deploy.yml
  - docker-compose.prod.yml
autonomous: false
user_setup:
  - service: coolify
    why: "Self-hosted PaaS for deployment"
    env_vars:
      - name: COOLIFY_WEBHOOK_URL
        source: "Coolify Dashboard -> Application -> Webhooks"
    dashboard_config:
      - task: "Create applications for web and api"
        location: "Coolify Dashboard -> New Application"
      - task: "Configure custom domains"
        location: "Coolify Dashboard -> Application -> Domains"
      - task: "Set environment variables"
        location: "Coolify Dashboard -> Application -> Environment Variables"
  - service: github
    why: "Container registry and CI/CD"
    env_vars:
      - name: GITHUB_TOKEN
        source: "Auto-provided by GitHub Actions"

must_haves:
  truths:
    - "Docker builds succeed for both web and api applications"
    - "GitHub Actions workflow triggers on push to main"
    - "CI pipeline runs tests before building Docker images"
    - "Docker images are pushed to GitHub Container Registry"
  artifacts:
    - path: "apps/web/Dockerfile"
      provides: "Production Docker image for web app"
    - path: "apps/api/Dockerfile"
      provides: "Production Docker image for API"
    - path: ".github/workflows/deploy.yml"
      provides: "CI/CD pipeline"
    - path: ".dockerignore"
      provides: "Docker build context exclusions"
  key_links:
    - from: ".github/workflows/deploy.yml"
      to: "apps/web/Dockerfile"
      via: "Docker build step"
      pattern: "docker.*build.*web"
    - from: ".github/workflows/deploy.yml"
      to: "ghcr.io"
      via: "Container registry push"
      pattern: "ghcr\\.io"
---

<objective>
Create production Docker images for web and API apps, set up CI/CD pipeline with GitHub Actions, and prepare for Coolify deployment.

Purpose: Deployment demonstrates DevOps skills and makes the application accessible to recruiters. CI/CD shows professional engineering practices.
Output: Dockerfiles for both apps, GitHub Actions CI/CD pipeline, production Docker Compose.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-portfolio-polish/04-RESEARCH.md
@apps/web/package.json
@apps/api/package.json
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Production Dockerfiles for Web and API</name>
  <files>
    apps/web/Dockerfile
    apps/api/Dockerfile
    .dockerignore
    docker-compose.prod.yml
  </files>
  <action>
    Create optimized production Docker images:

    1. **.dockerignore** (root level):
       ```
       node_modules
       .next
       .git
       .gitignore
       *.md
       .planning
       .env*
       .turbo
       dist
       coverage
       playwright-report
       test-results
       ```

    2. **Web Dockerfile** (apps/web/Dockerfile):
       Multi-stage build using turbo prune:

       Stage 1 - Pruner:
       - FROM node:20-alpine AS pruner
       - Install turbo globally
       - COPY entire monorepo
       - Run `turbo prune web --docker`

       Stage 2 - Installer:
       - FROM node:20-alpine AS installer
       - Copy package files from pruner /app/out/json/
       - Copy lockfile
       - Run `npm ci`

       Stage 3 - Builder:
       - FROM node:20-alpine AS builder
       - Copy full source from pruner /app/out/full/
       - Copy node_modules from installer
       - Generate Prisma client: `npx prisma generate --schema=packages/database/prisma/schema.prisma`
       - Run `npx turbo build --filter=web`

       Stage 4 - Runner:
       - FROM node:20-alpine AS runner
       - Set NODE_ENV=production
       - Create non-root user (nextjs:nodejs)
       - Copy standalone output from builder
       - Copy static assets and public folder
       - Expose 3000
       - CMD ["node", "apps/web/server.js"]

       Need to enable standalone output in next.config.ts: `output: 'standalone'`

    3. **API Dockerfile** (apps/api/Dockerfile):
       Multi-stage build:

       Stage 1 - Pruner:
       - FROM node:20-alpine AS pruner
       - Install turbo globally
       - COPY entire monorepo
       - Run `turbo prune api --docker`

       Stage 2 - Installer:
       - FROM node:20-alpine AS installer
       - Copy package files
       - Run `npm ci`

       Stage 3 - Builder:
       - FROM node:20-alpine AS builder
       - Copy full source
       - Copy node_modules
       - Generate Prisma client
       - Run `npx turbo build --filter=api`

       Stage 4 - Runner:
       - FROM node:20-alpine AS runner
       - Set NODE_ENV=production
       - Create non-root user
       - Copy dist from builder
       - Copy node_modules (production only)
       - Copy Prisma schema for migrations
       - Expose 4000
       - CMD ["node", "dist/main.js"]

    4. **Production Docker Compose** (docker-compose.prod.yml):
       - web service: builds from apps/web/Dockerfile, port 3000, depends on api + postgres + redis
       - api service: builds from apps/api/Dockerfile, port 4000, depends on postgres + redis
       - postgres: same as dev but with production volume mount
       - redis: same as dev
       - Environment variables from .env.production

    Update apps/web/next.config.ts to add `output: 'standalone'` for Docker deployment.
  </action>
  <verify>
    - apps/web/Dockerfile exists with multi-stage build
    - apps/api/Dockerfile exists with multi-stage build
    - .dockerignore exists and excludes node_modules, .next, .git
    - docker-compose.prod.yml exists with all 4 services
    - next.config.ts has `output: 'standalone'`
    - `docker build -f apps/web/Dockerfile .` succeeds (dry-run: just verify Dockerfile syntax is valid)
  </verify>
  <done>
    Production Dockerfiles for web and API use multi-stage builds with turbo prune for optimized images. Docker Compose production file orchestrates all services. Web app configured for standalone output.
  </done>
</task>

<task type="auto">
  <name>Task 2: GitHub Actions CI/CD Pipeline</name>
  <files>
    .github/workflows/deploy.yml
  </files>
  <action>
    Create a GitHub Actions workflow for CI/CD:

    1. **Workflow file** (.github/workflows/deploy.yml):

       Trigger: push to main branch

       Jobs:

       **Job 1: test**
       - runs-on: ubuntu-latest
       - Steps:
         - Checkout code
         - Setup Node.js 20
         - Install dependencies (npm ci)
         - Run linting (npm run lint --if-present)
         - Run web unit tests (cd apps/web && npx vitest run)
         - Run API unit tests (cd apps/api && npm test)

       **Job 2: build-and-push** (needs: test)
       - runs-on: ubuntu-latest
       - Steps:
         - Checkout code
         - Set up Docker Buildx
         - Login to GitHub Container Registry (ghcr.io)
         - Build and push web Docker image:
           - tag: ghcr.io/${{ github.repository }}/web:latest and :${{ github.sha }}
           - cache: registry type for faster rebuilds
         - Build and push API Docker image:
           - tag: ghcr.io/${{ github.repository }}/api:latest and :${{ github.sha }}
           - cache: registry type

       **Job 3: deploy** (needs: build-and-push)
       - runs-on: ubuntu-latest
       - if: github.ref == 'refs/heads/main'
       - Steps:
         - Trigger Coolify webhook (POST to COOLIFY_WEBHOOK_URL secret)
         - Use `fjogeleit/http-request-action@v1` or simple curl

    Add concurrency group to prevent parallel deployments:
    ```yaml
    concurrency:
      group: deploy-${{ github.ref }}
      cancel-in-progress: true
    ```

    Add permissions for GHCR:
    ```yaml
    permissions:
      contents: read
      packages: write
    ```
  </action>
  <verify>
    - .github/workflows/deploy.yml exists
    - Workflow has 3 jobs: test, build-and-push, deploy
    - Test job runs vitest and api tests
    - Build job pushes to ghcr.io
    - Deploy job triggers Coolify webhook
    - Concurrency group configured
    - YAML syntax is valid
  </verify>
  <done>
    CI/CD pipeline runs tests, builds Docker images, pushes to GHCR, and triggers Coolify deployment on push to main. Pipeline has proper concurrency control and caching.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Phase 4 Final Verification</name>
  <files>N/A</files>
  <action>
    Verify all Phase 4 deliverables work end-to-end:
    1. Start Docker containers and dev servers
    2. Visit http://localhost:3000 — see portfolio home page with hero
    3. Navigate: About, Projects, Case Study, Resume, Contact — all pages load
    4. Toggle dark mode — theme switches without flash
    5. Press Ctrl+K — command palette opens with navigation items
    6. Visit http://localhost:3000/nonexistent — see 404 page
    7. Log in with demo1@teamflow.dev / Password123
    8. Dashboard loads with sidebar, responsive on mobile
    9. Check theme toggle in dashboard
    10. Run `cd apps/web && npx vitest run` — unit tests pass
    11. Verify Dockerfiles exist and CI/CD workflow is ready
  </action>
  <verify>All 11 verification steps pass. User confirms "approved".</verify>
  <done>Phase 4 fully verified by user. Portfolio, polish, testing, and deployment infrastructure all working.</done>
</task>

</tasks>

<verification>
- Docker build succeeds for web and api
- GitHub Actions workflow is syntactically valid
- CI pipeline runs tests before deployment
- Docker images tagged with sha and latest
- Coolify webhook trigger configured
- All Phase 4 features working together
</verification>

<success_criteria>
Production Dockerfiles build optimized images for both apps. GitHub Actions CI/CD pipeline runs tests, builds images, pushes to GHCR, and deploys to Coolify. Application is deployable to production.
</success_criteria>

<output>
After completion, create `.planning/phases/04-portfolio-polish/04-10-SUMMARY.md`
</output>
