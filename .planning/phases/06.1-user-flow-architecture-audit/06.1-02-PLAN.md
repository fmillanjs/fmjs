---
phase: 06.1-user-flow-architecture-audit
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/api.ts
  - apps/web/lib/validators/api-schemas.ts
  - apps/api/test/integration/schema-validation.spec.ts
autonomous: true

must_haves:
  truths:
    - "API responses match database schema (no field mismatches, type errors, or missing data)"
    - "No data inconsistencies: orphaned records, stale cache, API-DB mismatches resolved"
  artifacts:
    - path: "apps/web/lib/api.ts"
      provides: "Enhanced API client with runtime Zod validation for all responses"
      exports: ["validatedApi"]
      min_lines: 100
    - path: "apps/web/lib/validators/api-schemas.ts"
      provides: "Zod schemas matching Prisma models for runtime API response validation"
      exports: ["TeamSchema", "ProjectSchema", "TaskSchema", "CommentSchema"]
      min_lines: 150
    - path: "apps/api/test/integration/schema-validation.spec.ts"
      provides: "Integration tests validating API responses match expected schemas"
      min_lines: 100
  key_links:
    - from: "apps/web/lib/api.ts"
      to: "apps/web/lib/validators/api-schemas.ts"
      via: "schema parameter"
      pattern: "validatedApi\\.get.*Schema"
    - from: "apps/web/components"
      to: "apps/web/lib/api.ts"
      via: "validated fetch calls"
      pattern: "validatedApi\\.get"
    - from: "apps/api/test/integration/schema-validation.spec.ts"
      to: "NestJS controllers"
      via: "supertest HTTP calls"
      pattern: "request\\(app\\.getHttpServer\\(\\)\\)"
---

<objective>
Implement runtime API response validation using Zod schemas to detect and prevent data mismatches between API and database, ensuring type safety at runtime and catching schema drift early.

Purpose: Eliminate data inconsistencies by validating all API responses match expected schemas before consuming data in frontend components. Catch Date serialization issues, missing fields, type mismatches, and null handling problems that TypeScript alone cannot detect.

Output: Enhanced API client with Zod validation, comprehensive schemas matching Prisma models, and integration tests proving API-DB consistency.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-user-flow-architecture-audit/06.1-RESEARCH.md

# Existing API client
@apps/web/lib/api.ts
@apps/web/lib/server-api.ts

# Existing Zod validators
@packages/shared/src/validators/auth.ts
@packages/shared/src/validators/teams.ts
@packages/shared/src/validators/projects.ts
@packages/shared/src/validators/tasks.ts

# Prisma models
@packages/database/prisma/schema.prisma

# Example API endpoint
@apps/api/src/tasks/tasks.controller.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API response Zod schemas matching Prisma models</name>
  <files>apps/web/lib/validators/api-schemas.ts</files>
  <action>
Create comprehensive Zod schemas matching Prisma models for runtime API response validation. These schemas differ from request validation schemas (which validate user input) - they validate API responses match database schema.

Schemas to create:
1. **UserSchema**: id, name, email, emailVerified, image, role, createdAt, updatedAt (Dates as z.coerce.date())
2. **OrganizationSchema**: id, name, slug, createdAt, updatedAt
3. **MembershipSchema**: id, userId, organizationId, role, createdAt, updatedAt, user (optional nested UserSchema)
4. **ProjectSchema**: id, name, description, status, organizationId, createdAt, updatedAt, archivedAt (nullable)
5. **LabelSchema**: id, name, color, organizationId, createdAt, updatedAt
6. **TaskSchema**: id, title, description, status, priority, dueDate, position, version, projectId, assigneeId, createdById, createdAt, updatedAt, assignee (optional), labels (optional array)
7. **CommentSchema**: id, content, taskId, userId, createdAt, updatedAt, user (optional nested)
8. **AuditLogSchema**: id, userId, action, outcome, entityType, entityId, metadata, ipAddress, userAgent, createdAt

Key patterns:
- Use z.coerce.date() for all Date fields (handles JSON string serialization)
- Use .nullable() for Prisma optional fields that can be null
- Use .optional() for relations that might not be included (e.g., task.assignee)
- Use z.string().cuid() for all ID fields matching Prisma @id @default(cuid())
- Use z.enum() for status/priority/role enums matching Prisma enums
- Export both schemas AND inferred types: `export type Task = z.infer<typeof TaskSchema>`

Reference existing Prisma schema at packages/database/prisma/schema.prisma for exact field names, types, and nullability. DO NOT invent fields - match exactly.

Follow pattern from 06.1-RESEARCH.md Example 2 for schema structure. Use existing validation schemas from packages/shared/src/validators/* as reference for enum values but create NEW response schemas (not request validators).
  </action>
  <verify>
Check schema exports:
```bash
cd apps/web
grep -E "export (const|type)" lib/validators/api-schemas.ts
```

Should show exports for all 8 schemas plus their inferred types. Verify schemas match Prisma models:
```bash
cat packages/database/prisma/schema.prisma | grep -A 20 "model Task"
```
  </verify>
  <done>
Comprehensive Zod schemas created matching all Prisma models with proper Date coercion, nullability, and enum handling. Schemas export both validators and TypeScript types for use in API client.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance API client with runtime Zod validation</name>
  <files>apps/web/lib/api.ts</files>
  <action>
Enhance existing API client utility to support runtime Zod validation of all responses before returning data to components. Create new validatedApi object alongside existing api utility.

Implementation:
1. Keep existing `api` object as-is for backward compatibility
2. Create new `validatedApi` object with same methods but schema validation
3. Implement `validatedApi.get<T>(path, schema, token?)`:
   - Fetch data using existing fetch logic
   - Parse JSON response
   - Use schema.safeParse(data) for validation
   - On success: return validated data (type-safe)
   - On failure: log detailed error with path, validation errors, and received data
   - Throw descriptive error: "API response does not match expected schema for {path}: {error.message}"
4. Implement `validatedApi.post<T>(path, body, schema, token?)` with same validation
5. Implement `validatedApi.patch<T>(path, body, schema, token?)` with same validation
6. Implement `validatedApi.delete<T>(path, schema, token?)` with same validation

Environment-aware validation:
- In development (NODE_ENV !== 'production'): Always validate and throw on mismatch
- In production: Use safeParse and log errors but don't throw (graceful degradation)
- Add environment check: `const VALIDATE_RESPONSES = process.env.NODE_ENV !== 'production'`

Error logging pattern:
```typescript
console.error('API response validation failed:', {
  path,
  errors: result.error.format(),
  received: data,
  expected: schema.description || 'See Zod schema'
});
```

Follow pattern from 06.1-RESEARCH.md Example 2. Preserve existing api utility for components that don't need validation yet. Export both: `export { api, validatedApi }`

DO NOT modify server-api.ts (that's for Server Components and has different auth pattern).
  </action>
  <verify>
Check exports and implementation:
```bash
cd apps/web
grep -E "export.*validatedApi" lib/api.ts
grep -E "safeParse" lib/api.ts
```

Should show validatedApi export and safeParse usage. Verify error logging includes path, errors, and received data.
  </verify>
  <done>
Enhanced API client provides validatedApi utility with runtime Zod validation for all HTTP methods. Development mode validates strictly, production mode logs errors gracefully. Both api and validatedApi exported for gradual migration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create API schema validation integration tests</name>
  <files>apps/api/test/integration/schema-validation.spec.ts</files>
  <action>
Create integration tests validating that API responses match expected schemas, catching Date serialization issues, missing fields, and type mismatches.

Test structure:
1. Setup: Create test database with seed data (1 org, 1 user, 1 project, 3 tasks with comments)
2. Test GET /api/organizations: Validate response matches OrganizationSchema array
3. Test GET /api/organizations/:id: Validate response matches OrganizationSchema
4. Test GET /api/projects/:id: Validate response matches ProjectSchema with relations
5. Test GET /api/tasks?projectId=:id: Validate response matches TaskSchema array
6. Test GET /api/tasks/:id: Validate response matches TaskSchema with assignee and labels
7. Test GET /api/tasks/:id/comments: Validate response matches CommentSchema array
8. Test POST /api/tasks: Validate created task response matches TaskSchema
9. Test PATCH /api/tasks/:id: Validate updated task response matches TaskSchema
10. Teardown: Clean up test data

Validation pattern for each test:
```typescript
const response = await request(app.getHttpServer())
  .get('/api/tasks')
  .set('Authorization', `Bearer ${token}`)
  .expect(200);

const result = z.array(TaskSchema).safeParse(response.body);
expect(result.success).toBe(true);
if (!result.success) {
  console.error('Validation errors:', result.error.format());
}
```

Critical checks:
- Dates are serialized as ISO strings and z.coerce.date() parses them
- Nullable fields return null (not undefined) when empty
- Optional relations (assignee, labels) are included when requested
- Enum values match exactly (no case mismatches)
- CUID format IDs pass z.string().cuid() validation

Use supertest for HTTP calls. Follow existing integration test pattern from apps/api/test/integration/tasks/tasks.spec.ts. Import schemas from apps/web/lib/validators/api-schemas.ts.

DO NOT use zod-prisma-types or code generation - manually maintain schemas for this phase (per Open Question 1 in research).
  </action>
  <verify>
Run integration tests:
```bash
cd apps/api
npm test -- schema-validation.spec.ts
```

All 10 schema validation tests should pass. If any fail, check console output for validation errors showing field mismatches.
  </verify>
  <done>
Integration tests validate API responses match Zod schemas for all major endpoints. Tests prove Date serialization works, nullable fields handled correctly, and no type mismatches between API and database. All 10 tests pass.
  </done>
</task>

</tasks>

<verification>
Run complete verification:

1. Check API schemas match Prisma models:
```bash
cd apps/web
cat lib/validators/api-schemas.ts | grep "export const.*Schema"
```

2. Verify validatedApi implementation:
```bash
grep -A 10 "validatedApi\.get" lib/api.ts
```

3. Run integration tests:
```bash
cd apps/api
npm test -- schema-validation.spec.ts
```

4. Test runtime validation in development:
```bash
cd apps/web
NODE_ENV=development npm run dev
# Open browser, navigate to /teams, check console for any validation errors
```

All schemas should export properly, validatedApi should validate responses, integration tests should pass, and no validation errors should appear in development console when using existing endpoints.
</verification>

<success_criteria>
1. Zod schemas created for all 8 major Prisma models (User, Organization, Membership, Project, Label, Task, Comment, AuditLog)
2. Schemas handle Date coercion (z.coerce.date()), nullable fields, optional relations, and enum validation
3. Enhanced API client provides validatedApi utility with runtime validation for all HTTP methods
4. Development mode validates strictly and throws on mismatch, production mode logs gracefully
5. Integration tests prove API responses match schemas for all major endpoints (GET, POST, PATCH)
6. No validation errors appear when using existing API endpoints in development mode
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-user-flow-architecture-audit/06.1-02-SUMMARY.md`
</output>
