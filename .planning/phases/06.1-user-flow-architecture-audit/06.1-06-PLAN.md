---
phase: 06.1-user-flow-architecture-audit
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/api.ts
  - apps/web/lib/api.test.ts
  - apps/web/app/(dashboard)/teams/page.tsx
  - apps/web/components/teams/team-list.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Teams data fetching uses validatedApi with runtime Zod validation"
    - "API schema validation catches mismatches in development mode"
    - "At least one critical data flow uses validatedApi for type safety"
  artifacts:
    - path: "apps/web/lib/api.ts"
      provides: "Enhanced API client with runtime validation"
      exports: ["validatedApi"]
    - path: "apps/web/lib/api.test.ts"
      provides: "Unit tests for validatedApi integration"
      contains: "describe('validatedApi'"
      min_lines: 50
    - path: "apps/web/lib/validators/api-schemas.ts"
      provides: "Zod schemas for API responses"
      exports: ["TeamSchema", "ProjectSchema", "TaskSchema"]
    - path: "apps/web/app/(dashboard)/teams/page.tsx"
      provides: "Teams page using validatedApi"
      contains: "validatedApi.get"
  key_links:
    - from: "apps/web/app/(dashboard)/teams/page.tsx"
      to: "validatedApi"
      via: "import and usage"
      pattern: "import.*validatedApi.*from.*api"
    - from: "validatedApi.get"
      to: "TeamSchema"
      via: "schema parameter"
      pattern: "validatedApi\\.get.*TeamSchema"
---

<objective>
Integrate runtime API validation infrastructure by migrating teams data flow to use validatedApi, ensuring the validation infrastructure created in Plan 02 is actually used and provides protection against API-database schema drift.

Purpose: Close Gap 3 from Phase 6.1 verification - validatedApi and api-schemas exist but are orphaned (no component imports or usage), making the validation infrastructure provide zero actual protection. Migrate at least one critical data flow to demonstrate integration.

Output: Teams data flow uses validatedApi with runtime Zod validation, demonstrating proper integration and providing a pattern for future migrations.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-user-flow-architecture-audit/06.1-VERIFICATION.md

# Gap context
Gap 3: Validation infrastructure not integrated (WARNING)
- validatedApi exists but no components use it
- api-schemas.ts has 8 schemas but never imported
- Fix needed: Migrate at least one critical data flow (teams/projects/tasks)

# Validation infrastructure
@apps/web/lib/api.ts
@apps/web/lib/validators/api-schemas.ts

# Migration targets
@apps/web/app/(dashboard)/teams/page.tsx
@apps/web/app/(dashboard)/teams/[teamId]/projects/[projectId]/page.tsx
@apps/web/components/teams/team-list.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add environment-aware validation mode to validatedApi</name>
  <files>apps/web/lib/api.ts</files>
  <action>
Enhance validatedApi to support environment-aware validation: strict validation in development (throws errors), graceful degradation in production (logs warnings).

Add configuration at top of api.ts:
```typescript
const VALIDATION_MODE = process.env.NODE_ENV === 'production' ? 'graceful' : 'strict';
```

Update validatedApi.get() method:
1. Keep existing safeParse() validation
2. On validation failure:
   - If VALIDATION_MODE === 'strict': throw error (current behavior for dev)
   - If VALIDATION_MODE === 'graceful': log error to console, return unvalidated data (production)
3. Add structured error logging:
   ```typescript
   console.error('API validation failed:', {
     path,
     mode: VALIDATION_MODE,
     errors: result.error.format(),
     received: data,
   });
   ```

This ensures development catches schema drift early while production degrades gracefully instead of breaking user experience.

Rationale: Research (06.1-RESEARCH.md Open Question 3) recommends validate in development, strip/log in production for performance and user experience.
  </action>
  <verify>
Check environment-aware validation logic:
```bash
cd apps/web
grep -A 10 "VALIDATION_MODE" lib/api.ts
```

Should show:
- VALIDATION_MODE constant defined
- Conditional behavior in validatedApi based on mode
- Structured error logging in both modes

Verify no breaking changes to existing API client:
```bash
npm run build
```

Should build successfully without errors.
  </verify>
  <done>
validatedApi supports environment-aware validation: strict in development (throws), graceful in production (logs). Configuration is clear and behavior is documented in code comments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate teams data fetching to validatedApi</name>
  <files>
apps/web/app/(dashboard)/teams/page.tsx
apps/web/components/teams/team-list.tsx
  </files>
  <action>
Migrate teams data fetching from plain API calls to validatedApi with runtime schema validation.

Changes in teams/page.tsx:
1. Import validatedApi and TeamSchema:
   ```typescript
   import { validatedApi } from '@/lib/api';
   import { TeamSchema } from '@/lib/validators/api-schemas';
   import { z } from 'zod';
   ```

2. Replace existing serverApi.get() or fetch() call with:
   ```typescript
   const teams = await validatedApi.get(
     '/api/organizations',
     z.array(TeamSchema),
     token
   );
   ```

3. Keep existing error handling and loading states unchanged
4. Pass validated teams data to TeamList component as before

Changes in team-list.tsx (if applicable):
- No changes needed if component just receives teams as props
- If component fetches data directly, apply same validatedApi pattern

Preserve existing functionality:
- SSR data fetching pattern (Server Component)
- Error boundaries
- Loading states
- Type safety (TypeScript types from z.infer<typeof TeamSchema>)

Do NOT change component logic, only the data fetching mechanism. The validated data should be type-compatible with existing code.
  </action>
  <verify>
Check migration implementation:
```bash
cd apps/web
grep -n "validatedApi" app/\(dashboard\)/teams/page.tsx
grep -n "TeamSchema" app/\(dashboard\)/teams/page.tsx
```

Should show:
- Import statement for validatedApi
- Import statement for TeamSchema
- Usage: validatedApi.get() with TeamSchema parameter

Run development server and check console:
```bash
npm run dev
```

Navigate to /teams and check browser console for:
- No validation errors (schema matches API response)
- If validation errors appear, they should be detailed and actionable

Run E2E tests to verify no regressions:
```bash
cd apps/web
npx playwright test e2e/authenticated/teams.spec.ts --project=chromium
```

Should pass without failures.
  </verify>
  <done>
Teams page uses validatedApi with TeamSchema for runtime validation. Data fetching works correctly with validated types. Development mode logs any schema mismatches for debugging. No regressions in team functionality.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add validation integration test</name>
  <files>apps/web/lib/api.test.ts</files>
  <action>
Create unit test validating that validatedApi integration works correctly for teams data flow.

Create new test file apps/web/lib/api.test.ts:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { validatedApi } from './api';
import { TeamSchema } from './validators/api-schemas';
import { z } from 'zod';

describe('validatedApi', () => {
  beforeEach(() => {
    // Reset fetch mock before each test
    vi.clearAllMocks();
  });

  it('validates successful response with correct schema', async () => {
    const mockTeams = [
      {
        id: 'team123',
        name: 'Engineering',
        slug: 'engineering',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      },
    ];

    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => mockTeams,
    });

    const result = await validatedApi.get(
      '/api/organizations',
      z.array(TeamSchema),
      'test-token'
    );

    expect(result).toHaveLength(1);
    expect(result[0].name).toBe('Engineering');
    expect(result[0].createdAt).toBeInstanceOf(Date); // Coerced by Zod
  });

  it('throws error in strict mode when schema validation fails', async () => {
    const invalidData = [
      { id: 123, name: 'Bad' }, // Invalid: id should be string
    ];

    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => invalidData,
    });

    // In development mode (strict), should throw
    await expect(
      validatedApi.get('/api/organizations', z.array(TeamSchema), 'token')
    ).rejects.toThrow(/does not match expected schema/);
  });
});
```

Tests verify:
1. Valid data passes validation and is typed correctly
2. Date coercion works (string → Date via z.coerce.date())
3. Invalid data throws error in strict mode

Run test to confirm:
```bash
cd apps/web
npm run test lib/api.test.ts
```
  </action>
  <verify>
Run validation integration tests:
```bash
cd apps/web
npm run test lib/api.test.ts
```

Should show:
- ✓ validates successful response with correct schema
- ✓ throws error in strict mode when schema validation fails
- All tests passing

Also verify teams E2E tests still pass:
```bash
npx playwright test e2e/authenticated/teams.spec.ts --project=chromium
```

Should pass without errors, confirming integration doesn't break functionality.
  </verify>
  <done>
Validation integration tests pass, proving validatedApi works correctly. Teams data flow uses runtime validation in development, catching schema drift early. Production mode logs validation errors without breaking UX. Gap 3 closed - validation infrastructure is integrated and functional.
  </done>
</task>

</tasks>

<verification>
Verify validation infrastructure integration:

**Code verification:**
```bash
cd apps/web
# Verify validatedApi is imported and used
grep -r "validatedApi" app/\(dashboard\)/teams/
grep -r "TeamSchema" app/\(dashboard\)/teams/

# Verify environment-aware validation mode
grep "VALIDATION_MODE" lib/api.ts
```

**Runtime verification:**
```bash
# Start dev server
npm run dev

# Navigate to /teams in browser
# Check console - should be no validation errors

# If validation errors appear, they indicate schema drift:
# - Check error message for specific field mismatches
# - Update TeamSchema or API response to match
```

**Test verification:**
```bash
# Run unit tests
npm run test lib/api.test.ts

# Run E2E tests
npx playwright test e2e/authenticated/teams.spec.ts --project=chromium
npx playwright test e2e/user-journey/complete-flow.spec.ts --project=chromium
```

All tests should pass.

**VERIFICATION.md update:**
- Gap 3 status: partial → closed
- Artifacts: validatedApi status orphaned → integrated
- Key links: NOT_WIRED → WIRED for teams data flow
</verification>

<success_criteria>
1. validatedApi supports environment-aware validation (strict dev, graceful prod)
2. Teams page uses validatedApi.get() with TeamSchema for data fetching
3. Runtime validation catches schema mismatches in development
4. Unit tests validate validatedApi integration works correctly
5. E2E tests pass without regressions
6. Gap 3 from VERIFICATION.md is fully closed (infrastructure integrated)
7. Pattern established for migrating other data flows (projects, tasks) in future
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-user-flow-architecture-audit/06.1-06-SUMMARY.md`
</output>
