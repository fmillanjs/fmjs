# Phase 6.1: User Flow & Architecture Audit - Research

**Researched:** 2026-02-15
**Domain:** Full-stack application architecture audit, user journey validation, data integrity verification
**Confidence:** HIGH

## Summary

Phase 6.1 focuses on auditing and fixing the complete user journey from portfolio through TeamFlow dashboard, ensuring navigation consistency, data integrity between API and database, proper authentication at boundaries, and comprehensive edge case handling. This is a cross-cutting architectural audit phase that validates the integration of all previously implemented features.

The research reveals that this phase requires a systematic approach combining **manual user flow testing**, **automated E2E journey validation**, **schema consistency verification**, **authentication boundary testing**, and **edge case enumeration**. The existing stack (Next.js 15, NestJS, Turborepo, Prisma, Zod) provides strong foundations for type safety and validation, but requires explicit audit processes to verify runtime behavior matches architectural expectations.

**Primary recommendation:** Use a three-tier audit approach: (1) Automated E2E tests for happy-path user journeys using Playwright, (2) Runtime schema validation with Zod for API-database consistency, and (3) Manual exploratory testing with documented checklists for edge cases and navigation flows.

## Standard Stack

### Core Testing & Validation Tools

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Playwright | ^1.58.2 | E2E user journey testing | Industry standard for Next.js testing, supports authentication flows, mobile viewport testing, and network interception. Already in project. |
| Zod | ^3.25.76 | Runtime schema validation | TypeScript-first validation library that provides both compile-time types and runtime validation. Already used for form validation, can extend to API response validation. |
| Vitest | ^4.0.18 | Unit and integration testing | Fast, modern test runner with ESM support. Already in project for unit tests. |

### Supporting Tools

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| React Testing Library | ^16.3.2 | Component integration tests | Testing component state transitions, loading/error/empty states. Already in project via @testing-library/react. |
| superjson | Latest | Type-safe serialization | If API responses need complex type preservation (Dates, Maps, Sets). Not currently in stack. |
| zod-prisma-types | Latest | Generate Zod schemas from Prisma | If wanting single source of truth for validation. Not currently in stack but useful for ensuring Prisma-Zod consistency. |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Playwright | Cypress | Cypress has better DX for visual debugging, but Playwright has better multi-browser support and is more suitable for CI/CD. Project already uses Playwright. |
| Manual checklist testing | Automated visual regression (Percy, Chromatic) | Visual regression catches UI bugs but doesn't validate functional flows. Manual testing needed for first-time flow discovery. |
| Zod runtime validation | TypeScript only | TypeScript provides compile-time safety but cannot validate runtime data from external APIs. Need both. |

**Installation:**

No new installations required - all necessary tools already in project. If adding zod-prisma-types:

```bash
npm install --save-dev zod-prisma-types
```

## Architecture Patterns

### Pattern 1: E2E User Journey Testing (Playwright)

**What:** Complete user flow tests that validate navigation, authentication, data persistence, and state management across multiple pages.

**When to use:** For validating critical user journeys like "portfolio → login → create team → create project → create task → kanban interaction"

**Example:**

```typescript
// Source: https://betterstack.com/community/guides/testing/playwright-signup-login/
// Adapted for Next.js 15 + NextAuth v5
test.describe('Complete User Journey', () => {
  test('user can navigate from portfolio to dashboard and create resources', async ({ page }) => {
    // Portfolio navigation
    await page.goto('/projects/teamflow');
    await expect(page.getByText(/TeamFlow/i)).toBeVisible();

    // Click "View Live Demo" button (goes to /teams which redirects to /login)
    await page.getByRole('link', { name: /view live demo/i }).click();

    // Should redirect to login
    await expect(page).toHaveURL(/\/login/);

    // Login
    await page.getByLabel('Email').fill('test@example.com');
    await page.getByLabel('Password').fill('password123');
    await page.getByRole('button', { name: /sign in/i }).click();

    // Should land on teams page
    await expect(page).toHaveURL(/\/teams/);

    // Create team (first-time user flow)
    await page.getByRole('link', { name: /create team/i }).click();
    await page.getByLabel('Team Name').fill('My Test Team');
    await page.getByRole('button', { name: /create/i }).click();

    // Verify team created and navigated to team page
    await expect(page).toHaveURL(/\/teams\/[^/]+$/);
    await expect(page.getByText('My Test Team')).toBeVisible();
  });
});
```

### Pattern 2: Runtime API Response Validation

**What:** Validate API responses match expected schema using Zod before consuming data in components.

**When to use:** For detecting data mismatches between API and database, ensuring type safety at runtime, catching breaking changes early.

**Example:**

```typescript
// Source: https://egghead.io/validate-http-api-response-with-zod-fetch-and-axios~re94k
// Adapted for existing api.ts utility
import { z } from 'zod';

const TeamSchema = z.object({
  id: z.string().cuid(),
  name: z.string(),
  slug: z.string(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

type Team = z.infer<typeof TeamSchema>;

export const api = {
  async get<T>(path: string, schema: z.ZodSchema<T>, token?: string): Promise<T> {
    const response = await fetch(`${API_URL}${path}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      },
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: 'Request failed' }));
      throw new ApiError(error.message || `HTTP ${response.status}`, response.status, error);
    }

    const data = await response.json();

    // Runtime validation with detailed error reporting
    const result = schema.safeParse(data);
    if (!result.success) {
      console.error('API response validation failed:', result.error.format());
      throw new Error(`API response does not match expected schema: ${result.error.message}`);
    }

    return result.data;
  },
};

// Usage:
const teams = await api.get<Team[]>('/api/teams', z.array(TeamSchema), token);
```

### Pattern 3: Authentication Boundary Testing

**What:** Explicit tests for authentication state at boundaries between public (portfolio) and protected (dashboard) routes.

**When to use:** For validating session persistence, redirect flows, and ensuring auth state is properly checked at route boundaries.

**Example:**

```typescript
// Source: https://nextjs.org/docs/app/guides/authentication
// Adapted for NextAuth v5 + Next.js 15
test.describe('Authentication Boundaries', () => {
  test('unauthenticated user redirects from protected route to login', async ({ page }) => {
    // Try to access protected route without auth
    await page.goto('/teams');

    // Should redirect to login
    await expect(page).toHaveURL(/\/login/);

    // Should preserve intended destination (return URL)
    const url = new URL(page.url());
    expect(url.searchParams.get('callbackUrl')).toContain('/teams');
  });

  test('authenticated user can access dashboard and return to portfolio', async ({ page }) => {
    // Setup: Login first
    await page.goto('/login');
    await page.getByLabel('Email').fill('test@example.com');
    await page.getByLabel('Password').fill('password123');
    await page.getByRole('button', { name: /sign in/i }).click();

    // Navigate to dashboard
    await page.goto('/teams');
    await expect(page).toHaveURL(/\/teams/);

    // Navigate back to portfolio (logo click)
    await page.getByRole('link', { name: /Fernando Millan/i }).first().click();
    await expect(page).toHaveURL('/');

    // Session should persist - try accessing dashboard again (no redirect)
    await page.goto('/teams');
    await expect(page).toHaveURL(/\/teams/);
  });
});
```

### Pattern 4: Edge Case Enumeration Checklist

**What:** Systematic checklist covering loading states, error states, empty states, invalid inputs, missing permissions, and navigation edge cases.

**When to use:** For comprehensive coverage of edge cases that users might encounter during real-world usage.

**Example:**

```markdown
## Edge Case Testing Checklist

### Loading States
- [ ] Initial page load shows skeleton/spinner
- [ ] Subsequent navigation shows loading indicators
- [ ] Form submission shows loading state on button
- [ ] Infinite scroll shows loading indicator at bottom
- [ ] Data refetch shows subtle loading indicator (not full-page spinner)

### Error States
- [ ] Network error shows actionable error message with retry button
- [ ] 404 page shows for invalid routes with navigation back to home
- [ ] 500 error shows generic error with support contact
- [ ] Form validation errors show next to fields
- [ ] API error messages are user-friendly (not raw stack traces)
- [ ] Error boundaries catch component errors without crashing app

### Empty States
- [ ] No teams: Shows "Create your first team" CTA
- [ ] No projects in team: Shows "Create your first project" CTA
- [ ] No tasks in project: Shows "Add your first task" CTA
- [ ] No search results: Shows "No results found" with clear filters button
- [ ] No comments on task: Shows "Be the first to comment" placeholder

### Navigation Edge Cases
- [ ] Browser back button works correctly (no broken state)
- [ ] Breadcrumbs show correct hierarchy
- [ ] Sidebar active state matches current page
- [ ] Deep links (direct URL access) work when logged in
- [ ] Invalid resource IDs show 404 not error page
- [ ] Deleted resource redirects to parent (e.g., deleted project → team page)

### Permission Edge Cases
- [ ] Member cannot access admin-only pages (redirect with error)
- [ ] Member cannot see delete buttons (UI hidden)
- [ ] Manager can archive but not delete projects
- [ ] Last admin cannot remove themselves
- [ ] Invite link shows error if already member

### Data Integrity Edge Cases
- [ ] Optimistic UI rollback on API failure (drag-drop, inline edit)
- [ ] Concurrent edits show conflict warning
- [ ] Form resubmission prevention (double-click submit)
- [ ] Stale data refresh on focus (window.addEventListener('focus'))
- [ ] Orphaned records handled (task without project shows error)
```

### Pattern 5: Breadcrumb Navigation with State Preservation

**What:** Dynamic breadcrumbs that reflect current location with preserved scroll position and sidebar state.

**When to use:** For complex nested navigation (Team → Project → Task detail) where users need context and easy back-navigation.

**Example:**

```typescript
// Source: https://jeremykreutzbender.com/blog/app-router-dynamic-breadcrumbs
// Adapted for existing routing structure
'use client';

import { usePathname } from 'next/navigation';
import Link from 'next/link';

interface BreadcrumbItem {
  label: string;
  href: string;
}

export function Breadcrumbs({ team, project }: { team?: { name: string; id: string }, project?: { name: string; id: string } }) {
  const pathname = usePathname();

  const items: BreadcrumbItem[] = [
    { label: 'Teams', href: '/teams' },
  ];

  if (team) {
    items.push({ label: team.name, href: `/teams/${team.id}` });
  }

  if (project && team) {
    items.push({ label: project.name, href: `/teams/${team.id}/projects/${project.id}` });
  }

  // Add current page if it's a task detail
  if (pathname.includes('/tasks/')) {
    items.push({ label: 'Task Details', href: pathname });
  }

  return (
    <nav className="flex items-center space-x-2 text-sm text-muted-foreground">
      {items.map((item, index) => (
        <div key={item.href} className="flex items-center">
          {index > 0 && <span className="mx-2">/</span>}
          {index === items.length - 1 ? (
            <span className="text-foreground font-medium">{item.label}</span>
          ) : (
            <Link href={item.href} className="hover:text-foreground transition-colors">
              {item.label}
            </Link>
          )}
        </div>
      ))}
    </nav>
  );
}
```

### Anti-Patterns to Avoid

- **Testing implementation details instead of user behavior:** Don't test internal state or component methods. Test what users see and do. Use semantic queries (getByRole, getByLabel) not CSS selectors.

- **Skipping server-side validation because client validation exists:** Client validation is for UX, server validation is for security. Always validate on both sides using shared Zod schemas.

- **Assuming TypeScript types guarantee runtime correctness:** TypeScript types are erased at runtime. External data (API responses, user input) must be validated at runtime with Zod.

- **Not testing authentication boundaries:** Don't assume middleware works correctly. Explicitly test that protected routes redirect, sessions persist, and unauthorized actions are blocked.

- **Ignoring empty and error states in tests:** Most E2E tests only cover happy paths. Edge cases (network failures, empty data, permission errors) are where bugs hide.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| API response validation | Manual type checking with `if (data.field)` | Zod schemas with `.safeParse()` | Zod provides comprehensive error messages, handles nested objects, enums, dates, and gives you TypeScript types for free. Edge cases like coercion, transforms, and refinements are built-in. |
| E2E test authentication | Manual cookie/localStorage manipulation | Playwright's `storageState` and setup projects | Playwright's authentication setup project runs once and reuses session state across tests. Handles cookie expiration, token refresh, and session persistence automatically. |
| Navigation state management | Custom history tracking with useEffect | Next.js built-in navigation with `router.back()` and URL state | Next.js App Router preserves scroll position, handles loading states, and manages client-side cache. Manual history tracking duplicates built-in behavior and introduces bugs. |
| Form validation | Custom validation functions | React Hook Form + Zod resolver | React Hook Form handles re-renders, touched state, error display, and async validation. Zod resolver provides type-safe validation with shared schemas between frontend/backend. |
| Loading/error/empty states | Conditional rendering in every component | Shared UI components (`<EmptyState>`, `<ErrorBoundary>`, `<Skeleton>`) | Consistent UX requires standardized components. Ad-hoc conditional rendering creates visual inconsistency and duplicated code. |

**Key insight:** User flow auditing and architectural testing require **disciplined use of existing tools** rather than custom solutions. The stack already provides Playwright for E2E testing, Zod for validation, and Next.js patterns for state management. The challenge is systematic application, not new tooling.

## Common Pitfalls

### Pitfall 1: Testing Only Happy Paths

**What goes wrong:** E2E tests cover successful login, successful task creation, successful navigation, but miss error scenarios. Real users encounter network failures, permission denials, invalid inputs, and missing data.

**Why it happens:** Happy path tests are easier to write and succeed more reliably. Edge cases require more setup (mocking network failures, creating permission scenarios, testing empty states).

**How to avoid:**
- Use a **coverage matrix** for each user journey: happy path, network error, permission error, empty state, invalid input
- Implement **error injection** in tests: `page.route('**/api/tasks', route => route.abort())` to simulate network failure
- Create **test fixtures** for edge case scenarios: empty databases, permission-restricted users, partially filled forms

**Warning signs:**
- All E2E tests pass but users report "white screen" errors
- No tests for 404 pages, error boundaries, or loading states
- Test coverage shows 80%+ but bugs appear in error handling

### Pitfall 2: API-Database Schema Drift

**What goes wrong:** Backend API returns fields that don't match Prisma schema (wrong types, missing fields, extra fields). Frontend expects `createdAt: Date` but receives `createdAt: string`. Runtime errors occur despite TypeScript showing no issues.

**Why it happens:** Prisma types are generated from schema, but API responses go through JSON serialization which converts Dates to strings. NestJS DTOs might not match Prisma types exactly. No runtime validation between API layer and database layer.

**How to avoid:**
- Use **Zod schemas as single source of truth** for API contracts: generate from Prisma with `zod-prisma-types` or manually maintain
- Add **runtime validation** in API responses: validate DTO against Zod schema before returning
- Implement **API contract tests**: verify response shape matches expected schema in integration tests
- Use **TypeScript strict mode** with `exactOptionalPropertyTypes` to catch optional field mismatches

**Warning signs:**
- `Cannot read property 'X' of undefined` errors in production but not in development
- Date formatting errors (`Invalid Date`) when displaying timestamps
- TypeScript errors after running `prisma generate`
- API returns `null` but frontend expects empty array `[]`

### Pitfall 3: Authentication State Desynchronization

**What goes wrong:** User is logged in but sees "Login" button. Session exists in Redis but NextAuth doesn't recognize it. User can access `/teams` via direct URL but clicking "Dashboard" link redirects to login.

**Why it happens:** Session state exists in multiple places: browser cookies, Redis, NextAuth session object, WebSocket connection. Middleware might check auth differently than Server Components. Token expiration not handled consistently.

**How to avoid:**
- **Single source of truth for auth:** Always use `auth()` from NextAuth, never read cookies directly
- **Consistent auth checks:** Use same pattern in middleware, Server Components, and API routes
- **Test auth boundaries explicitly:** Write E2E tests that verify redirect behavior, session persistence across navigation
- **Handle token expiration gracefully:** Implement session refresh or clear error message when token expires

**Warning signs:**
- Inconsistent redirect behavior (sometimes redirects to login, sometimes doesn't)
- "Unauthorized" errors after extended idle time
- WebSocket disconnects but HTTP requests still work
- User can access protected page via URL but not via navigation

### Pitfall 4: Navigation State Loss

**What goes wrong:** User navigates Team → Project → Task, clicks back button, and project page shows stale data or resets scroll position. Sidebar collapses on navigation. Filter state resets when clicking task then returning to list.

**Why it happens:** Server Components refetch data on every navigation, losing client-side state. Filter state stored in component state instead of URL params. Sidebar state not persisted across route changes.

**How to avoid:**
- **Store UI state in URL:** Use `nuqs` for filters, search, sort (already in stack)
- **Preserve scroll position:** Next.js App Router does this automatically for client navigation, but not for programmatic navigation
- **Use React Context for shared UI state:** Sidebar open/closed state should persist across navigation
- **Test browser back/forward:** Verify state preservation with Playwright `await page.goBack()`

**Warning signs:**
- Filters reset when navigating to task detail and back
- Scroll jumps to top on every navigation
- Sidebar state changes unexpectedly
- URL doesn't reflect current view (filters, sort, search)

### Pitfall 5: Incomplete Edge Case Handling

**What goes wrong:** Empty states show generic "No data" without CTA. Error states show raw error messages ("PrismaClientKnownRequestError"). Loading states block entire UI instead of showing skeletons. Permission errors don't explain what user lacks.

**Why it happens:** Edge cases are implemented after core functionality, often rushed or forgotten. No systematic checklist for edge case coverage. Different developers implement states inconsistently.

**How to avoid:**
- Create **shared UI components** for all states: `<EmptyState>`, `<ErrorMessage>`, `<LoadingSpinner>`, `<PermissionDenied>`
- Use **systematic checklist** (see Pattern 4 above) for every major feature
- Implement **error boundaries** at route segments to catch unexpected errors gracefully
- Test edge cases with **explicit test scenarios**: disconnect network, deny permissions, empty database

**Warning signs:**
- White screen errors (no error boundary)
- Generic "Error" messages without explanation
- No loading indicators on slow operations
- Empty pages with no guidance on what to do next
- Permission errors that don't explain which role is needed

## Code Examples

Verified patterns from official sources and existing codebase:

### Example 1: Complete User Journey E2E Test

```typescript
// Source: https://playwright.dev/ + existing e2e/portfolio/navigation.spec.ts pattern
import { test, expect } from '@playwright/test';

test.describe('Portfolio to Dashboard User Journey', () => {
  test('new user can discover TeamFlow, login, create team, and create task', async ({ page }) => {
    // Step 1: Portfolio Discovery
    await page.goto('/');
    await expect(page.getByRole('heading', { name: /Fernando Millan/i })).toBeVisible();

    await page.getByRole('link', { name: /Projects/i }).first().click();
    await expect(page).toHaveURL(/\/projects/);

    await page.getByText(/TeamFlow/i).click();
    await expect(page).toHaveURL(/\/projects\/teamflow/);

    // Step 2: Navigate to Dashboard (triggers login redirect)
    await page.getByRole('link', { name: /View Live Demo/i }).click();
    await expect(page).toHaveURL(/\/login/);

    // Step 3: Login
    await page.getByLabel('Email').fill('test@example.com');
    await page.getByLabel('Password').fill('Password123');
    await page.getByRole('button', { name: /sign in/i }).click();

    // Step 4: First-time user sees empty teams state
    await expect(page).toHaveURL(/\/teams/);
    await expect(page.getByText(/Create your first team/i)).toBeVisible();

    // Step 5: Create team
    await page.getByRole('link', { name: /Create Team/i }).click();
    await expect(page).toHaveURL(/\/teams\/new/);

    await page.getByLabel('Team Name').fill('Engineering Team');
    await page.getByRole('button', { name: /Create/i }).click();

    // Step 6: Verify team created and navigation to team page
    await expect(page).toHaveURL(/\/teams\/[a-z0-9]+$/);
    await expect(page.getByText('Engineering Team')).toBeVisible();

    // Step 7: Create project
    await page.getByRole('link', { name: /New Project/i }).click();
    await page.getByLabel('Project Name').fill('Q1 Platform');
    await page.getByLabel('Description').fill('Q1 platform improvements');
    await page.getByRole('button', { name: /Create/i }).click();

    // Step 8: Verify project created and navigation to project page
    await expect(page).toHaveURL(/\/teams\/[a-z0-9]+\/projects\/[a-z0-9]+$/);
    await expect(page.getByText('Q1 Platform')).toBeVisible();

    // Step 9: Create task via Kanban
    await page.getByRole('button', { name: /Add task/i }).first().click();
    await page.getByLabel('Title').fill('Setup CI/CD pipeline');
    await page.getByLabel('Description').fill('Configure GitHub Actions');
    await page.getByRole('button', { name: /Create Task/i }).click();

    // Step 10: Verify task appears in Kanban TODO column
    await expect(page.getByText('Setup CI/CD pipeline')).toBeVisible();

    // Step 11: Navigate to task detail
    await page.getByText('Setup CI/CD pipeline').click();
    await expect(page).toHaveURL(/\/tasks\/[a-z0-9]+$/);
    await expect(page.getByText('Configure GitHub Actions')).toBeVisible();
  });
});
```

### Example 2: Runtime API Validation with Zod

```typescript
// Source: https://zod.dev/ + https://blog.logrocket.com/schema-validation-typescript-zod/
// Enhanced version of existing lib/api.ts
import { z } from 'zod';

// Define response schemas matching Prisma models
const TaskSchema = z.object({
  id: z.string().cuid(),
  title: z.string(),
  description: z.string().nullable(),
  status: z.enum(['TODO', 'IN_PROGRESS', 'DONE', 'BLOCKED']),
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT']),
  dueDate: z.coerce.date().nullable(),
  position: z.number().int(),
  version: z.number().int(),
  projectId: z.string().cuid(),
  assigneeId: z.string().cuid().nullable(),
  createdById: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  assignee: z.object({
    id: z.string().cuid(),
    name: z.string().nullable(),
    email: z.string().email(),
  }).nullable().optional(),
  labels: z.array(z.object({
    id: z.string().cuid(),
    name: z.string(),
    color: z.string(),
  })).optional(),
});

type Task = z.infer<typeof TaskSchema>;

// Enhanced API client with runtime validation
export const validatedApi = {
  async get<T>(path: string, schema: z.ZodSchema<T>, token?: string): Promise<T> {
    const response = await fetch(`${API_URL}${path}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      },
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: 'Request failed' }));
      throw new ApiError(error.message || `HTTP ${response.status}`, response.status, error);
    }

    const data = await response.json();

    // Runtime validation with detailed error reporting
    const result = schema.safeParse(data);

    if (!result.success) {
      // Log validation errors for debugging
      console.error('API response validation failed:', {
        path,
        errors: result.error.format(),
        received: data,
      });

      throw new Error(
        `API response does not match expected schema for ${path}: ${result.error.message}`
      );
    }

    return result.data;
  },
};

// Usage in component:
async function fetchTasks(projectId: string, token: string) {
  const tasks = await validatedApi.get(
    `/api/projects/${projectId}/tasks`,
    z.array(TaskSchema),
    token
  );

  // TypeScript knows tasks is Task[] with all fields properly typed
  // Runtime validation ensures data actually matches schema
  return tasks;
}
```

### Example 3: Systematic Edge Case Testing

```typescript
// Source: https://blog.logrocket.com/ui-design-best-practices-loading-error-empty-state-react/
// Pattern for comprehensive state testing
import { test, expect } from '@playwright/test';

test.describe('Project Board Edge Cases', () => {
  test.beforeEach(async ({ page }) => {
    // Login and navigate to project
    await page.goto('/login');
    await page.getByLabel('Email').fill('test@example.com');
    await page.getByLabel('Password').fill('Password123');
    await page.getByRole('button', { name: /sign in/i }).click();
    await page.goto('/teams/test-team-id/projects/test-project-id');
  });

  test('shows loading skeleton on initial load', async ({ page }) => {
    await page.goto('/teams/test-team-id/projects/test-project-id');

    // Should show loading skeleton briefly
    await expect(page.getByTestId('kanban-skeleton')).toBeVisible();

    // Wait for data to load
    await expect(page.getByTestId('kanban-board')).toBeVisible();
    await expect(page.getByTestId('kanban-skeleton')).not.toBeVisible();
  });

  test('shows empty state when no tasks exist', async ({ page }) => {
    // Navigate to project with no tasks
    await page.goto('/teams/test-team-id/projects/empty-project-id');

    await expect(page.getByText(/No tasks yet/i)).toBeVisible();
    await expect(page.getByText(/Add your first task/i)).toBeVisible();
    await expect(page.getByRole('button', { name: /Add task/i })).toBeVisible();
  });

  test('shows error state on network failure', async ({ page }) => {
    // Intercept API call and force failure
    await page.route('**/api/projects/*/tasks', route => route.abort());

    await page.goto('/teams/test-team-id/projects/test-project-id');

    await expect(page.getByText(/Failed to load tasks/i)).toBeVisible();
    await expect(page.getByRole('button', { name: /Try again/i })).toBeVisible();
  });

  test('shows error state on 404 project', async ({ page }) => {
    await page.goto('/teams/test-team-id/projects/nonexistent-id');

    await expect(page.getByText(/Project not found/i)).toBeVisible();
    await expect(page.getByRole('link', { name: /Back to team/i })).toBeVisible();
  });

  test('shows permission denied for member viewing admin page', async ({ page }) => {
    // Login as member (not admin)
    await page.goto('/login');
    await page.getByLabel('Email').fill('member@example.com');
    await page.getByLabel('Password').fill('Password123');
    await page.getByRole('button', { name: /sign in/i }).click();

    // Try to access admin-only audit log
    await page.goto('/teams/test-team-id/audit-log');

    await expect(page.getByText(/You don't have permission/i)).toBeVisible();
    await expect(page.getByText(/Admin role required/i)).toBeVisible();
  });

  test('handles browser back button correctly', async ({ page }) => {
    // Navigate: Project → Task Detail → Back
    await page.goto('/teams/test-team-id/projects/test-project-id');
    await page.getByText('Sample Task').click();
    await expect(page).toHaveURL(/\/tasks\/[a-z0-9]+$/);

    await page.goBack();

    // Should return to project board with preserved state
    await expect(page).toHaveURL(/\/projects\/test-project-id$/);
    await expect(page.getByText('Sample Task')).toBeVisible();
  });

  test('handles optimistic UI rollback on drag-drop failure', async ({ page }) => {
    // Intercept status update API and force failure
    await page.route('**/api/tasks/*/status', route => route.abort());

    await page.goto('/teams/test-team-id/projects/test-project-id');

    const task = page.getByText('Sample Task');
    const doneColumn = page.getByTestId('kanban-column-DONE');

    // Drag task to DONE column
    await task.dragTo(doneColumn);

    // Should show optimistic update (task moves immediately)
    await expect(doneColumn.getByText('Sample Task')).toBeVisible();

    // Should rollback after API failure (task returns to original column)
    await expect(page.getByText(/Failed to update task/i)).toBeVisible();
    await expect(page.getByTestId('kanban-column-TODO').getByText('Sample Task')).toBeVisible();
  });
});
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Cypress for E2E testing | Playwright | 2024 | Playwright has better multi-browser support, faster execution, and better CI/CD integration. More suitable for Next.js App Router testing. |
| Manual type checking at runtime | Zod runtime validation | 2023-2024 | Zod provides single source of truth for validation + types. Catches mismatches between API and database schemas at runtime. |
| Page Router (pages/) | App Router (app/) | Next.js 13+ (2023) | Server Components change testing strategy - need to test server/client boundaries explicitly. Middleware for auth protection. |
| Class components with state | Functional components with hooks | React 16.8+ (2019) | Testing Library focuses on user behavior not implementation. useOptimistic (React 19) enables better optimistic UI patterns. |
| Client-side data fetching | Server Components + streaming | Next.js 13+ (2023) | Loading states handled by Suspense boundaries. Need to test SSR scenarios, not just client-side rendering. |

**Deprecated/outdated:**
- `getServerSideProps` / `getStaticProps` → Use Server Components and `fetch` with caching
- `next-auth` v4 → Use NextAuth v5 (`next-auth@beta`) for Next.js 15 compatibility
- Jest + `ts-jest` → Use Vitest for faster, modern ESM-native testing
- Manual `useEffect` data fetching → Use Server Components for initial data, React Query for client mutations

## Open Questions

1. **Question: Should we generate Zod schemas from Prisma or maintain them separately?**
   - What we know: `zod-prisma-types` can auto-generate Zod schemas from Prisma schema, ensuring perfect alignment
   - What's unclear: Current codebase has manually maintained Zod schemas in `packages/shared/src/validators/`. Would code generation improve or complicate the workflow?
   - Recommendation: **Stick with manual schemas for now** (HIGH confidence). Manual schemas provide more control over validation rules (e.g., password strength, email normalization) and API contracts might intentionally differ from database schema (e.g., excluding sensitive fields). Generated schemas work better for simple CRUD but add build complexity.

2. **Question: How should we handle Date serialization between API and frontend?**
   - What we know: Prisma returns `Date` objects, JSON serialization converts to `string`, frontend might expect `Date` again
   - What's unclear: Should API return ISO strings and frontend parse? Should we use `superjson` for automatic serialization? Current implementation status unclear.
   - Recommendation: **Use `z.coerce.date()` in Zod schemas** (HIGH confidence). This handles string-to-Date conversion automatically. API returns ISO strings (natural JSON serialization), Zod schemas on frontend coerce to Date objects. No need for superjson complexity.

3. **Question: What level of API response validation is appropriate?**
   - What we know: Runtime validation with Zod catches mismatches but adds overhead. TypeScript provides compile-time safety.
   - What's unclear: Should we validate every API response in production? Only in development? Only critical endpoints?
   - Recommendation: **Validate in development, strip in production** (MEDIUM confidence). Use environment variable to enable/disable validation. In development, validate all responses to catch schema drift early. In production, trust TypeScript types for performance but log unexpected errors. Use Zod's `safeParse()` in production for graceful degradation instead of throwing errors.

4. **Question: Should breadcrumbs be Server or Client Components?**
   - What we know: Breadcrumbs need current route context (usePathname) which requires Client Component
   - What's unclear: Breadcrumb labels need team/project names from database. Should we fetch in Server Component parent and pass as props, or fetch in Client Component?
   - Recommendation: **Server Component fetches data, Client Component renders navigation** (HIGH confidence). Pattern already exists in dashboard layout (fetches teams, passes to Sidebar). Breadcrumbs should follow same pattern - layout fetches team/project data, passes to `<Breadcrumbs>` client component for active state highlighting.

## Sources

### Primary (HIGH confidence)

- [Next.js Testing Guide](https://nextjs.org/docs/app/guides/testing) - Official Next.js 15 testing documentation
- [Playwright E2E Testing](https://playwright.dev/) - Official Playwright documentation for user journey testing
- [Zod Documentation](https://zod.dev/) - Official Zod schema validation library
- [NextAuth v5 Migration](https://authjs.dev/getting-started/migrating-to-v5) - Official NextAuth v5 documentation for authentication boundaries
- Existing codebase analysis - apps/web/e2e/portfolio/navigation.spec.ts, apps/api/test/integration/tasks/tasks.spec.ts

### Secondary (MEDIUM confidence)

- [Next.js App Router user flow testing](https://strapi.io/blog/nextjs-testing-guide-unit-and-e2e-tests-with-vitest-and-playwright) - Strapi guide to Next.js testing with Playwright
- [Playwright E2E Testing: Complete Guide (2026)](https://www.bugster.dev/playwright-e2e-testing-guide) - Comprehensive Playwright patterns
- [Building Dynamic Breadcrumbs in Next.js App Router](https://jeremykreutzbender.com/blog/app-router-dynamic-breadcrumbs) - Breadcrumb implementation patterns
- [UI best practices for loading, error, and empty states](https://blog.logrocket.com/ui-design-best-practices-loading-error-empty-state-react/) - Edge case handling patterns
- [Zod with TypeScript for Runtime Validation](https://www.telerik.com/blogs/zod-typescript-schema-validation-made-easy) - Zod validation patterns
- [Next.js + NestJS Monorepo patterns](https://gist.github.com/realcc/c08ff57de93274ec3e0d5809bd5a54ef) - Full-stack TypeScript monorepo guide

### Tertiary (LOW confidence - needs verification)

- [Full-stack application architecture audit checklist](https://getnerdify.com/blog/user-experience-audit-checklist) - General UX audit patterns, not Next.js specific
- [React Server Components debugging](https://www.dash0.com/guides/inspect-react-server-components-nextjs) - Observability patterns for Server Components
- [Tech stack audit guide](https://fullscale.io/blog/tech-stack-audit-guide/) - General architectural audit framework

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All tools already in project, well-documented, industry standard for Next.js
- Architecture patterns: HIGH - Patterns verified against official docs and existing codebase
- Pitfalls: HIGH - Based on common Next.js 15 + NestJS integration issues and existing codebase analysis
- Edge case handling: MEDIUM - Patterns are standard but specific implementation needs validation against current components

**Research date:** 2026-02-15
**Valid until:** 60 days (stable tooling, Next.js 15 and Playwright are mature)
