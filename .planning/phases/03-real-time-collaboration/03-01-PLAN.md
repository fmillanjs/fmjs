---
phase: 03-real-time-collaboration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/prisma/schema.prisma
  - apps/api/src/modules/events/events.gateway.ts
  - apps/api/src/modules/events/events.module.ts
  - apps/api/src/modules/events/listeners/task.listener.ts
  - apps/api/src/modules/events/listeners/comment.listener.ts
  - apps/api/src/modules/events/dto/ws-events.dto.ts
  - packages/shared/src/types/events.ts
  - packages/shared/src/types/task.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket server uses Redis pub/sub adapter for cross-instance broadcasting"
    - "Clients can join and leave project-specific rooms"
    - "Task CRUD events are broadcast via WebSocket to all clients in the project room"
    - "Comment CRUD events are broadcast via WebSocket to all clients in the project room"
    - "Task model has a version field that increments on every update"
  artifacts:
    - path: "apps/api/src/modules/events/events.gateway.ts"
      provides: "WebSocket gateway with Redis adapter, project room management"
      contains: "createAdapter"
    - path: "apps/api/src/modules/events/listeners/task.listener.ts"
      provides: "EventEmitter2 listener that broadcasts task events via WebSocket"
      contains: "OnEvent.*task"
    - path: "apps/api/src/modules/events/listeners/comment.listener.ts"
      provides: "EventEmitter2 listener that broadcasts comment events via WebSocket"
      contains: "OnEvent.*comment"
    - path: "apps/api/src/modules/events/dto/ws-events.dto.ts"
      provides: "WebSocket event payload types"
      exports: ["WsTaskEvent", "WsCommentEvent"]
    - path: "packages/database/prisma/schema.prisma"
      provides: "Task model with version field"
      contains: "version.*Int.*@default(0)"
  key_links:
    - from: "apps/api/src/modules/events/listeners/task.listener.ts"
      to: "apps/api/src/modules/events/events.gateway.ts"
      via: "gateway.server.to(room).emit()"
      pattern: "server\\.to.*\\.emit"
    - from: "apps/api/src/modules/tasks/tasks.service.ts"
      to: "apps/api/src/modules/events/listeners/task.listener.ts"
      via: "EventEmitter2 event bridge"
      pattern: "eventEmitter\\.emit.*task"
---

<objective>
Set up the backend WebSocket infrastructure for real-time collaboration: Redis pub/sub adapter for horizontal scaling, project-based room management, and event listeners that bridge existing EventEmitter2 audit events to WebSocket broadcasts for tasks and comments.

Purpose: All real-time features depend on this backend broadcasting infrastructure. Without it, no frontend real-time updates are possible.
Output: Fully functional WebSocket broadcasting pipeline — service emits event -> listener catches -> broadcasts to project room via Redis-backed Socket.IO.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-collaboration/03-RESEARCH.md

Key existing files to understand:
@apps/api/src/modules/events/events.gateway.ts
@apps/api/src/modules/events/events.module.ts
@apps/api/src/core/audit/audit.listener.ts
@apps/api/src/modules/tasks/tasks.service.ts
@apps/api/src/modules/comments/comments.service.ts
@packages/shared/src/types/events.ts
@packages/shared/src/types/task.ts
@packages/database/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Redis adapter, configure gateway with Redis pub/sub, add project room handlers</name>
  <files>
    apps/api/src/modules/events/events.gateway.ts
    apps/api/src/modules/events/events.module.ts
    apps/api/src/modules/events/dto/ws-events.dto.ts
    packages/shared/src/types/events.ts
    packages/shared/src/types/task.ts
  </files>
  <action>
    1. Install @socket.io/redis-adapter in apps/api:
       `cd apps/api && npm install @socket.io/redis-adapter`
       Note: ioredis is already installed. The Redis adapter needs TWO ioredis clients (pub + sub).

    2. Update `events.gateway.ts`:
       - Import `createAdapter` from `@socket.io/redis-adapter` and `Redis` from `ioredis`
       - Add `OnGatewayInit` interface
       - In `afterInit(server)`: Create two ioredis clients (pub/sub) using existing REDIS_URL env var (redis://localhost:6380), call `server.adapter(createAdapter(pubClient, subClient))`
       - Add `@SubscribeMessage('join:project')` handler:
         * Extract projectId from payload
         * Verify user has project access by checking membership (use PrismaService — inject it)
         * If authorized: `client.join('project:${projectId}')`, emit `presence:join` to room with userId/email
         * If not authorized: emit error event back to client
       - Add `@SubscribeMessage('leave:project')` handler:
         * `client.leave('project:${projectId}')`, emit `presence:leave` to room
       - Update `handleDisconnect`: Emit `presence:leave` for all project rooms the client was in before disconnecting
       - Keep existing ping/pong handler

    3. Update `events.module.ts`:
       - Import PrismaModule (or DatabaseModule if that's how it's globally available — check if PrismaService is global)
       - Add TaskListener and CommentListener to providers
       - Export EventsGateway so listeners can inject it

    4. Create `apps/api/src/modules/events/dto/ws-events.dto.ts`:
       - Define `WsTaskEvent` interface: `{ type: 'task:created' | 'task:updated' | 'task:status_changed' | 'task:deleted'; task?: TaskWithRelations; taskId?: string; userId: string; projectId: string; version?: number; timestamp: number; }`
       - Define `WsCommentEvent` interface: `{ type: 'comment:created' | 'comment:updated' | 'comment:deleted'; comment?: CommentWithAuthor; commentId?: string; taskId: string; userId: string; projectId: string; timestamp: number; }`
       - Define `WsPresenceEvent` interface: `{ userId: string; email: string; name?: string; projectId: string; }`

    5. Add `version` field type to `TaskBase` in `packages/shared/src/types/task.ts` (add `version: number` to TaskBase interface)

    6. Add WebSocket event types to `packages/shared/src/types/events.ts`:
       - Export the WsTaskEvent, WsCommentEvent, WsPresenceEvent types (or just re-export from the dto file — keep types in shared for frontend access)
  </action>
  <verify>
    - `cd apps/api && npx tsc --noEmit` compiles without errors
    - `cat node_modules/@socket.io/redis-adapter/package.json | head -5` confirms installation
    - Gateway file contains `createAdapter`, `join:project`, `leave:project` handlers
  </verify>
  <done>
    Redis adapter configured in gateway, project room join/leave handlers exist with membership verification, WS event DTOs defined, version field added to TaskBase type
  </done>
</task>

<task type="auto">
  <name>Task 2: Create task and comment event listeners for WebSocket broadcasting + add version field to schema</name>
  <files>
    apps/api/src/modules/events/listeners/task.listener.ts
    apps/api/src/modules/events/listeners/comment.listener.ts
    packages/database/prisma/schema.prisma
    apps/api/src/modules/tasks/tasks.service.ts
  </files>
  <action>
    1. Add `version` field to Task model in `packages/database/prisma/schema.prisma`:
       - Add `version Int @default(0)` to the Task model
       - Run `cd packages/database && npx prisma db push` to sync schema

    2. Update `tasks.service.ts` to increment version on updates:
       - In `update()` method: add `version: { increment: 1 }` to the Prisma update data
       - In `updateStatus()` method: add `version: { increment: 1 }` to the Prisma update data
       - CRITICAL: The TaskEvent metadata must include `projectId` so the listener knows which room to broadcast to. Currently the metadata only has ipAddress/userAgent. Add `projectId` to the metadata in the emit calls for task.created, task.updated, task.status_changed, task.deleted. Example: `metadata: { ...metadata, projectId: dto.projectId }`
       - Also include the full task object (with relations) in the event payload so the listener can broadcast the complete task data. Add `task: task` (the created/updated task) to the TaskEvent.

    3. Update `comments.service.ts` similarly:
       - The CommentEvent metadata must include `projectId` and `taskId` so the listener knows which room to broadcast to
       - Look up the task's projectId (the service already has the task from verifyTaskAccess) and include it: `metadata: { ...metadata, projectId: task.project.id, taskId }`
       - Include the full comment object in the event for broadcasting

    4. Create `apps/api/src/modules/events/listeners/task.listener.ts`:
       - Injectable class with `EventsGateway` injected
       - `@OnEvent('task.created', { async: true })` handler: Extract projectId from event metadata, broadcast `task:created` event to `project:${projectId}` room with task data, userId, timestamp
       - `@OnEvent('task.updated', { async: true })` handler: Same pattern, broadcast `task:updated`
       - `@OnEvent('task.status_changed', { async: true })` handler: Same pattern, broadcast `task:status_changed`
       - `@OnEvent('task.deleted', { async: true })` handler: Broadcast `task:deleted` with taskId only (task no longer exists)
       - Each broadcast payload matches the WsTaskEvent interface

    5. Create `apps/api/src/modules/events/listeners/comment.listener.ts`:
       - Injectable class with `EventsGateway` injected
       - `@OnEvent('comment.created', { async: true })` handler: Extract projectId from event metadata, broadcast `comment:created` to project room with comment data, taskId, userId, timestamp
       - `@OnEvent('comment.updated', { async: true })` handler: Same pattern
       - `@OnEvent('comment.deleted', { async: true })` handler: Broadcast with commentId and taskId

    IMPORTANT: The existing audit.listener.ts already listens to some events. The new listeners are ADDITIONAL listeners on the SAME events — EventEmitter2 supports multiple listeners per event. The audit listener logs to database, the new listeners broadcast via WebSocket. They are independent.
  </action>
  <verify>
    - `cd packages/database && npx prisma db push` succeeds
    - `cd apps/api && npx tsc --noEmit` compiles without errors
    - Task and comment listener files exist in events/listeners/
    - `grep -r "version" packages/database/prisma/schema.prisma | grep "Task"` shows version field
    - `grep -r "OnEvent" apps/api/src/modules/events/listeners/` shows event handlers
  </verify>
  <done>
    Task model has version field in database, tasks service increments version on update, task and comment event listeners bridge EventEmitter2 events to WebSocket broadcasts to project rooms, event payloads include projectId for room targeting
  </done>
</task>

</tasks>

<verification>
1. Check Docker is running: `docker ps` shows postgres and redis containers
2. Schema sync: `cd packages/database && npx prisma db push` succeeds
3. TypeScript: `cd apps/api && npx tsc --noEmit` passes
4. Redis adapter installed: `ls apps/api/node_modules/@socket.io/redis-adapter`
5. Event flow exists: Service -> EventEmitter2 -> TaskListener/CommentListener -> Gateway.server.to(room).emit()
6. Version field: `npx prisma studio` shows version column on Task table
</verification>

<success_criteria>
- Redis adapter configured and initializes on server start
- Project room join/leave with membership verification
- Task events (created, updated, status_changed, deleted) broadcast to project rooms
- Comment events (created, updated, deleted) broadcast to project rooms
- Task version field exists and increments on update
- All existing tests and type checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-collaboration/03-01-SUMMARY.md`
</output>
