---
phase: 01-foundation-authentication
plan: 06
type: execute
wave: 4
depends_on: ["01-03"]
files_modified:
  - apps/api/src/modules/auth/auth.module.ts
  - apps/api/src/modules/auth/auth.service.ts
  - apps/api/src/modules/auth/auth.controller.ts
  - apps/api/src/modules/auth/strategies/jwt.strategy.ts
  - apps/api/src/modules/auth/guards/jwt-auth.guard.ts
  - apps/api/src/modules/auth/decorators/current-user.decorator.ts
  - apps/api/src/modules/auth/decorators/roles.decorator.ts
  - apps/api/src/modules/auth/decorators/public.decorator.ts
  - apps/api/src/modules/users/users.module.ts
  - apps/api/src/modules/users/users.service.ts
  - apps/api/src/modules/users/users.controller.ts
  - apps/api/src/modules/users/dto/update-profile.dto.ts
  - apps/api/src/core/rbac/ability.factory.ts
  - apps/api/src/core/rbac/rbac.guard.ts
  - apps/api/src/core/rbac/rbac.module.ts
  - apps/api/src/core/rbac/decorators/check-ability.decorator.ts
  - apps/api/src/app.module.ts
  - apps/api/package.json
autonomous: true

must_haves:
  truths:
    - "NestJS API endpoints are protected by JWT authentication guard"
    - "CASL ability factory defines different permissions for Admin, Manager, and Member roles"
    - "RBAC guard denies unauthorized requests with 403 Forbidden response"
    - "Users controller enforces role-based access: Admin can manage users, Members can only update own profile"
    - "Unauthorized actions return clear 'Forbidden: You do not have permission' error messages"
  artifacts:
    - path: "apps/api/src/modules/auth/strategies/jwt.strategy.ts"
      provides: "Passport JWT strategy validating tokens"
      contains: "JwtStrategy"
    - path: "apps/api/src/core/rbac/ability.factory.ts"
      provides: "CASL ability factory with three-role permissions"
      contains: "AbilityFactory"
    - path: "apps/api/src/core/rbac/rbac.guard.ts"
      provides: "NestJS guard checking CASL permissions"
      contains: "RbacGuard"
    - path: "apps/api/src/modules/users/users.controller.ts"
      provides: "User management endpoints with RBAC"
      contains: "@UseGuards"
  key_links:
    - from: "apps/api/src/modules/auth/strategies/jwt.strategy.ts"
      to: "@repo/database"
      via: "Validates JWT payload against User table"
      pattern: "prisma\\.user\\.findUnique"
    - from: "apps/api/src/core/rbac/ability.factory.ts"
      to: "@casl/prisma"
      via: "Creates PrismaAbility for database-level filtering"
      pattern: "createPrismaAbility"
    - from: "apps/api/src/core/rbac/rbac.guard.ts"
      to: "apps/api/src/core/rbac/ability.factory.ts"
      via: "Uses AbilityFactory to check permissions"
      pattern: "abilityFactory\\.createForUser"
    - from: "apps/api/src/modules/users/users.service.ts"
      to: "@casl/prisma"
      via: "accessibleBy for database-level filtering"
      pattern: "accessibleBy"
---

<objective>
Implement NestJS authentication module with JWT strategy and CASL-based RBAC system with multi-layer enforcement at guard and service levels.

Purpose: The backend needs its own authentication (JWT validation) and authorization (RBAC) system independent of NextAuth. NestJS guards protect API endpoints, CASL provides declarative permission rules, and database-level filtering prevents data leakage. Covers RBAC-01 through RBAC-06 and provides the backend auth layer for TECH-08 (WebSocket auth).

Output: JWT-protected NestJS API with three-role CASL-based RBAC and user management endpoints.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: NestJS auth module with JWT strategy, guards, and decorators</name>
  <files>
    apps/api/package.json
    apps/api/src/modules/auth/auth.module.ts
    apps/api/src/modules/auth/auth.service.ts
    apps/api/src/modules/auth/auth.controller.ts
    apps/api/src/modules/auth/strategies/jwt.strategy.ts
    apps/api/src/modules/auth/guards/jwt-auth.guard.ts
    apps/api/src/modules/auth/decorators/current-user.decorator.ts
    apps/api/src/modules/auth/decorators/roles.decorator.ts
    apps/api/src/modules/auth/decorators/public.decorator.ts
    apps/api/src/app.module.ts
  </files>
  <action>
    Install auth dependencies:
    ```bash
    npm install @nestjs/passport passport passport-jwt @nestjs/jwt bcrypt --workspace=apps/api
    npm install -D @types/passport-jwt @types/bcrypt --workspace=apps/api
    ```

    **apps/api/src/modules/auth/strategies/jwt.strategy.ts:**
    Passport JWT strategy:
    - Extract JWT from Bearer token in Authorization header
    - secretOrKey from process.env.JWT_SECRET
    - validate(payload): lookup user in DB by payload.sub (user id). If user not found, throw UnauthorizedException. Return user object with id, email, name, role.
    - IMPORTANT: Always re-fetch user from DB on each request to get latest role (prevents stale role after RBAC change)

    **apps/api/src/modules/auth/guards/jwt-auth.guard.ts:**
    Extends AuthGuard('jwt'). Override canActivate to check for @Public() decorator first (skip auth for public endpoints like health check).

    **apps/api/src/modules/auth/decorators/current-user.decorator.ts:**
    createParamDecorator extracting user from request: `const request = ctx.switchToHttp().getRequest(); return request.user;`

    **apps/api/src/modules/auth/decorators/roles.decorator.ts:**
    SetMetadata decorator: `@Roles('ADMIN', 'MANAGER')` sets required roles on handler metadata.

    **apps/api/src/modules/auth/decorators/public.decorator.ts:**
    SetMetadata decorator marking endpoint as public (no JWT required): `@Public()`.

    **apps/api/src/modules/auth/auth.service.ts:**
    - `generateToken(user)`: creates JWT with sub: user.id, email, role. ExpiresIn from JWT_EXPIRES_IN env var.
    - `validateUser(email, password)`: find user, bcrypt.compare, return user if valid
    - `login(loginDto)`: validate + generate token
    - `signup(signUpDto)`: hash password, create user, generate token

    **apps/api/src/modules/auth/auth.controller.ts:**
    - POST /auth/login: @Public(), validates loginSchema, returns { accessToken, user }
    - POST /auth/signup: @Public(), validates signUpSchema, returns { accessToken, user }
    - GET /auth/me: Protected, returns current user from @CurrentUser()
    - All endpoints documented with @ApiTags('auth') and @ApiOperation

    **apps/api/src/modules/auth/auth.module.ts:**
    Import JwtModule.registerAsync with secret from ConfigService, PassportModule. Provide JwtStrategy, AuthService. Export AuthService, JwtModule.

    **apps/api/src/app.module.ts:**
    - Import AuthModule
    - Register JwtAuthGuard as APP_GUARD (global auth — all endpoints require JWT unless @Public())
  </action>
  <verify>
    ```bash
    cd apps/api && npx nest build  # Build succeeds
    # Start API and test:
    cd apps/api && node dist/main.js &
    sleep 3
    # Public endpoint works:
    curl -s http://localhost:3001/api/health | jq .status
    # Signup works:
    TOKEN=$(curl -s -X POST http://localhost:3001/api/auth/signup -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"TestPass1","name":"Test User"}' | jq -r .accessToken)
    echo "Token: $TOKEN"
    # Auth endpoint works with token:
    curl -s http://localhost:3001/api/auth/me -H "Authorization: Bearer $TOKEN" | jq .
    # Auth endpoint fails without token:
    curl -s http://localhost:3001/api/auth/me | jq .statusCode  # Should be 401
    kill %1
    ```
  </verify>
  <done>
    JWT authentication fully working on NestJS API. Global JwtAuthGuard protects all endpoints except @Public() ones. JWT strategy re-validates user from DB on each request. Auth endpoints: POST /auth/signup, POST /auth/login (public), GET /auth/me (protected). @CurrentUser decorator extracts user. @Roles decorator marks required roles.
  </done>
</task>

<task type="auto">
  <name>Task 2: CASL ability factory with three-role RBAC and user management endpoints</name>
  <files>
    apps/api/src/core/rbac/ability.factory.ts
    apps/api/src/core/rbac/rbac.guard.ts
    apps/api/src/core/rbac/rbac.module.ts
    apps/api/src/core/rbac/decorators/check-ability.decorator.ts
    apps/api/src/modules/users/users.module.ts
    apps/api/src/modules/users/users.service.ts
    apps/api/src/modules/users/users.controller.ts
    apps/api/src/modules/users/dto/update-profile.dto.ts
    apps/api/src/app.module.ts
  </files>
  <action>
    Install CASL:
    ```bash
    npm install @casl/ability @casl/prisma --workspace=apps/api
    ```

    **apps/api/src/core/rbac/ability.factory.ts:**
    As shown in research Pattern 6 (CASL Ability Factory):
    - Subjects: 'User', 'Project', 'Task', 'AuditLog', 'all'
    - Actions: 'create', 'read', 'update', 'delete', 'manage'
    - ADMIN: can('manage', 'all') — full access
    - MANAGER: can read/create/update Projects (same org), can read/create/update Tasks, can read Users (same org), cannot delete Projects they don't own, cannot manage AuditLog
    - MEMBER: can read Projects (same org), can read Tasks, can update Tasks (assigned to them), can read Users (same org), can update own User profile, cannot create/delete anything except own data

    Note: Organization scoping will be refined in Phase 2 when teams exist. For Phase 1, scope by role only. Keep the factory extensible.

    **apps/api/src/core/rbac/decorators/check-ability.decorator.ts:**
    Custom decorator that stores required action + subject on metadata:
    ```typescript
    @CheckAbility('read', 'User')  // or @CheckAbility('manage', 'all')
    ```
    Use SetMetadata with a key like 'check_ability'.

    **apps/api/src/core/rbac/rbac.guard.ts:**
    CanActivate guard:
    - Read 'check_ability' metadata from handler
    - If no metadata, allow (no restriction)
    - Get user from request
    - Build ability using AbilityFactory.createForUser(user)
    - Check ability.can(action, subject)
    - If denied: throw ForbiddenException('Forbidden: You do not have permission to perform this action')
    - IMPORTANT: Do NOT just return false — throw explicit exception with message (RBAC-06)

    **apps/api/src/core/rbac/rbac.module.ts:**
    Global module providing AbilityFactory and RbacGuard. Export AbilityFactory for use in services.

    **apps/api/src/modules/users/dto/update-profile.dto.ts:**
    Use createZodDto from nestjs-zod with updateProfileSchema from @repo/shared.

    **apps/api/src/modules/users/users.service.ts:**
    - `findAll(user)`: uses accessibleBy(ability, 'read').User to filter users at DB level
    - `findById(id, user)`: check ability.can('read', 'User') + find by id
    - `updateProfile(id, dto, user)`: check user is updating own profile (or admin). Use updateProfileSchema validation.
    - `updateRole(targetUserId, newRole, actor)`: ADMIN only. Update user role. Return updated user.

    **apps/api/src/modules/users/users.controller.ts:**
    - GET /users: @CheckAbility('read', 'User') — list users (filtered by role permissions)
    - GET /users/:id: @CheckAbility('read', 'User') — get single user
    - PATCH /users/:id/profile: @CheckAbility('update', 'User') — update profile
    - PATCH /users/:id/role: @CheckAbility('manage', 'User') — Admin only, change role
    - All endpoints with @ApiTags('users') and Swagger docs

    **apps/api/src/app.module.ts:**
    Import RbacModule and UsersModule. Register RbacGuard as APP_GUARD after JwtAuthGuard (guard order matters).

    IMPORTANT: Guard execution order in NestJS is:
    1. JwtAuthGuard (authenticates user)
    2. RbacGuard (authorizes action)
    This ensures user is always available when RBAC check runs.
  </action>
  <verify>
    ```bash
    cd apps/api && npx nest build  # Build succeeds
    cd apps/api && node dist/main.js &
    sleep 3

    # Create admin user (directly in DB for testing):
    # Or create via signup and manually change role

    # Signup as regular member:
    MEMBER_TOKEN=$(curl -s -X POST http://localhost:3001/api/auth/signup -H "Content-Type: application/json" -d '{"email":"member@test.com","password":"TestPass1","name":"Member User"}' | jq -r .accessToken)

    # Member can read users:
    curl -s http://localhost:3001/api/users -H "Authorization: Bearer $MEMBER_TOKEN" | jq .

    # Member cannot change roles (should get 403):
    curl -s -X PATCH http://localhost:3001/api/users/some-id/role -H "Authorization: Bearer $MEMBER_TOKEN" -H "Content-Type: application/json" -d '{"role":"ADMIN"}' | jq .statusCode  # 403

    kill %1
    ```
  </verify>
  <done>
    CASL ability factory defines permissions for Admin (full access), Manager (CRUD projects/tasks, read users), and Member (read-only + own profile + assigned tasks). RbacGuard checks permissions before every protected handler. @CheckAbility decorator marks required permissions. Users controller enforces RBAC: GET /users (all roles, filtered), PATCH /users/:id/role (admin only), PATCH /users/:id/profile (own profile). Unauthorized actions return 403 with clear error message.
  </done>
</task>

</tasks>

<verification>
1. POST /auth/signup creates user and returns JWT → 201
2. POST /auth/login validates credentials and returns JWT → 200
3. GET /auth/me with valid JWT returns user → 200
4. GET /auth/me without JWT returns → 401
5. Member calls PATCH /users/:id/role → 403 "Forbidden"
6. Admin calls PATCH /users/:id/role → 200 (role updated)
7. Member calls GET /users → 200 (filtered list)
8. Member calls PATCH /own-id/profile → 200 (profile updated)
9. Member calls PATCH /other-id/profile → 403 "Forbidden"
10. Swagger docs at /api/docs show all endpoints with auth requirements
</verification>

<success_criteria>
- JWT strategy authenticates every non-public endpoint
- CASL ability factory implements three-role permissions (Admin, Manager, Member)
- RbacGuard enforces permissions at controller level
- accessibleBy filters data at database level
- Clear "Forbidden" errors with descriptive messages for denied actions
- Users controller demonstrates RBAC: list (all), update profile (own), update role (admin)
- Guard execution order: JWT auth first, then RBAC
- All endpoints documented in Swagger
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-06-SUMMARY.md`
</output>
