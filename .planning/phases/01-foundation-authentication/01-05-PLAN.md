---
phase: 01-foundation-authentication
plan: 05
type: execute
wave: 4
depends_on: ["01-04"]
files_modified:
  - apps/web/app/(auth)/reset-password/page.tsx
  - apps/web/app/(auth)/reset-password/[token]/page.tsx
  - apps/web/app/(auth)/reset-password/actions.ts
  - apps/web/components/auth/reset-password-request-form.tsx
  - apps/web/components/auth/reset-password-form.tsx
  - apps/web/app/(dashboard)/profile/page.tsx
  - apps/web/app/(dashboard)/profile/actions.ts
  - apps/web/components/auth/profile-form.tsx
  - apps/web/components/auth/change-password-form.tsx
  - apps/web/lib/email.ts
autonomous: true

must_haves:
  truths:
    - "User can request password reset by entering email, and a reset token is created in the database"
    - "User can reset password using a valid token via /reset-password/[token]"
    - "User can view their profile information (name, email, role)"
    - "User can edit their name and profile picture URL"
    - "User can change their password by providing current password and new password"
  artifacts:
    - path: "apps/web/app/(auth)/reset-password/page.tsx"
      provides: "Password reset request page"
      contains: "ResetPasswordRequestForm"
    - path: "apps/web/app/(auth)/reset-password/[token]/page.tsx"
      provides: "Password reset page with token"
      contains: "ResetPasswordForm"
    - path: "apps/web/app/(dashboard)/profile/page.tsx"
      provides: "Profile view and edit page"
      contains: "ProfileForm"
    - path: "apps/web/lib/email.ts"
      provides: "Email utility (console log for dev, real email later)"
      contains: "sendResetPasswordEmail"
  key_links:
    - from: "apps/web/app/(auth)/reset-password/actions.ts"
      to: "@repo/database"
      via: "Creates VerificationToken and updates user password"
      pattern: "prisma\\.verificationToken"
    - from: "apps/web/app/(dashboard)/profile/actions.ts"
      to: "@repo/shared/validators"
      via: "Uses updateProfileSchema and changePasswordSchema for validation"
      pattern: "updateProfileSchema|changePasswordSchema"
---

<objective>
Complete the remaining auth flows: password reset via email token and user profile management (view, edit, change password).

Purpose: Completes AUTH-04 (password reset), AUTH-05 (profile view/edit). These are required for the auth system to be complete. Password reset demonstrates security best practices (token expiration, one-time use). Profile management shows user data handling.

Output: Password reset flow (request -> email -> reset), profile view/edit page with password change.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement password reset flow with token generation and validation</name>
  <files>
    apps/web/app/(auth)/reset-password/page.tsx
    apps/web/app/(auth)/reset-password/[token]/page.tsx
    apps/web/app/(auth)/reset-password/actions.ts
    apps/web/components/auth/reset-password-request-form.tsx
    apps/web/components/auth/reset-password-form.tsx
    apps/web/lib/email.ts
  </files>
  <action>
    **apps/web/lib/email.ts:**
    Email utility with dev-mode fallback. For now, log to console (production email integration is deferred). Create a `sendResetPasswordEmail(email: string, token: string)` function that:
    - In development: logs the reset URL to console as `[EMAIL] Reset password: http://localhost:3000/reset-password/{token}`
    - In production: placeholder for future SMTP integration (just throw "Not configured" for now)
    - This is acceptable for portfolio demo — document the production approach in code comments

    **apps/web/app/(auth)/reset-password/actions.ts:**
    Server actions for password reset:

    1. `requestPasswordReset(formData)`:
       - Validate email with resetPasswordRequestSchema from @repo/shared
       - Find user by email (if not found, STILL return success to prevent email enumeration)
       - Generate secure random token: `crypto.randomUUID()` (NOT predictable tokens)
       - Delete any existing tokens for this email (one active token at a time)
       - Create VerificationToken in DB: { identifier: email, token, expires: 1 hour from now, type: 'password-reset' }
       - Call sendResetPasswordEmail with email and token
       - Return { success: true } (same response whether user exists or not)

    2. `resetPassword(formData)`:
       - Validate with resetPasswordSchema from @repo/shared (token + new password)
       - Find VerificationToken by token where type='password-reset' and expires > now
       - If not found or expired: return { error: 'Invalid or expired reset link' }
       - Find user by token.identifier (email)
       - Hash new password with bcrypt (12 rounds)
       - Update user password in DB
       - Delete the used token (one-time use)
       - Return { success: true }

    **apps/web/components/auth/reset-password-request-form.tsx:**
    Client component with email field. Uses zodResolver(resetPasswordRequestSchema). On success, show message "If an account exists with that email, we've sent a reset link." (same message regardless of email existence).

    **apps/web/components/auth/reset-password-form.tsx:**
    Client component with password field (and confirm password for UX). Takes token as prop. Uses zodResolver(resetPasswordSchema). On success, redirect to /login with success message.

    **apps/web/app/(auth)/reset-password/page.tsx:** Renders ResetPasswordRequestForm.
    **apps/web/app/(auth)/reset-password/[token]/page.tsx:** Renders ResetPasswordForm with token from params.
  </action>
  <verify>
    ```bash
    cd apps/web && npx next build 2>&1 | tail -3  # Build succeeds
    ```
    Manual test flow:
    1. Create test user via signup
    2. Visit /reset-password, enter email, submit
    3. Check console for reset URL with token
    4. Visit /reset-password/{token}, enter new password, submit
    5. Login with new password → succeeds
    6. Try same token again → "Invalid or expired reset link"
  </verify>
  <done>
    Password reset flow complete: request page sends token (logged to console in dev), reset page validates token and updates password. Tokens are one-time use with 1-hour expiry. Email enumeration prevented by consistent response messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement profile view/edit page with password change</name>
  <files>
    apps/web/app/(dashboard)/profile/page.tsx
    apps/web/app/(dashboard)/profile/actions.ts
    apps/web/components/auth/profile-form.tsx
    apps/web/components/auth/change-password-form.tsx
  </files>
  <action>
    **apps/web/app/(dashboard)/profile/actions.ts:**
    Server actions for profile management:

    1. `updateProfile(formData)`:
       - Get session via auth() — reject if not authenticated
       - Validate with updateProfileSchema from @repo/shared
       - Update user in DB: `prisma.user.update({ where: { id: session.user.id }, data: validated })`
       - IMPORTANT: Never accept userId from form data — always use session.user.id (prevents IDOR)
       - Return updated user data

    2. `changePassword(formData)`:
       - Get session via auth() — reject if not authenticated
       - Validate with changePasswordSchema from @repo/shared
       - Fetch user from DB to get current password hash
       - Compare currentPassword with stored hash using bcrypt.compare
       - If no match: return { error: 'Current password is incorrect' }
       - Hash new password with bcrypt (12 rounds)
       - Update password in DB
       - Return { success: true }

    **apps/web/components/auth/profile-form.tsx:**
    Client component:
    - Pre-populated form with current name and image URL
    - React Hook Form with zodResolver(updateProfileSchema)
    - Shows email and role as read-only fields (cannot be changed by user)
    - Submit calls updateProfile server action
    - Shows success/error feedback

    **apps/web/components/auth/change-password-form.tsx:**
    Client component:
    - Fields: current password, new password, confirm new password
    - React Hook Form with zodResolver(changePasswordSchema)
    - Client-side check: new password !== current password
    - Client-side check: new password === confirm password
    - Submit calls changePassword server action
    - Shows success/error feedback

    **apps/web/app/(dashboard)/profile/page.tsx:**
    Server component:
    - Get session via auth()
    - Fetch full user profile from DB (name, email, role, image, createdAt)
    - Render ProfileForm and ChangePasswordForm in sections
    - Show "Member since {date}" info
  </action>
  <verify>
    ```bash
    cd apps/web && npx next build 2>&1 | tail -3  # Build succeeds
    ```
    Manual test flow:
    1. Login and visit /profile
    2. See current name, email (read-only), role (read-only)
    3. Change name → see updated name after refresh
    4. Change password with correct current password → succeeds
    5. Change password with wrong current password → error message
    6. Login with new password → succeeds
  </verify>
  <done>
    Profile page at /profile shows user info. User can edit name and image URL. User can change password with current password verification. Email and role displayed as read-only. All mutations use session.user.id (not form data) to prevent IDOR attacks.
  </done>
</task>

</tasks>

<verification>
1. Password reset request creates token in DB (visible in console log)
2. Password reset with valid token updates password and deletes token
3. Password reset with expired/used token shows error
4. Profile page shows current user info (name, email, role)
5. Profile update changes name successfully
6. Password change with correct current password succeeds
7. Password change with wrong current password fails
8. All forms use shared Zod schemas for validation
</verification>

<success_criteria>
- Password reset flow: request -> token creation -> reset -> one-time use token
- Email enumeration prevented (same response for existing/non-existing emails)
- Profile shows user info with edit capability for name/image
- Password change requires current password verification
- All mutations authenticate via session (no user ID in form data)
- Zod validation on both client and server using @repo/shared schemas
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-05-SUMMARY.md`
</output>
