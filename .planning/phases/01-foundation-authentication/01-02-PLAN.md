---
phase: 01-foundation-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/database/prisma/schema.prisma
  - packages/database/src/client.ts
  - packages/database/src/index.ts
  - packages/shared/src/types/user.ts
  - packages/shared/src/types/session.ts
  - packages/shared/src/types/enums.ts
  - packages/shared/src/types/audit.ts
  - packages/shared/src/types/index.ts
  - packages/shared/src/validators/auth.schema.ts
  - packages/shared/src/validators/user.schema.ts
  - packages/shared/src/validators/index.ts
  - packages/shared/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Prisma schema generates client without errors and migrations apply to Docker Postgres"
    - "Zod validation schemas for signup, login, and password reset validate correct inputs and reject invalid ones"
    - "TypeScript types for User, Session, and Role enum are importable from @repo/shared in both apps"
    - "Database has proper indexes on all foreign keys and commonly queried columns"
  artifacts:
    - path: "packages/database/prisma/schema.prisma"
      provides: "User, Account, Session, VerificationToken, AuditLog models"
      contains: "model User"
    - path: "packages/shared/src/validators/auth.schema.ts"
      provides: "signUpSchema, loginSchema, resetPasswordSchema, changePasswordSchema"
      contains: "signUpSchema"
    - path: "packages/shared/src/types/enums.ts"
      provides: "UserRole enum (ADMIN, MANAGER, MEMBER)"
      contains: "UserRole"
    - path: "packages/database/src/client.ts"
      provides: "Prisma client singleton"
      contains: "PrismaClient"
  key_links:
    - from: "packages/shared/src/validators/auth.schema.ts"
      to: "packages/shared/src/types/user.ts"
      via: "z.infer generates types matching TypeScript interfaces"
      pattern: "z\\.infer"
    - from: "packages/database/src/client.ts"
      to: "packages/database/prisma/schema.prisma"
      via: "Prisma generate creates typed client"
      pattern: "PrismaClient"
---

<objective>
Create the database schema with Prisma and shared validation/type packages that serve as the single source of truth for both frontend and backend.

Purpose: All authentication, RBAC, and audit features depend on the data models and validation schemas. This plan establishes the data foundation. Covers TECH-02 (shared types), TECH-03 (Zod validation), TECH-06 (database indexes).

Output: Prisma schema with migrations applied, Zod schemas for auth flows, shared TypeScript types.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Prisma schema with auth and audit models</name>
  <files>
    packages/database/prisma/schema.prisma
    packages/database/src/client.ts
    packages/database/src/index.ts
  </files>
  <action>
    **packages/database/prisma/schema.prisma:**

    Datasource: postgresql, url from env("DATABASE_URL")
    Generator: prisma-client-js

    **Models:**

    ```
    enum UserRole {
      ADMIN
      MANAGER
      MEMBER
    }

    model User {
      id             String    @id @default(cuid())
      email          String    @unique
      name           String?
      password       String?        // Hashed with bcrypt
      role           UserRole  @default(MEMBER)
      emailVerified  DateTime?
      image          String?
      createdAt      DateTime  @default(now())
      updatedAt      DateTime  @updatedAt

      accounts       Account[]
      sessions       Session[]
      auditLogs      AuditLog[]  @relation("AuditActor")

      @@index([email])
      @@index([role])
    }

    model Account {
      id                String  @id @default(cuid())
      userId            String
      type              String
      provider          String
      providerAccountId String
      refresh_token     String? @db.Text
      access_token      String? @db.Text
      expires_at        Int?
      token_type        String?
      scope             String?
      id_token          String? @db.Text
      session_state     String?

      user User @relation(fields: [userId], references: [id], onDelete: Cascade)

      @@unique([provider, providerAccountId])
      @@index([userId])
    }

    model Session {
      id           String   @id @default(cuid())
      sessionToken String   @unique
      userId       String
      expires      DateTime

      user User @relation(fields: [userId], references: [id], onDelete: Cascade)

      @@index([userId])
    }

    model VerificationToken {
      identifier String
      token      String   @unique
      expires    DateTime
      type       String   @default("email")  // email, password-reset

      @@unique([identifier, token])
    }

    model AuditLog {
      id          String   @id @default(cuid())
      entityType  String          // User, Task, Project, etc.
      entityId    String?         // ID of affected entity
      action      String          // LOGIN, LOGOUT, ROLE_CHANGED, etc.
      actorId     String?         // Who performed the action
      outcome     String   @default("SUCCESS")  // SUCCESS, DENIED, FAILURE
      changes     Json?           // { field, from, to } for mutations
      metadata    Json?           // { ipAddress, userAgent, requestId }
      timestamp   DateTime @default(now())

      actor       User?    @relation("AuditActor", fields: [actorId], references: [id])

      @@index([entityType, entityId])
      @@index([actorId])
      @@index([action])
      @@index([timestamp])
    }
    ```

    **packages/database/src/client.ts:**
    Create a Prisma client singleton pattern (prevent multiple instances in dev with hot reload):
    ```typescript
    import { PrismaClient } from '@prisma/client';

    const globalForPrisma = globalThis as unknown as { prisma: PrismaClient };

    export const prisma = globalForPrisma.prisma || new PrismaClient({
      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
    });

    if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
    ```

    **packages/database/src/index.ts:**
    Re-export: `export { prisma } from './client';` and `export * from '@prisma/client';`

    After creating files, generate the Prisma client and run migration:
    ```bash
    cd packages/database && npx prisma generate && npx prisma db push
    ```
    Use `db push` for initial development (not migrate, which is for production).
  </action>
  <verify>
    ```bash
    cd packages/database && npx prisma db push --accept-data-loss 2>&1 | grep "applied"
    cd packages/database && npx prisma studio --port 5556 &  # Opens browser to verify tables exist, then kill
    ```
    Or verify with: `cd packages/database && npx prisma db execute --stdin <<< "SELECT tablename FROM pg_tables WHERE schemaname='public';"`
  </verify>
  <done>
    Prisma schema defines User (with role enum), Account, Session, VerificationToken, and AuditLog models. All foreign keys have indexes. Prisma client generates successfully and schema is pushed to Docker Postgres database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shared Zod validators and TypeScript types</name>
  <files>
    packages/shared/src/types/user.ts
    packages/shared/src/types/session.ts
    packages/shared/src/types/enums.ts
    packages/shared/src/types/audit.ts
    packages/shared/src/types/index.ts
    packages/shared/src/validators/auth.schema.ts
    packages/shared/src/validators/user.schema.ts
    packages/shared/src/validators/index.ts
    packages/shared/src/index.ts
  </files>
  <action>
    **packages/shared/src/types/enums.ts:**
    ```typescript
    export const UserRole = {
      ADMIN: 'ADMIN',
      MANAGER: 'MANAGER',
      MEMBER: 'MEMBER',
    } as const;
    export type UserRole = (typeof UserRole)[keyof typeof UserRole];

    export const AuditAction = {
      LOGIN: 'LOGIN',
      LOGOUT: 'LOGOUT',
      LOGIN_FAILED: 'LOGIN_FAILED',
      SIGNUP: 'SIGNUP',
      PASSWORD_RESET_REQUEST: 'PASSWORD_RESET_REQUEST',
      PASSWORD_RESET_COMPLETE: 'PASSWORD_RESET_COMPLETE',
      PASSWORD_CHANGED: 'PASSWORD_CHANGED',
      ROLE_CHANGED: 'ROLE_CHANGED',
      PROFILE_UPDATED: 'PROFILE_UPDATED',
      AUTHORIZATION_DENIED: 'AUTHORIZATION_DENIED',
    } as const;
    export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction];

    export const AuditOutcome = {
      SUCCESS: 'SUCCESS',
      DENIED: 'DENIED',
      FAILURE: 'FAILURE',
    } as const;
    export type AuditOutcome = (typeof AuditOutcome)[keyof typeof AuditOutcome];
    ```

    **packages/shared/src/types/user.ts:**
    ```typescript
    import { UserRole } from './enums';

    export interface UserBase {
      id: string;
      email: string;
      name: string | null;
      role: UserRole;
    }

    export interface UserProfile extends UserBase {
      image: string | null;
      createdAt: Date;
      updatedAt: Date;
    }

    export interface SessionUser extends UserBase {
      // Minimal user data stored in JWT/session
    }
    ```

    **packages/shared/src/types/session.ts:**
    ```typescript
    import { SessionUser } from './user';

    export interface AuthSession {
      user: SessionUser;
      expires: string;
      accessToken?: string;
    }
    ```

    **packages/shared/src/types/audit.ts:**
    ```typescript
    import { AuditAction, AuditOutcome } from './enums';

    export interface AuditLogEntry {
      id: string;
      entityType: string;
      entityId: string | null;
      action: AuditAction;
      actorId: string | null;
      outcome: AuditOutcome;
      changes: Record<string, unknown> | null;
      metadata: AuditMetadata | null;
      timestamp: Date;
    }

    export interface AuditMetadata {
      ipAddress: string;
      userAgent: string;
      requestId?: string;
    }
    ```

    **packages/shared/src/validators/auth.schema.ts:**
    ```typescript
    import { z } from 'zod';

    export const signUpSchema = z.object({
      email: z.string().email('Invalid email address'),
      password: z
        .string()
        .min(8, 'Password must be at least 8 characters')
        .regex(/[A-Z]/, 'Password must contain an uppercase letter')
        .regex(/[a-z]/, 'Password must contain a lowercase letter')
        .regex(/[0-9]/, 'Password must contain a number'),
      name: z.string().min(2, 'Name must be at least 2 characters').max(100, 'Name must be under 100 characters'),
    });

    export const loginSchema = z.object({
      email: z.string().email('Invalid email address'),
      password: z.string().min(1, 'Password is required'),
    });

    export const resetPasswordRequestSchema = z.object({
      email: z.string().email('Invalid email address'),
    });

    export const resetPasswordSchema = z.object({
      token: z.string().min(1, 'Token is required'),
      password: z
        .string()
        .min(8, 'Password must be at least 8 characters')
        .regex(/[A-Z]/, 'Password must contain an uppercase letter')
        .regex(/[a-z]/, 'Password must contain a lowercase letter')
        .regex(/[0-9]/, 'Password must contain a number'),
    });

    export const changePasswordSchema = z.object({
      currentPassword: z.string().min(1, 'Current password is required'),
      newPassword: z
        .string()
        .min(8, 'Password must be at least 8 characters')
        .regex(/[A-Z]/, 'Password must contain an uppercase letter')
        .regex(/[a-z]/, 'Password must contain a lowercase letter')
        .regex(/[0-9]/, 'Password must contain a number'),
    });

    // Inferred types
    export type SignUpDto = z.infer<typeof signUpSchema>;
    export type LoginDto = z.infer<typeof loginSchema>;
    export type ResetPasswordRequestDto = z.infer<typeof resetPasswordRequestSchema>;
    export type ResetPasswordDto = z.infer<typeof resetPasswordSchema>;
    export type ChangePasswordDto = z.infer<typeof changePasswordSchema>;
    ```

    **packages/shared/src/validators/user.schema.ts:**
    ```typescript
    import { z } from 'zod';

    export const updateProfileSchema = z.object({
      name: z.string().min(2, 'Name must be at least 2 characters').max(100).optional(),
      image: z.string().url('Invalid URL').optional().nullable(),
    });

    export type UpdateProfileDto = z.infer<typeof updateProfileSchema>;
    ```

    **Index files:** Re-export all types and validators from their respective index.ts files.
    **packages/shared/src/index.ts:** Re-export from './types' and './validators'.

    Verify types compile:
    ```bash
    cd packages/shared && npx tsc --noEmit
    ```
  </action>
  <verify>
    ```bash
    cd packages/shared && npx tsc --noEmit  # No type errors
    # Test import from web app context:
    node -e "const z = require('zod'); console.log('zod ok');"
    ```
    Verify Zod schema validation works:
    ```bash
    node -e "
      const { signUpSchema } = require('./packages/shared/src/validators/auth.schema');
      console.log(signUpSchema.safeParse({email:'test@x.com', password:'Abcdef1!', name:'Jo'}).success);
      console.log(signUpSchema.safeParse({email:'bad', password:'short', name:''}).success);
    "
    ```
    First should return true, second should return false.
  </verify>
  <done>
    Shared types (UserRole, UserBase, SessionUser, AuditLogEntry) and Zod validators (signUpSchema, loginSchema, resetPasswordSchema, changePasswordSchema, updateProfileSchema) exist in @repo/shared. Types compile without errors. Validators correctly accept valid input and reject invalid input. Both apps can import via @repo/shared/types and @repo/shared/validators.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma db push` applies schema to Postgres without errors
2. `SELECT tablename FROM pg_tables WHERE schemaname='public'` shows User, Account, Session, VerificationToken, AuditLog tables
3. `npx tsc --noEmit` in packages/shared passes
4. signUpSchema.safeParse validates correctly
5. @repo/shared and @repo/database are importable from apps
</verification>

<success_criteria>
- Prisma schema has User (with role), Account, Session, VerificationToken, AuditLog models with proper indexes
- Zod schemas validate auth flows (signup, login, password reset, change password, profile update)
- TypeScript types are importable from @repo/shared by both apps
- Database tables created in Docker Postgres
- All foreign keys have indexes (@@index directives)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-02-SUMMARY.md`
</output>
