---
phase: 01-foundation-authentication
plan: 07
type: execute
wave: 5
depends_on: ["01-05", "01-06"]
files_modified:
  - apps/api/src/core/audit/audit.module.ts
  - apps/api/src/core/audit/audit.service.ts
  - apps/api/src/core/audit/audit.listener.ts
  - apps/api/src/core/audit/decorators/audit-log.decorator.ts
  - apps/api/src/core/audit/interceptors/audit.interceptor.ts
  - packages/shared/src/types/events.ts
  - packages/shared/src/types/index.ts
  - apps/api/src/modules/events/events.module.ts
  - apps/api/src/modules/events/events.gateway.ts
  - apps/api/src/common/guards/ws-auth.guard.ts
  - apps/api/src/app.module.ts
  - apps/api/package.json
  - apps/web/lib/websocket.ts
autonomous: false

must_haves:
  truths:
    - "System logs authentication events (login success, login failure, signup, logout) with IP and user agent"
    - "System logs authorization failures (403 responses) with attempted action and actor context"
    - "System logs RBAC changes (role assignments) with who changed whom and from/to roles"
    - "Audit log entries include: who (actorId), what (action), when (timestamp), IP address, user agent"
    - "WebSocket connections with valid JWT are accepted and assigned to user rooms"
    - "WebSocket connections without valid JWT are rejected immediately"
  artifacts:
    - path: "apps/api/src/core/audit/audit.service.ts"
      provides: "Audit logging service writing to AuditLog table"
      contains: "AuditService"
    - path: "apps/api/src/core/audit/audit.listener.ts"
      provides: "Event listeners for auth, RBAC, and authorization events"
      contains: "@OnEvent"
    - path: "packages/shared/src/types/events.ts"
      provides: "Domain event types for audit system"
      contains: "AuthEvent"
    - path: "apps/api/src/modules/events/events.gateway.ts"
      provides: "WebSocket gateway with JWT authentication"
      contains: "EventsGateway"
    - path: "apps/api/src/common/guards/ws-auth.guard.ts"
      provides: "WebSocket JWT auth guard"
      contains: "WsAuthGuard"
  key_links:
    - from: "apps/api/src/core/audit/audit.listener.ts"
      to: "apps/api/src/core/audit/audit.service.ts"
      via: "Event listeners call audit service to persist"
      pattern: "auditService\\.log"
    - from: "apps/api/src/modules/auth/auth.service.ts"
      to: "@nestjs/event-emitter"
      via: "Auth service emits events on login/signup/failure"
      pattern: "eventEmitter\\.emit"
    - from: "apps/api/src/core/rbac/rbac.guard.ts"
      to: "@nestjs/event-emitter"
      via: "RBAC guard emits authorization.denied event on 403"
      pattern: "eventEmitter\\.emit.*authorization"
    - from: "apps/api/src/common/guards/ws-auth.guard.ts"
      to: "@nestjs/jwt"
      via: "Validates JWT token from socket handshake"
      pattern: "jwtService\\.verifyAsync"
---

<objective>
Implement event-driven audit logging system capturing all authentication events, authorization failures, and RBAC changes. Add WebSocket gateway with JWT authentication. Final verification of complete Phase 1.

Purpose: Completes the audit logging requirements (AUDIT-01 through AUDIT-04, AUDIT-07) and WebSocket auth (TECH-08). The audit system uses domain events for decoupled, complete logging. WebSocket auth establishes the pattern for Phase 3 real-time features.

Output: Complete audit trail for auth/RBAC events, authenticated WebSocket gateway, verified Phase 1 system.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-05-SUMMARY.md
@.planning/phases/01-foundation-authentication/01-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Event-driven audit logging system</name>
  <files>
    apps/api/package.json
    packages/shared/src/types/events.ts
    packages/shared/src/types/index.ts
    apps/api/src/core/audit/audit.module.ts
    apps/api/src/core/audit/audit.service.ts
    apps/api/src/core/audit/audit.listener.ts
    apps/api/src/core/audit/decorators/audit-log.decorator.ts
    apps/api/src/core/audit/interceptors/audit.interceptor.ts
    apps/api/src/app.module.ts
  </files>
  <action>
    Install event emitter:
    ```bash
    npm install @nestjs/event-emitter --workspace=apps/api
    ```

    **packages/shared/src/types/events.ts:**
    Domain event interfaces:
    ```typescript
    import { AuditAction, AuditOutcome } from './enums';

    export interface AuditEventPayload {
      entityType: string;
      entityId?: string;
      action: AuditAction;
      actorId?: string;
      outcome: AuditOutcome;
      changes?: Record<string, unknown>;
      metadata: {
        ipAddress: string;
        userAgent: string;
        requestId?: string;
      };
    }

    // Specific event types for type safety
    export interface AuthEvent extends AuditEventPayload {
      entityType: 'User';
      action: 'LOGIN' | 'LOGOUT' | 'LOGIN_FAILED' | 'SIGNUP' | 'PASSWORD_RESET_REQUEST' | 'PASSWORD_RESET_COMPLETE' | 'PASSWORD_CHANGED';
    }

    export interface RbacEvent extends AuditEventPayload {
      entityType: 'User';
      action: 'ROLE_CHANGED';
      changes: {
        field: 'role';
        from: string;
        to: string;
      };
    }

    export interface AuthorizationDeniedEvent extends AuditEventPayload {
      entityType: string;
      action: 'AUTHORIZATION_DENIED';
      outcome: 'DENIED';
      changes: {
        attemptedAction: string;
        requiredPermission: string;
      };
    }
    ```

    Update packages/shared/src/types/index.ts to re-export events.

    **apps/api/src/core/audit/audit.service.ts:**
    Injectable service:
    - `log(payload: AuditEventPayload)`: creates AuditLog entry in DB via Prisma
    - Includes timestamp (now), all fields from payload
    - Use try/catch — audit logging should NEVER crash the main operation. Log failures to console.error but don't throw.
    - Async by nature (fire and forget for performance)

    **apps/api/src/core/audit/audit.listener.ts:**
    Event listeners using @OnEvent from @nestjs/event-emitter:
    - `@OnEvent('auth.login')` → logs LOGIN success
    - `@OnEvent('auth.login.failed')` → logs LOGIN_FAILED
    - `@OnEvent('auth.signup')` → logs SIGNUP
    - `@OnEvent('auth.logout')` → logs LOGOUT
    - `@OnEvent('auth.password.reset.request')` → logs PASSWORD_RESET_REQUEST
    - `@OnEvent('auth.password.reset.complete')` → logs PASSWORD_RESET_COMPLETE
    - `@OnEvent('auth.password.changed')` → logs PASSWORD_CHANGED
    - `@OnEvent('rbac.role.changed')` → logs ROLE_CHANGED with from/to
    - `@OnEvent('authorization.denied')` → logs AUTHORIZATION_DENIED
    All handlers marked { async: true } to not block the main thread.

    **apps/api/src/core/audit/interceptors/audit.interceptor.ts:**
    NestJS interceptor that extracts IP address and user agent from request and attaches to request object for use by event emitters. Gets IP from req.ip or x-forwarded-for header, user agent from req.headers['user-agent'].

    **apps/api/src/core/audit/decorators/audit-log.decorator.ts:**
    Custom method decorator that automatically emits an audit event after successful execution. Usage: `@AuditLog('auth.login')`. Uses interceptor pattern to emit event with method result and request context.

    **Now modify existing services to emit events:**

    1. **apps/api/src/modules/auth/auth.service.ts** — inject EventEmitter2:
       - After successful login: emit 'auth.login' with user context and request metadata
       - After failed login: emit 'auth.login.failed' with email and metadata
       - After signup: emit 'auth.signup' with new user context

    2. **apps/api/src/core/rbac/rbac.guard.ts** — inject EventEmitter2:
       - On ForbiddenException: emit 'authorization.denied' with user, attempted action, resource

    3. **apps/api/src/modules/users/users.service.ts** — inject EventEmitter2:
       - After role change: emit 'rbac.role.changed' with from/to roles, actor, target

    **apps/api/src/core/audit/audit.module.ts:**
    Global module. Import EventEmitterModule.forRoot(). Provide AuditService, AuditListener. Export AuditService.

    **apps/api/src/app.module.ts:**
    Import AuditModule. Register AuditInterceptor as APP_INTERCEPTOR.
  </action>
  <verify>
    ```bash
    cd apps/api && npx nest build  # Build succeeds
    cd apps/api && node dist/main.js &
    sleep 3

    # Login and check audit log:
    curl -s -X POST http://localhost:3001/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"TestPass1"}'
    # Failed login:
    curl -s -X POST http://localhost:3001/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"wrong"}'

    # Check audit logs in DB:
    docker compose exec postgres psql -U teamflow -d teamflow -c "SELECT action, outcome, metadata->>'ipAddress' as ip FROM \"AuditLog\" ORDER BY timestamp DESC LIMIT 5;"

    kill %1
    ```
    Expected: audit_logs table has entries for login success and login failure with IP and user agent.
  </verify>
  <done>
    Event-driven audit system captures: login (success/failure), signup, logout, password reset, password change, role changes, and authorization denials. Each entry includes actorId, action, outcome, timestamp, IP address, and user agent. Events are async (non-blocking). Audit failures don't crash main operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: WebSocket gateway with JWT authentication</name>
  <files>
    apps/api/src/modules/events/events.module.ts
    apps/api/src/modules/events/events.gateway.ts
    apps/api/src/common/guards/ws-auth.guard.ts
    apps/api/src/app.module.ts
    apps/api/package.json
    apps/web/lib/websocket.ts
  </files>
  <action>
    Install Socket.io for NestJS:
    ```bash
    npm install @nestjs/websockets @nestjs/platform-socket.io socket.io --workspace=apps/api
    npm install socket.io-client --workspace=apps/web
    ```

    **apps/api/src/common/guards/ws-auth.guard.ts:**
    As shown in research Pattern 5 (WebSocket Authentication):
    - CanActivate guard
    - Extract JWT from client.handshake.auth.token OR client.handshake.headers.authorization (Bearer token)
    - Verify JWT using JwtService.verifyAsync
    - Attach decoded user to client.data.user (id, email, role)
    - On failure: throw WsException('Unauthorized') which disconnects client
    - Log connection attempts for audit

    **apps/api/src/modules/events/events.gateway.ts:**
    ```typescript
    @WebSocketGateway({
      cors: {
        origin: process.env.NEXTAUTH_URL || 'http://localhost:3000',
        credentials: true,
      },
      namespace: '/',
    })
    export class EventsGateway implements OnGatewayConnection, OnGatewayDisconnect {
      @WebSocketServer() server: Server;

      constructor(
        private jwtService: JwtService,
        private eventEmitter: EventEmitter2,
      ) {}

      async handleConnection(client: Socket) {
        try {
          // Validate token (defense in depth — guard already checked, but validate again)
          const token = client.handshake.auth?.token || client.handshake.headers?.authorization?.replace('Bearer ', '');
          if (!token) {
            client.disconnect();
            return;
          }

          const payload = await this.jwtService.verifyAsync(token);
          client.data.user = { id: payload.sub, email: payload.email, role: payload.role };

          // Join user-specific room for targeted events
          client.join(`user:${payload.sub}`);

          console.log(`WS Connected: user ${payload.sub}`);
        } catch (error) {
          client.disconnect();
        }
      }

      async handleDisconnect(client: Socket) {
        if (client.data.user) {
          console.log(`WS Disconnected: user ${client.data.user.id}`);
        }
      }

      // Placeholder for Phase 3 real-time events
      @SubscribeMessage('ping')
      handlePing(client: Socket): { event: string; data: string } {
        return { event: 'pong', data: 'connected' };
      }
    }
    ```

    **apps/api/src/modules/events/events.module.ts:**
    Import JwtModule, provide EventsGateway and WsAuthGuard.

    **apps/web/lib/websocket.ts:**
    Client-side WebSocket utility:
    ```typescript
    import { io, Socket } from 'socket.io-client';

    let socket: Socket | null = null;

    export function getSocket(token: string): Socket {
      if (socket?.connected) return socket;

      socket = io(process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001', {
        auth: { token },
        reconnection: true,
        reconnectionDelay: 1000,
        reconnectionAttempts: 5,
      });

      socket.on('connect', () => console.log('WS connected'));
      socket.on('disconnect', () => console.log('WS disconnected'));
      socket.on('connect_error', (err) => console.error('WS error:', err.message));

      return socket;
    }

    export function disconnectSocket() {
      if (socket) {
        socket.disconnect();
        socket = null;
      }
    }
    ```

    **apps/api/src/app.module.ts:**
    Import EventsModule.
  </action>
  <verify>
    ```bash
    cd apps/api && npx nest build  # Build succeeds
    cd apps/api && node dist/main.js &
    sleep 3

    # Test WebSocket with valid token:
    # Get a token first:
    TOKEN=$(curl -s -X POST http://localhost:3001/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"TestPass1"}' | jq -r .accessToken)

    # Test WS connection (requires wscat):
    # wscat -c ws://localhost:3001 -H "Authorization: Bearer $TOKEN"
    # Or use a simple Node.js script:
    node -e "
      const { io } = require('socket.io-client');
      const s = io('http://localhost:3001', { auth: { token: '$TOKEN' } });
      s.on('connect', () => { console.log('CONNECTED'); s.emit('ping'); });
      s.on('pong', (d) => { console.log('PONG:', d); s.disconnect(); process.exit(0); });
      s.on('connect_error', (e) => { console.log('ERROR:', e.message); process.exit(1); });
      setTimeout(() => process.exit(1), 5000);
    "

    # Test WS connection without token (should fail):
    node -e "
      const { io } = require('socket.io-client');
      const s = io('http://localhost:3001', { auth: {} });
      s.on('connect', () => { console.log('SHOULD NOT CONNECT'); process.exit(1); });
      s.on('connect_error', (e) => { console.log('CORRECTLY REJECTED:', e.message); process.exit(0); });
      setTimeout(() => { console.log('CORRECTLY REJECTED: timeout'); process.exit(0); }, 3000);
    "

    kill %1
    ```
  </verify>
  <done>
    WebSocket gateway authenticates connections via JWT token in handshake. Valid tokens are accepted, user is attached to socket, and user-specific room is joined. Invalid/missing tokens cause immediate disconnection. Client-side utility in apps/web/lib/websocket.ts provides singleton socket with reconnection.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete Phase 1 auth system</name>
  <files>N/A — verification only</files>
  <action>
    Human verification of complete Phase 1 system. What was built:
    - Monorepo with Next.js + NestJS + shared packages
    - Docker infrastructure (Postgres + Redis)
    - NextAuth v5 with signup, login, logout, password reset, profile management
    - NestJS JWT auth with CASL-based three-role RBAC
    - Event-driven audit logging for all auth events
    - WebSocket gateway with JWT authentication
    - Shared Zod validation between frontend and backend
    - Swagger API documentation
    - Health check endpoints

    Steps to verify:

    **Prerequisites:** Docker containers running (`docker compose up -d`), both apps running.

    **1. Authentication Flow:**
    1. Visit http://localhost:3000/signup — create a new account
    2. After signup, verify you land on the dashboard with your name displayed
    3. Click logout — verify redirect to /login
    4. Visit http://localhost:3000/login — log in with same credentials
    5. Close browser completely, reopen, visit http://localhost:3000 — verify session persists
    6. Visit http://localhost:3000/reset-password — request password reset (check console for token URL)
    7. Visit the token URL, set new password, verify login works with new password

    **2. Profile Management:**
    1. Visit http://localhost:3000/profile — see your name, email, role
    2. Change your name — verify it updates
    3. Change password — verify old password stops working and new one works

    **3. RBAC (via API):**
    1. Login via API: `curl -X POST http://localhost:3001/api/auth/login -H "Content-Type: application/json" -d '{"email":"your@email.com","password":"YourPass1"}'`
    2. Try admin endpoint as Member — expect 403 Forbidden
    3. Check that 403 error message is clear and descriptive

    **4. Audit Logs:**
    1. Check audit logs: `docker compose exec postgres psql -U teamflow -d teamflow -c 'SELECT action, outcome, "actorId", metadata FROM "AuditLog" ORDER BY timestamp DESC LIMIT 10;'`
    2. Verify entries for: LOGIN, SIGNUP, LOGIN_FAILED, AUTHORIZATION_DENIED
    3. Verify metadata has ipAddress and userAgent

    **5. WebSocket:**
    1. Verify in NestJS console logs that WebSocket connections are accepted with valid JWT
    2. Verify connections without JWT are rejected

    **6. Infrastructure:**
    1. Visit http://localhost:3001/api/health — should show database, redis "up"
    2. Visit http://localhost:3001/api/docs — Swagger docs should render

    Resume signal: Type "approved" or describe issues that need fixing.
  </action>
  <verify>Human confirms all 6 verification categories pass.</verify>
  <done>All Phase 1 success criteria verified by human: auth flows, profile management, RBAC enforcement, audit logging, WebSocket auth, and infrastructure health.</done>
</task>

</tasks>

<verification>
1. Full signup → login → logout → login cycle works
2. Password reset flow (request → token → reset → login) works
3. Profile view and edit works
4. RBAC: Member gets 403 on admin endpoints, Admin can manage roles
5. Audit log has entries for login, signup, failed login, authorization denied, role changes
6. Each audit entry has actorId, action, outcome, timestamp, IP, user agent
7. WebSocket accepts authenticated connections, rejects unauthenticated
8. Health check returns database and redis status
9. Swagger docs render at /api/docs
</verification>

<success_criteria>
- Audit logging captures: login (success/failure), signup, logout, password reset, role changes, authorization denials
- Each log entry has: who, what, when, IP address, user agent
- WebSocket connections require valid JWT
- WebSocket rejects connections without/invalid JWT
- All Phase 1 success criteria from ROADMAP.md are met
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-07-SUMMARY.md`
</output>
