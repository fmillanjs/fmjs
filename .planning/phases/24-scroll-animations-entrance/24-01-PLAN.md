---
phase: 24-scroll-animations-entrance
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/components/portfolio/motion-provider.tsx
  - apps/web/components/portfolio/animate-in.tsx
  - apps/web/components/portfolio/stagger-container.tsx
  - apps/web/app/(portfolio)/layout.tsx
autonomous: true
requirements:
  - ANIM-01

must_haves:
  truths:
    - "A MotionConfig reducedMotion='user' gate wraps all portfolio children in layout.tsx"
    - "AnimateIn renders children with fade+slide-up on scroll when reduced motion is off; renders as plain element immediately when reduced motion is on"
    - "StaggerContainer sequences child StaggerItem entrances at 150ms intervals when reduced motion is off; renders as plain divs when reduced motion is on"
    - "Zero hydration warnings: server never renders opacity:0 inline style; motion applies it client-side after hydration"
  artifacts:
    - path: "apps/web/components/portfolio/motion-provider.tsx"
      provides: "MotionConfig reducedMotion='user' client provider"
      contains: "MotionConfig"
    - path: "apps/web/components/portfolio/animate-in.tsx"
      provides: "Single-element scroll reveal wrapper"
      contains: "useReducedMotion"
    - path: "apps/web/components/portfolio/stagger-container.tsx"
      provides: "Stagger parent + StaggerItem child for card grids"
      contains: "staggerChildren"
    - path: "apps/web/app/(portfolio)/layout.tsx"
      provides: "Portfolio layout with MotionProvider wrapping main"
      contains: "MotionProvider"
  key_links:
    - from: "apps/web/app/(portfolio)/layout.tsx"
      to: "apps/web/components/portfolio/motion-provider.tsx"
      via: "import + JSX wrapping main tag"
      pattern: "MotionProvider"
    - from: "apps/web/components/portfolio/animate-in.tsx"
      to: "motion/react"
      via: "import { motion, useReducedMotion }"
      pattern: "useReducedMotion"
    - from: "apps/web/components/portfolio/stagger-container.tsx"
      to: "motion/react"
      via: "import { motion, useReducedMotion }"
      pattern: "staggerChildren"
---

<objective>
Create the three animation primitive components that all portfolio pages will use, and wire the MotionConfig reduced-motion gate into the portfolio layout.

Purpose: These primitives are the shared foundation — ANIM-01 (scroll reveal on all portfolio pages) depends on them existing before any page-level application. The MotionProvider gate completes THEME-04's third layer (CSS in Phase 22, canvas RAF in Phase 23, MotionConfig here in Phase 24).

Output: motion-provider.tsx, animate-in.tsx, stagger-container.tsx (new files) + layout.tsx (modified to add MotionProvider).
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/web/app/(portfolio)/layout.tsx
@apps/web/components/portfolio/hero-section.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MotionProvider and wire into portfolio layout</name>
  <files>
    apps/web/components/portfolio/motion-provider.tsx
    apps/web/app/(portfolio)/layout.tsx
  </files>
  <action>
Create `apps/web/components/portfolio/motion-provider.tsx`:

```typescript
'use client'

import { MotionConfig } from 'motion/react'
import type { ReactNode } from 'react'

export function MotionProvider({ children }: { children: ReactNode }) {
  return (
    <MotionConfig reducedMotion="user">
      {children}
    </MotionConfig>
  )
}
```

Key points:
- MUST use `'use client'` — MotionConfig reads window.matchMedia client-side.
- Import MUST be from `motion/react` NOT `framer-motion` (per v2.5 constraint in STATE.md).
- `reducedMotion="user"` reads the OS prefers-reduced-motion setting automatically.

Then modify `apps/web/app/(portfolio)/layout.tsx` to wrap `<main>` with `MotionProvider`:
- Add import: `import { MotionProvider } from '@/components/portfolio/motion-provider'`
- Wrap `<main className="flex-1">{children}</main>` so it becomes:
  `<MotionProvider><main className="flex-1">{children}</main></MotionProvider>`
- Do NOT wrap PortfolioNav, PortfolioFooter, or CommandPalette — only main content needs motion gate.
- layout.tsx stays a Server Component (no `'use client'` needed — it only imports a client component).
  </action>
  <verify>
Run `cd /home/doctor/fernandomillan && npx tsc --project apps/web/tsconfig.json --noEmit 2>&1 | grep -E "motion-provider|layout" | head -20`

No TypeScript errors on these two files.
  </verify>
  <done>
`motion-provider.tsx` exists with `'use client'`, imports from `motion/react`, exports `MotionProvider` wrapping `MotionConfig reducedMotion="user"`. `layout.tsx` imports and uses `MotionProvider` wrapping the main tag only. TypeScript reports no errors on these files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AnimateIn single-element scroll reveal component</name>
  <files>
    apps/web/components/portfolio/animate-in.tsx
  </files>
  <action>
Create `apps/web/components/portfolio/animate-in.tsx`:

```typescript
'use client'

import { motion, useReducedMotion } from 'motion/react'
import type { ReactNode } from 'react'

type MotionTag = 'div' | 'section' | 'article'

interface AnimateInProps {
  children: ReactNode
  className?: string
  delay?: number
  as?: MotionTag
}

export function AnimateIn({
  children,
  className,
  delay = 0,
  as = 'div',
}: AnimateInProps) {
  const prefersReducedMotion = useReducedMotion()

  if (prefersReducedMotion) {
    // Render as plain element — no motion overhead, no opacity:0, instant display
    const PlainTag = as
    return <PlainTag className={className}>{children}</PlainTag>
  }

  const Component = motion[as]

  return (
    <Component
      className={className}
      initial={{ opacity: 0, y: 24 }}
      whileInView={{ opacity: 1, y: 0 }}
      viewport={{ once: true, amount: 0.2 }}
      transition={{ duration: 0.5, ease: 'easeOut', delay }}
    >
      {children}
    </Component>
  )
}
```

Key points:
- `'use client'` is REQUIRED — `useReducedMotion()` reads `window.matchMedia`, cannot run on server.
- The `prefersReducedMotion` early-return renders a plain HTML element with NO motion wrapper — this means when OS Reduce Motion is ON, elements are immediately visible with no transition at all (satisfies SC3).
- `initial={{ opacity: 0, y: 24 }}` — motion applies this client-side via DOM style API AFTER hydration (not in SSR HTML), so zero hydration warnings (satisfies SC4).
- `whileInView` + `viewport={{ once: true }}` — fires exactly once per component mount. Navigation remounts the component tree, so each page visit gets one animation (satisfies SC5).
- `y: 24` = translateY(24px) — uses CSS transform, NOT `top`/`margin`. Zero CLS risk.
- Only animate `opacity` and `y` — NEVER `height`, `width`, `margin`, `padding` (per v2.5 constraint).
- `amount: 0.2` — triggers when 20% of element enters viewport, gives time to animate before fully visible.
  </action>
  <verify>
Run `cd /home/doctor/fernandomillan && npx tsc --project apps/web/tsconfig.json --noEmit 2>&1 | grep "animate-in" | head -10`

No TypeScript errors on animate-in.tsx.
  </verify>
  <done>
`animate-in.tsx` exists with `'use client'`, imports from `motion/react`, exports `AnimateIn`. Component returns plain element when `useReducedMotion()` is true; returns motion component with `whileInView`, `viewport={{ once: true, amount: 0.2 }}`, `initial={{ opacity: 0, y: 24 }}` otherwise. TypeScript reports no errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create StaggerContainer and StaggerItem components</name>
  <files>
    apps/web/components/portfolio/stagger-container.tsx
  </files>
  <action>
Create `apps/web/components/portfolio/stagger-container.tsx`:

```typescript
'use client'

import { motion, useReducedMotion } from 'motion/react'
import type { ReactNode } from 'react'

const containerVariants = {
  hidden: {},
  visible: {
    transition: {
      staggerChildren: 0.15,
      delayChildren: 0.1,
    },
  },
}

const itemVariants = {
  hidden: { opacity: 0, y: 24 },
  visible: {
    opacity: 1,
    y: 0,
    transition: { duration: 0.5, ease: 'easeOut' },
  },
}

interface ContainerProps {
  children: ReactNode
  className?: string
}

export function StaggerContainer({ children, className }: ContainerProps) {
  const prefersReducedMotion = useReducedMotion()

  if (prefersReducedMotion) {
    return <div className={className}>{children}</div>
  }

  return (
    <motion.div
      className={className}
      variants={containerVariants}
      initial="hidden"
      whileInView="visible"
      viewport={{ once: true, amount: 0.1 }}
    >
      {children}
    </motion.div>
  )
}

export function StaggerItem({ children, className }: ContainerProps) {
  const prefersReducedMotion = useReducedMotion()

  if (prefersReducedMotion) {
    return <div className={className}>{children}</div>
  }

  return (
    <motion.div variants={itemVariants} className={className}>
      {children}
    </motion.div>
  )
}
```

Key points:
- `'use client'` is REQUIRED — both `useReducedMotion()` and motion variants run client-side only.
- Export BOTH `StaggerContainer` (parent) and `StaggerItem` (child wrapper) from the same file. Server Component pages import both and use `<StaggerItem>` wrapping each card — this avoids using `motion.div` directly in Server Components (which would cause a runtime error).
- `staggerChildren: 0.15` = 150ms between each card's start — visually obvious to human observer (satisfies SC2).
- `delayChildren: 0.1` = small initial delay so stagger starts after container enters view.
- When reduced motion is ON: both components render as plain `<div>` — zero animation, instant display.
- `viewport={{ amount: 0.1 }}` on container — triggers as soon as 10% of grid enters viewport; this ensures stagger is visible even when cards are near the top of scroll.
  </action>
  <verify>
Run `cd /home/doctor/fernandomillan && npx tsc --project apps/web/tsconfig.json --noEmit 2>&1 | grep "stagger" | head -10`

No TypeScript errors on stagger-container.tsx.
  </verify>
  <done>
`stagger-container.tsx` exists with `'use client'`, exports `StaggerContainer` and `StaggerItem`. Container uses `staggerChildren: 0.15`. Both components return plain divs when `useReducedMotion()` is true. TypeScript reports no errors.
  </done>
</task>

</tasks>

<verification>
After all three tasks:

1. Run full TypeScript check: `cd /home/doctor/fernandomillan && npx tsc --project apps/web/tsconfig.json --noEmit 2>&1 | head -30` — zero errors on new files.
2. Confirm files exist:
   - `apps/web/components/portfolio/motion-provider.tsx` — contains `MotionConfig reducedMotion="user"`
   - `apps/web/components/portfolio/animate-in.tsx` — contains `useReducedMotion` + `whileInView`
   - `apps/web/components/portfolio/stagger-container.tsx` — contains `staggerChildren: 0.15`
   - `apps/web/app/(portfolio)/layout.tsx` — contains `MotionProvider` wrapping `main`
3. Grep confirm imports are from `motion/react` NOT `framer-motion`:
   `grep -r "from 'framer-motion'" apps/web/components/portfolio/` — should return nothing.
</verification>

<success_criteria>
- Three new component files created and TypeScript-clean
- `layout.tsx` modified to include MotionProvider wrapping main content only
- All imports use `motion/react` (not `framer-motion`)
- `useReducedMotion()` early-returns plain elements in both AnimateIn and StaggerContainer/StaggerItem
- No new dependencies added (motion v12.34.2 already installed)
</success_criteria>

<output>
After completion, create `.planning/phases/24-scroll-animations-entrance/24-01-SUMMARY.md`
</output>
