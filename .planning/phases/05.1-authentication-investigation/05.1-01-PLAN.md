---
phase: 05.1-authentication-investigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/modules/events/events.gateway.ts
  - apps/api/src/modules/auth/auth.module.ts
  - apps/web/lib/auth.ts
  - apps/web/lib/websocket.ts
autonomous: true

must_haves:
  truths:
    - "Backend logs exact token value received from frontend during WebSocket connection"
    - "Backend logs JWT verification result (success/failure with reason)"
    - "Frontend logs accessToken before passing to WebSocket client"
    - "Developer can see complete authentication flow in console from token generation to verification"
    - "JWT algorithm configuration is explicit and matches between signing and verification"
  artifacts:
    - path: "apps/api/src/modules/events/events.gateway.ts"
      provides: "Comprehensive WebSocket handshake logging in handleConnection"
      min_lines: 100
    - path: "apps/api/src/modules/auth/auth.module.ts"
      provides: "Explicit verifyOptions with algorithms array"
      contains: "verifyOptions"
    - path: "apps/web/lib/auth.ts"
      provides: "JWT generation logging showing algorithm and payload"
      contains: "console.log"
    - path: "apps/web/lib/websocket.ts"
      provides: "Token logging before Socket.IO connection"
      contains: "console.log"
  key_links:
    - from: "apps/web/lib/auth.ts"
      to: "session.accessToken"
      via: "jwt.sign with HS256"
      pattern: "jwt\\.sign"
    - from: "apps/web/lib/websocket.ts"
      to: "socket.handshake.auth.token"
      via: "io(..., { auth: { token } })"
      pattern: "auth:\\s*\\{\\s*token"
    - from: "apps/api/src/modules/events/events.gateway.ts"
      to: "jwtService.verifyAsync"
      via: "token extraction from handshake.auth"
      pattern: "handshake\\.auth\\?\\.token"
---

<objective>
Add comprehensive debug logging throughout the WebSocket authentication flow to identify the exact cause of "Invalid token" disconnections.

Purpose: Determine whether the issue is token format mismatch (JWE vs JWS), algorithm mismatch (signing vs verification), token extraction failure, or configuration error. This diagnostic data will inform Phase 5.2 implementation.

Output: Console logs showing complete token lifecycle from generation (NextAuth) → transmission (Socket.IO client) → reception (Socket.IO server) → verification (JwtService), plus explicit JWT algorithm configuration.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05.1-authentication-investigation/05.1-RESEARCH.md

# Current implementation files
@apps/web/lib/auth.ts
@apps/web/lib/websocket.ts
@apps/api/src/modules/events/events.gateway.ts
@apps/api/src/modules/auth/auth.module.ts
@apps/api/src/common/guards/ws-auth.guard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add comprehensive WebSocket backend logging and explicit JWT algorithm config</name>
  <files>
    apps/api/src/modules/events/events.gateway.ts
    apps/api/src/modules/auth/auth.module.ts
  </files>
  <action>
Update EventsGateway.handleConnection to add detailed debug logging:

1. Log the complete handshake object structure:
   - `socket.handshake.auth` (should contain token)
   - `socket.handshake.headers.authorization` (fallback)
   - `socket.handshake.query` (for completeness)

2. Before verification, log token details:
   - Token presence (boolean)
   - Token type (typeof)
   - Token length
   - First 20 chars of token (for identification without exposing full secret)

3. Attempt to decode token WITHOUT verification to inspect structure:
   - Use `jwt.decode(token, { complete: true })` from jsonwebtoken
   - Log decoded header (especially `alg` field)
   - Log decoded payload (user info)
   - Handle decode errors gracefully

4. Log verification attempt and result:
   - "Attempting to verify token with algorithm: HS256"
   - On success: log payload.sub, payload.email, payload.role
   - On failure: log full error message and error.name

Update AuthModule JwtModule configuration to add explicit verifyOptions:

```typescript
JwtModule.registerAsync({
  inject: [ConfigService],
  useFactory: (configService: ConfigService) => ({
    secret: configService.get<string>('JWT_SECRET'),
    signOptions: {
      expiresIn: configService.get<string>('JWT_EXPIRES_IN') || '15m',
      algorithm: 'HS256', // Explicit algorithm
    },
    verifyOptions: {
      algorithms: ['HS256'], // CRITICAL: Must match signOptions
    },
  }),
}),
```

This ensures NestJS JwtService.verifyAsync uses the correct algorithm, preventing algorithm confusion attacks and mismatches.
  </action>
  <verify>
1. Start backend: `npm run dev --workspace=api`
2. Check logs show "JWT configured with algorithm: HS256" or similar startup message
3. Attempt WebSocket connection from frontend
4. Verify backend console shows:
   - Handshake object logged
   - Token structure logged
   - Decoded token header/payload logged
   - Verification attempt logged with result
  </verify>
  <done>
Backend logs show complete WebSocket authentication flow with token structure, decode result, and verification outcome. JwtModule has explicit verifyOptions with algorithms array.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add frontend JWT generation and WebSocket connection logging</name>
  <files>
    apps/web/lib/auth.ts
    apps/web/lib/websocket.ts
  </files>
  <action>
Update auth.ts session callback (around line 190-201) to log JWT generation:

Before calling `jwt.sign`, add:
```typescript
console.log('[NextAuth Session] Generating accessToken for user:', {
  userId: user.id,
  email: user.email,
  role: user.role,
  jwtSecretPresent: !!jwtSecret,
  jwtSecretLength: jwtSecret?.length,
});
```

After calling `jwt.sign`, add:
```typescript
console.log('[NextAuth Session] Generated accessToken:', {
  tokenLength: accessToken.length,
  tokenPreview: accessToken.substring(0, 20) + '...',
  decodedHeader: jwt.decode(accessToken, { complete: true })?.header,
  expiresIn: '15m',
});
```

Update websocket.ts getSocket function to log before connection:

Before `socket = io(...)` line, add:
```typescript
console.log('[WebSocket Client] Initializing connection:', {
  url: process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001',
  tokenLength: token.length,
  tokenPreview: token.substring(0, 20) + '...',
  authObject: { token: '[REDACTED]' },
});
```

After connection, enhance existing event listeners:
```typescript
socket.on('connect', () => {
  console.log('[WebSocket Client] Connected successfully', {
    socketId: socket.id,
    connected: socket.connected,
  });
});

socket.on('connect_error', (err) => {
  console.error('[WebSocket Client] Connection error:', {
    message: err.message,
    description: err.message,
    stack: err.stack,
  });
});
```

This creates a complete audit trail from token generation through connection attempt.
  </action>
  <verify>
1. Login to dashboard as demo1@teamflow.dev
2. Check browser console for "[NextAuth Session] Generating accessToken" logs
3. Verify token generation shows algorithm HS256 in decoded header
4. Check for "[WebSocket Client] Initializing connection" logs
5. Verify token length matches between session callback and WebSocket client
6. Check connection result logs (success or error with details)
  </verify>
  <done>
Browser console shows complete token lifecycle: generation in NextAuth session callback → passing to WebSocket client → connection attempt with detailed error messages if failure occurs. Token preview in both logs confirms same token is being used.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test and document authentication flow</name>
  <files>
    .planning/phases/05.1-authentication-investigation/05.1-FINDINGS.md
  </files>
  <action>
1. Start backend: `npm run dev --workspace=api`
2. Start frontend: `npm run dev --workspace=web`
3. Navigate to http://localhost:3000/login
4. Login as demo1@teamflow.dev / Password123
5. Navigate to any team/project page to trigger WebSocket connection
6. Collect all logs from both backend and frontend consoles

Create FINDINGS.md documenting:

**Token Generation (Frontend)**
- JWT algorithm used (from decoded header)
- Token length
- Payload structure (sub, email, role, exp)
- Secret configuration (present/absent, length)

**Token Transmission**
- How token is passed (auth object vs headers)
- Token value matches generation (compare previews)

**Token Reception (Backend)**
- What backend receives in handshake.auth.token
- Decoded token structure on backend
- Algorithm in token header

**Verification Result**
- Success or failure
- If failure: exact error message
- If failure: error type (JsonWebTokenError, TokenExpiredError, etc.)

**Configuration Analysis**
- Frontend signing algorithm: HS256 (confirmed)
- Backend verification algorithm: HS256 (confirmed via verifyOptions)
- JWT_SECRET match (cannot confirm directly, but infer from verification)

**Root Cause Hypothesis**
Based on logs, identify one of:
1. Algorithm mismatch (header shows different alg than HS256)
2. Token not reaching backend (handshake.auth.token is undefined)
3. Secret mismatch (verification fails with "invalid signature")
4. Token format issue (not standard JWT structure)
5. Timing issue (token expired between generation and verification)
6. Guard vs Middleware issue (connection succeeds but Guard rejects later)

Include exact log excerpts supporting the hypothesis.
  </action>
  <verify>
1. Read .planning/phases/05.1-authentication-investigation/05.1-FINDINGS.md
2. Verify it contains all required sections
3. Verify it includes actual log excerpts (not generic descriptions)
4. Verify it states a clear root cause hypothesis with supporting evidence
  </verify>
  <done>
FINDINGS.md exists with complete authentication flow documentation, actual log excerpts from testing, and clear hypothesis about root cause of WebSocket authentication failure. Developer knows exactly what is happening at each step of token lifecycle.
  </done>
</task>

</tasks>

<verification>
1. Backend logs show complete handshake object, token structure, decoded header/payload
2. Frontend logs show token generation with algorithm and payload
3. Frontend logs show token being passed to WebSocket client
4. FINDINGS.md documents complete authentication flow with actual log excerpts
5. Root cause hypothesis is stated based on diagnostic evidence
6. JwtModule has explicit verifyOptions: { algorithms: ['HS256'] }
</verification>

<success_criteria>
- Developer can trace a single token from generation (NextAuth) through transmission (Socket.IO client) to reception and verification (Socket.IO server)
- Token structure is visible at each stage (algorithm, payload, length)
- Verification failure cause is documented with supporting log evidence
- Next phase (5.2) has clear implementation target based on findings
- All logging is in place for ongoing debugging during fix implementation
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-authentication-investigation/05.1-01-SUMMARY.md` following the summary template.
</output>
