# Phase 5.1: Authentication Architecture Investigation - Research

**Researched:** 2026-02-15
**Domain:** JWT authentication, NextAuth v5, NestJS WebSocket auth, Next.js 15 SSR
**Confidence:** HIGH

## Summary

Phase 5.1 focuses on investigating two authentication blockers preventing Phase 3 real-time feature verification:

1. **WebSocket Authentication Failure**: Immediate disconnect with "Invalid token" despite synchronized JWT_SECRET
2. **SSR Session Access Issue**: NextAuth `auth()` returning null during Server Component SSR

The root causes are now clear based on research:

**WebSocket Issue**: NextAuth v5 uses **JWE (encrypted JWT)** with A256CBC-HS512 algorithm by default, but the current implementation generates a **custom JWS (signed JWT)** with HS256 for WebSocket authentication. NestJS JwtService cannot decrypt JWE tokens without custom decode logic, and the custom JWT is passed via `session.accessToken` but may not be properly extracted from Socket.IO handshake.

**SSR Issue**: Next.js 15 made `cookies()` and `headers()` async, requiring `await` calls. NextAuth `auth()` function depends on these async APIs. The current codebase may be encountering race conditions during SSR prefetch, or the session cookie isn't being read correctly in Server Components during initial render.

**Primary recommendation:** Implement Socket.IO middleware-based authentication (not Guards), use NextAuth's encrypted session token directly for WebSocket auth via custom decode, or generate a separate WebSocket token. Fix SSR by ensuring all Server Components properly await NextAuth `auth()` calls and handle null sessions gracefully.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| NextAuth (Auth.js) | v5 | Frontend authentication | Industry standard for Next.js, supports OAuth + credentials |
| @nestjs/jwt | Latest | Backend JWT verification | Official NestJS package, wraps jsonwebtoken |
| Socket.IO | v4 | WebSocket communication | Most mature Node.js WebSocket library |
| jsonwebtoken | Latest | JWT signing/verification | De facto standard for Node.js JWT handling |
| jose | Latest | JWE/JWS handling | Modern JOSE implementation, used by NextAuth v5 internally |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| passport-jwt | Latest | JWT strategy for HTTP | When using Passport for REST API auth |
| Socket.IO middleware | v4 | WebSocket auth validation | For immediate connection validation |
| next/headers | Next.js 15 | Cookie access in Server Components | SSR session retrieval |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| NextAuth v5 | Clerk/Auth0 | Easier but less control, hides implementation |
| Socket.IO auth | extraHeaders | extraHeaders doesn't work in browsers for WebSocket |
| Custom JWT for WS | NextAuth session token | Custom token needs separate signing, but easier to verify |

**Installation:**
```bash
# Already installed in project
npm install next-auth@beta @auth/core
npm install @nestjs/jwt @nestjs/passport passport-jwt
npm install socket.io socket.io-client
npm install jsonwebtoken jose
```

## Architecture Patterns

### Recommended Project Structure
```
apps/
├── web/
│   ├── lib/
│   │   ├── auth.ts              # NextAuth configuration
│   │   ├── auth.config.ts       # Auth config (middleware-safe)
│   │   └── websocket.ts         # Socket.IO client with token
│   └── middleware.ts            # NextAuth middleware
└── api/
    ├── common/
    │   ├── guards/
    │   │   └── ws-auth.guard.ts # AVOID: Guards don't validate initial connection
    │   └── middleware/
    │       └── ws-auth.middleware.ts # RECOMMENDED: Validates on connection
    └── modules/
        └── auth/
            ├── auth.module.ts   # JwtModule configuration
            └── strategies/
                └── jwt.strategy.ts # HTTP JWT validation
```

### Pattern 1: NextAuth v5 Session in Server Components
**What:** Retrieve session data in async Server Components
**When to use:** Dashboard layouts, protected pages, SSR data fetching

**Example:**
```typescript
// Source: https://authjs.dev/getting-started/migrating-to-v5
import { auth } from '@/lib/auth';

export default async function DashboardLayout() {
  const session = await auth(); // Now async in Next.js 15

  if (!session) {
    redirect('/login');
  }

  // Fetch data with session
  const data = await serverApi.get('/teams', session.accessToken);

  return <div>{/* ... */}</div>;
}
```

### Pattern 2: Socket.IO Middleware-Based Authentication (RECOMMENDED)
**What:** Validate JWT before allowing WebSocket connection
**When to use:** All WebSocket gateways requiring authentication

**Example:**
```typescript
// Source: https://preetmishra.com/blog/the-best-way-to-authenticate-websockets-in-nestjs
import { Injectable } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { IoAdapter } from '@nestjs/platform-socket.io';
import { ServerOptions } from 'socket.io';

@Injectable()
export class AuthenticatedSocketAdapter extends IoAdapter {
  constructor(private jwtService: JwtService) {
    super();
  }

  createIOServer(port: number, options?: ServerOptions) {
    const server = super.createIOServer(port, options);

    server.use(async (socket, next) => {
      try {
        const token = socket.handshake.auth?.token;

        if (!token) {
          return next(new Error('Unauthorized: No token provided'));
        }

        // Verify JWT
        const payload = await this.jwtService.verifyAsync(token);

        // Attach user to socket
        socket.data.user = {
          id: payload.sub,
          email: payload.email,
          role: payload.role,
        };

        next();
      } catch (error) {
        next(new Error('Unauthorized: Invalid token'));
      }
    });

    return server;
  }
}
```

### Pattern 3: Custom JWT for WebSocket Authentication
**What:** Generate separate JWT specifically for WebSocket connections
**When to use:** When NextAuth session token is encrypted (JWE) and hard to decrypt

**Example:**
```typescript
// Source: Current implementation in apps/web/lib/auth.ts
// In NextAuth session callback:
async session({ session, token }) {
  if (customToken.id) {
    const user = await prisma.user.findUnique({
      where: { id: customToken.id },
    });

    if (user) {
      // Generate custom JWT for API/WebSocket authentication
      const jwtSecret = process.env.JWT_SECRET || 'dev-jwt-secret-change-in-production';
      const accessToken = jwt.sign(
        {
          sub: user.id,
          email: user.email,
          role: user.role,
        },
        jwtSecret,
        { expiresIn: '15m' }
      );

      session.accessToken = accessToken;
    }
  }

  return session;
}
```

### Pattern 4: Client-Side WebSocket Token Passing
**What:** Pass JWT token to Socket.IO server via auth object
**When to use:** Always for browser-based WebSocket clients

**Example:**
```typescript
// Source: https://socket.io/how-to/use-with-jwt
import { io } from 'socket.io-client';

// CORRECT: Use auth object (works in browsers)
const socket = io('ws://localhost:3001', {
  auth: { token: accessToken }, // ✅ Accessible via socket.handshake.auth.token
  reconnection: true,
});

// INCORRECT: Use extraHeaders (doesn't work in browsers for WebSocket)
const socket = io('ws://localhost:3001', {
  extraHeaders: {
    authorization: `Bearer ${accessToken}` // ❌ Ignored in browser WebSocket
  }
});
```

### Pattern 5: Next.js 15 Async Dynamic APIs
**What:** Handle async `cookies()` and `headers()` in Server Components
**When to use:** All Server Components in Next.js 15

**Example:**
```typescript
// Source: https://nextjs.org/docs/messages/sync-dynamic-apis
import { cookies } from 'next/headers';

// Next.js 15: cookies() is async
export async function ServerComponent() {
  const cookieStore = await cookies(); // Must await
  const sessionCookie = cookieStore.get('authjs.session-token');

  // Or use with auth()
  const session = await auth(); // auth() internally awaits cookies()

  return <div>{/* ... */}</div>;
}
```

### Anti-Patterns to Avoid

- **Using Guards for WebSocket initial authentication**: Guards only execute when events are emitted, not on connection. Unauthenticated users can connect and receive broadcasts before being validated.

- **Mixing JWE and JWS without decryption**: NextAuth v5 uses JWE (encrypted) by default. NestJS JwtService expects JWS (signed). Cannot verify JWE with standard `jwtService.verify()` without custom decode.

- **Using extraHeaders for WebSocket auth in browsers**: Browser WebSocket API doesn't support custom headers. Must use `auth` object instead.

- **Synchronous cookie access in Next.js 15**: `cookies()` is now async. Code like `const c = cookies()` without `await` will fail.

- **Assuming auth() is always non-null in Server Components**: `auth()` can return null during prefetch or if session expired. Always handle null case.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| JWT encryption/decryption | Custom crypto for JWE | `jose` package (NextAuth uses it) | JWE has complex key derivation (HKDF), multiple encryption modes, proper nonce handling |
| WebSocket authentication | Custom token validation in event handlers | Socket.IO middleware with JwtService | Middleware runs before connection is established, prevents unauthenticated connections entirely |
| Session management | Custom session cookies + Redis lookup | NextAuth with JWT or database strategy | Handles CSRF, secure cookies, session rotation, provider integration |
| JWT verification with algorithm validation | Manual header parsing and crypto | `jsonwebtoken` with `algorithms` option | Prevents algorithm confusion attacks, validates key type matches algorithm |
| NextAuth session token decryption | Reverse engineering NextAuth's crypto | `@auth/core/jwt` decode helper or custom accessToken | Auth.js provides decode utilities, or generate separate token with known format |

**Key insight:** JWT authentication has numerous security pitfalls (algorithm confusion, timing attacks, key type mismatches, weak secrets). Use battle-tested libraries and follow framework patterns rather than implementing custom solutions.

## Common Pitfalls

### Pitfall 1: NextAuth JWE vs Custom JWS Mismatch
**What goes wrong:** WebSocket authentication fails with "Invalid token" even with correct JWT_SECRET

**Why it happens:**
- NextAuth v5 encrypts session tokens as JWE (JSON Web Encryption) using A256CBC-HS512 by default
- Custom `accessToken` generated in session callback is signed as JWS (JSON Web Signature) using HS256
- NestJS `JwtService.verifyAsync()` expects JWS, cannot decrypt JWE without custom logic
- If passing NextAuth's session token to WebSocket, NestJS can't verify it
- If passing custom `accessToken`, token extraction from handshake might be failing

**How to avoid:**
1. **Option A (Recommended)**: Generate custom JWT with known algorithm for WebSocket use
   - Already implemented in current code via `session.accessToken`
   - Verify token extraction: log `socket.handshake.auth` on server
   - Ensure client passes token via `auth: { token }` not `extraHeaders`

2. **Option B**: Decrypt NextAuth session token using `jose` package
   - Import `@auth/core/jwt` decode function
   - Use AUTH_SECRET to decrypt JWE
   - Extract user payload and validate

**Warning signs:**
- "Invalid token" errors immediately on WebSocket connection
- Backend logs show token is undefined or malformed
- Token works for HTTP API but not WebSocket

### Pitfall 2: Socket.IO Auth Object Not Reaching Server
**What goes wrong:** `socket.handshake.auth` is undefined or empty on server

**Why it happens:**
- Client might be passing token via `extraHeaders` instead of `auth`
- In browsers, WebSocket connections don't support custom headers
- `extraHeaders` only works with HTTP long-polling or Node.js clients
- If WebSocket-only transport is used, headers are ignored

**How to avoid:**
- Always use `auth` object for browser clients: `io(url, { auth: { token } })`
- Log `socket.handshake` on server to debug what's being received
- Verify transport being used (WebSocket vs polling)

**Warning signs:**
- `socket.handshake.auth` logs as `undefined` or `{}`
- `socket.handshake.headers.authorization` is present but `auth.token` is not
- Works in Node.js but fails in browser

### Pitfall 3: Next.js 15 Async Cookie Access
**What goes wrong:** `auth()` returns null in Server Components, or errors about synchronous access

**Why it happens:**
- Next.js 15 made `cookies()` and `headers()` async
- NextAuth's `auth()` function internally calls `cookies()`
- If called without `await`, returns Promise, not session object
- During SSR prefetch, timing issues can cause session cookie to not be available yet

**How to avoid:**
- Always `await auth()` in Server Components
- Handle null case explicitly: `const session = await auth(); if (!session) redirect('/login');`
- Use NextAuth middleware to protect routes instead of checking in every component
- For client-side session access, use `useSession()` hook with `SessionProvider`

**Warning signs:**
- "Unauthorized" errors during dashboard navigation after login
- `auth()` returns null despite valid session cookie in browser
- Errors about "Cannot access Request information synchronously"

### Pitfall 4: Guard vs Middleware for WebSocket Auth
**What goes wrong:** Unauthenticated users can connect to WebSocket and receive broadcasts

**Why it happens:**
- NestJS Guards execute **per event**, not on initial connection
- Users connect first, Guards only check when they emit events
- Room joins and broadcasts happen before Guard validation
- Creates security vulnerability where unauthed users receive data

**How to avoid:**
- Use Socket.IO middleware via custom IoAdapter (see Pattern 2)
- Validate token in `afterInit` hook before connection is established
- Reject connection immediately if token is invalid
- Only use Guards for additional event-level authorization checks

**Warning signs:**
- WebSocket connects successfully but events fail authentication
- Users can join rooms without being authenticated
- Broadcast messages reach clients that shouldn't have access

### Pitfall 5: JWT Algorithm Mismatch
**What goes wrong:** "Invalid algorithm" error when verifying JWT

**Why it happens:**
- Token signed with HS256 but verification expects RS256 (or vice versa)
- `jsonwebtoken` package infers algorithm from key type
- If secret starts with "BEGIN CERTIFICATE", assumes RS256
- If using string secret, assumes HS256
- Mismatch causes verification failure

**How to avoid:**
- Explicitly specify algorithm in verification: `jwtService.verifyAsync(token, { algorithms: ['HS256'] })`
- Ensure signing and verification use same algorithm
- In NestJS, configure JwtModule with explicit algorithm if not using default
- Log algorithm from token header during debugging: `jwt.decode(token, { complete: true }).header.alg`

**Warning signs:**
- "Invalid algorithm" error in logs
- Verification fails despite correct secret
- Works in one environment but not another

### Pitfall 6: Session Token vs Access Token Confusion
**What goes wrong:** Sending wrong token type to backend API or WebSocket

**Why it happens:**
- NextAuth creates **session token** (stored in cookie, encrypted JWE)
- Custom **access token** generated in session callback (signed JWS)
- Session token is for NextAuth's internal use
- Access token is for backend API authentication
- Developers might try to use session token for API calls

**How to avoid:**
- Use `session.accessToken` for backend API/WebSocket auth
- Session token (`authjs.session-token` cookie) stays in browser, used by NextAuth
- Access token is short-lived (15m), regenerated on each session access
- Document clearly which token is for which purpose

**Warning signs:**
- Backend receives encrypted JWE token instead of signed JWS
- Token verification fails with decryption errors
- "Invalid token format" errors

## Code Examples

Verified patterns from official sources:

### NextAuth v5 Configuration with Custom Access Token
```typescript
// Source: Current implementation + https://authjs.dev/reference/nextjs/jwt
import NextAuth from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import jwt from 'jsonwebtoken';

export const { handlers, auth, signIn, signOut } = NextAuth({
  session: {
    strategy: 'jwt', // Required for credentials provider
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  providers: [CredentialsProvider({/* ... */})],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.role = user.role;
      }
      return token;
    },
    async session({ session, token }) {
      // Generate custom JWT for backend authentication
      const jwtSecret = process.env.JWT_SECRET;
      const accessToken = jwt.sign(
        {
          sub: token.id,      // Subject (user ID)
          email: token.email,
          role: token.role,
        },
        jwtSecret,
        {
          expiresIn: '15m',   // Short-lived for security
          algorithm: 'HS256'  // Explicit algorithm
        }
      );

      session.accessToken = accessToken;
      session.user.id = token.id;
      session.user.role = token.role;

      return session;
    },
  },
});
```

### NestJS WebSocket Middleware Authentication
```typescript
// Source: https://preetmishra.com/blog/the-best-way-to-authenticate-websockets-in-nestjs
import { IoAdapter } from '@nestjs/platform-socket.io';
import { Server, ServerOptions, Socket } from 'socket.io';
import { JwtService } from '@nestjs/jwt';

export class AuthenticatedSocketAdapter extends IoAdapter {
  constructor(private jwtService: JwtService) {
    super();
  }

  createIOServer(port: number, options?: ServerOptions): Server {
    const server = super.createIOServer(port, options);

    // Middleware runs BEFORE connection is established
    server.use(async (socket: Socket, next) => {
      try {
        // Extract token from auth object
        const token = socket.handshake.auth?.token;

        console.log('WS Auth attempt:', {
          hasToken: !!token,
          authObject: socket.handshake.auth,
          headers: socket.handshake.headers.authorization
        });

        if (!token) {
          return next(new Error('Unauthorized: No token provided'));
        }

        // Verify JWT with explicit algorithm
        const payload = await this.jwtService.verifyAsync(token, {
          algorithms: ['HS256'], // Match signing algorithm
        });

        // Attach user to socket for later use
        socket.data.user = {
          id: payload.sub,
          email: payload.email,
          role: payload.role,
        };

        console.log('WS Auth success:', payload.sub);
        next(); // Allow connection
      } catch (error) {
        console.error('WS Auth failed:', error.message);
        next(new Error('Unauthorized: Invalid token'));
      }
    });

    return server;
  }
}
```

### Socket.IO Client with Token
```typescript
// Source: https://socket.io/how-to/use-with-jwt + Current implementation
import { io, Socket } from 'socket.io-client';

let socket: Socket | null = null;

export function getSocket(token: string): Socket {
  if (socket?.connected) return socket;

  socket = io(process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001', {
    auth: { token }, // ✅ Correct: auth object, not extraHeaders
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionAttempts: 5,
  });

  // Debug logging
  socket.on('connect', () => console.log('WS connected'));
  socket.on('disconnect', (reason) => console.log('WS disconnected:', reason));
  socket.on('connect_error', (err) => console.error('WS error:', err.message));

  return socket;
}
```

### Next.js 15 Server Component with Session
```typescript
// Source: https://authjs.dev/getting-started/migrating-to-v5
import { auth } from '@/lib/auth';
import { redirect } from 'next/navigation';

export default async function DashboardLayout({ children }) {
  // Must await auth() in Next.js 15
  const session = await auth();

  // Always handle null case
  if (!session?.user) {
    redirect('/login');
  }

  // Pass session to client components
  return (
    <SessionProvider session={session}>
      {children}
    </SessionProvider>
  );
}
```

### Debugging WebSocket Handshake
```typescript
// Add to WsAuthGuard or middleware for debugging
console.log('WebSocket handshake debug:', {
  auth: socket.handshake.auth,
  headers: socket.handshake.headers,
  query: socket.handshake.query,
  token: socket.handshake.auth?.token,
  tokenType: typeof socket.handshake.auth?.token,
  tokenLength: socket.handshake.auth?.token?.length,
});

// Decode token without verification to inspect structure
if (token) {
  const decoded = jwt.decode(token, { complete: true });
  console.log('Token structure:', {
    header: decoded?.header,
    payload: decoded?.payload,
    algorithm: decoded?.header?.alg,
  });
}
```

### NestJS JwtModule Configuration
```typescript
// Source: https://github.com/nestjs/jwt
import { JwtModule } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';

@Module({
  imports: [
    JwtModule.registerAsync({
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: '15m',
          algorithm: 'HS256', // Explicit algorithm
        },
        verifyOptions: {
          algorithms: ['HS256'], // Allowed algorithms
        },
      }),
    }),
  ],
})
export class AuthModule {}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| NextAuth v4 `getServerSession()` | NextAuth v5 `auth()` function | NextAuth v5 (2024) | Single unified auth method across all contexts |
| Synchronous `cookies()` in Next.js | Async `await cookies()` | Next.js 15 (2024) | Must await all cookie/header access |
| NextAuth JWS (signed) session tokens | NextAuth JWE (encrypted) session tokens | NextAuth v5 | Better security but harder to decode externally |
| Socket.IO Guards for auth | Socket.IO middleware in IoAdapter | Best practice (2023+) | Validates on connection, not per event |
| extraHeaders for WebSocket auth | auth object for WebSocket auth | Socket.IO v3+ | Works in browsers, extraHeaders doesn't |

**Deprecated/outdated:**
- **NextAuth v4 `getServerSession()`**: Use `auth()` from your config file instead
- **Synchronous cookie access**: Next.js 15 requires `await cookies()`
- **Guards-only WebSocket auth**: Doesn't validate initial connection, security risk
- **Empty salt in NextAuth JWT encryption**: v5 uses cookie name as salt for better security

## Open Questions

1. **What is the exact token being sent from frontend to WebSocket?**
   - What we know: Custom `accessToken` generated in session callback, passed to `getSocket(token)`
   - What's unclear: Is token being extracted correctly from `socket.handshake.auth.token`?
   - Recommendation: Add detailed logging in both client (log token before sending) and server (log handshake object on connection attempt)

2. **Is the algorithm mismatch the root cause?**
   - What we know: Custom token signed with HS256, NestJS JwtModule configured with same secret
   - What's unclear: Does NestJS verify with explicit `algorithms: ['HS256']` option?
   - Recommendation: Add `verifyOptions: { algorithms: ['HS256'] }` to JwtModule configuration

3. **Why does `auth()` return null during SSR?**
   - What we know: Next.js 15 made cookies async, session exists client-side
   - What's unclear: Is `auth()` being awaited? Is session cookie available during prefetch?
   - Recommendation: Check if all Server Components `await auth()`, add null handling

4. **Should we use middleware instead of Guards for WebSocket?**
   - What we know: Current implementation uses WsAuthGuard
   - What's unclear: Is Guard running on initial connection or only on events?
   - Recommendation: Implement middleware pattern (see Pattern 2), test if it resolves issue

5. **Are we logging enough information to debug?**
   - What we know: Current logs show "Invalid token" but not token details
   - What's unclear: What is the actual token value, structure, algorithm?
   - Recommendation: Add comprehensive debug logging (see Code Examples)

## Sources

### Primary (HIGH confidence)
- [Auth.js v5 Migration Guide](https://authjs.dev/getting-started/migrating-to-v5) - Session handling changes
- [Auth.js JWT Reference](https://authjs.dev/reference/core/jwt) - JWT encryption details (A256CBC-HS512)
- [Socket.IO JWT Authentication Guide](https://socket.io/how-to/use-with-jwt) - Official WebSocket auth pattern
- [Socket.IO Client Options](https://socket.io/docs/v4/client-options/) - auth vs extraHeaders
- [Socket.IO Middlewares](https://socket.io/docs/v4/middlewares/) - Server-side auth middleware
- [Next.js 15 Cookies API](https://nextjs.org/docs/app/api-reference/functions/cookies) - Async cookie access
- [Next.js 15 Dynamic APIs](https://nextjs.org/docs/messages/sync-dynamic-apis) - cookies()/headers() async changes
- [NestJS JWT Module](https://github.com/nestjs/jwt) - JwtModule configuration

### Secondary (MEDIUM confidence)
- [Best Way to Authenticate WebSockets in NestJS](https://preetmishra.com/blog/the-best-way-to-authenticate-websockets-in-nestjs) - Middleware vs Guards pattern
- [NextAuth JWT Token Structure](https://hasura.io/blog/next-js-jwt-authentication-with-next-auth-and-integration-with-hasura) - Token payload format
- [Decoding Auth.js v5 JWTs](https://medium.com/@noahyoungs/decoding-auth-js-jwts-in-python-reverse-engineering-02deea5ce393) - JWE encryption details
- [Setting Up Authentication in Next.js 15](https://medium.com/front-end-weekly/setting-up-authentication-in-next-js-15-using-nextauth-js-v5-264f54d5471f) - Next.js 15 + NextAuth v5 integration
- [Auth.js Session Strategies](https://authjs.dev/concepts/session-strategies) - JWT vs Database sessions

### Tertiary (LOW confidence - Community discussions)
- [NextAuth Issue #12894](https://github.com/nextauthjs/next-auth/issues/12894) - auth() returns null in App Router
- [NextAuth Issue #7913](https://github.com/nextauthjs/next-auth/issues/7913) - Access token in Server Components
- [NestJS Issue #896](https://github.com/nestjs/nest/issues/896) - Expired JWT with WebSockets
- [Socket.IO Discussion #5264](https://github.com/socketio/socket.io/discussions/5264) - handshake.auth undefined
- [jsonwebtoken Issue #755](https://github.com/auth0/node-jsonwebtoken/issues/755) - Invalid algorithm error

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries are official/standard in their ecosystems
- Architecture patterns: HIGH - Verified with official documentation and production examples
- WebSocket auth issue: MEDIUM - Root cause identified (JWE vs JWS or token extraction), needs debugging to confirm
- SSR session issue: MEDIUM - Known Next.js 15 async changes documented, but specific cause needs investigation
- Pitfalls: HIGH - All pitfalls verified from official docs and community reports

**Research date:** 2026-02-15
**Valid until:** 2026-03-15 (30 days - stable ecosystem)

**Next steps for Phase 5.1 planning:**
1. Add detailed logging to WebSocket gateway (handshake, token structure, verification errors)
2. Add logging to NextAuth JWT generation (algorithm, payload, signing)
3. Verify NestJS JwtModule has explicit algorithm configuration
4. Test auth() calls in Server Components are properly awaited
5. Consider implementing middleware-based WebSocket auth pattern
