---
phase: 05.1-authentication-investigation
plan: 01
type: findings
date: 2026-02-15
investigator: Claude Sonnet 4.5
---

# WebSocket Authentication Investigation Findings

## Executive Summary

**Root Cause:** JWT_SECRET configuration mismatch between frontend (NextAuth) and backend (NestJS JwtService).

**Evidence:** Comprehensive logging added to the authentication flow revealed that tokens signed with the correct JWT_SECRET verify successfully, while tokens signed with a different secret fail with "invalid signature" error.

**Impact:** All WebSocket connections fail immediately after handshake due to token verification failure in `EventsGateway.handleConnection`.

## Test Results

### Test Environment
- Backend API: http://localhost:3001 (NestJS)
- Frontend Web: http://localhost:3000 (Next.js 15)
- PostgreSQL: localhost:5434 (Docker container)
- Redis: localhost:6380 (Docker container)
- Test date: 2026-02-15 16:54 UTC

### Test 1: Token with Default Secret (Failed)

**Token Generation:**
```javascript
JWT_SECRET = 'dev-jwt-secret-change-in-production'
const token = jwt.sign({ sub, email, role }, jwtSecret, { expiresIn: '15m' })
```

**Token Details:**
- Length: 212 characters
- Algorithm: HS256 (confirmed in decoded header)
- Preview: `eyJhbGciOiJIUzI1NiIs...`
- Payload: `{ sub: 'test-user-id', email: 'test@example.com', role: 'ADMIN' }`

**Backend Reception:**
```
[WS Handshake] Auth object: { hasAuth: true, authKeys: [ 'token' ], hasToken: true }
[WS Auth] Token received: { present: true, type: 'string', length: 212 }
[WS Auth] Decoded token (unverified): {
  header: { alg: 'HS256', typ: 'JWT' },
  payload: { sub: 'test-user-id', email: 'test@example.com', role: 'ADMIN' },
  hasSignature: true
}
```

**Verification Result:**
```
[WS Auth] Attempting verification with algorithm: HS256
[WS Auth] Verification FAILED: {
  message: 'invalid signature',
  name: 'JsonWebTokenError'
}
[WS Auth] REJECTED: Invalid token
```

### Test 2: Token with Correct .env Secret (Success)

**Token Generation:**
```javascript
JWT_SECRET = 'dev-secret-change-in-production-min-32-chars-required-for-jwt'
const token = jwt.sign({ sub, email, role }, jwtSecret, { expiresIn: '15m' })
```

**Token Details:**
- Length: 212 characters
- Algorithm: HS256 (confirmed in decoded header)
- Preview: `eyJhbGciOiJIUzI1NiIs...`
- Payload: `{ sub: 'test-user-id', email: 'test@example.com', role: 'ADMIN' }`

**Backend Reception:**
```
[WS Handshake] Auth object: { hasAuth: true, authKeys: [ 'token' ], hasToken: true }
[WS Auth] Token received: { present: true, type: 'string', length: 212 }
[WS Auth] Decoded token (unverified): {
  header: { alg: 'HS256', typ: 'JWT' },
  payload: { sub: 'test-user-id', email: 'test@example.com', role: 'ADMIN' },
  hasSignature: true
}
```

**Verification Result:**
```
[WS Auth] Attempting verification with algorithm: HS256
[WS Auth] Verification SUCCESS: {
  sub: 'test-user-id',
  email: 'test@example.com',
  role: 'ADMIN',
  exp: 1771197074
}
[WS Auth] CONNECTED: user test-user-id
```

## Authentication Flow Analysis

### Token Generation (Frontend - NextAuth)

**Location:** `apps/web/lib/auth.ts` line 191-201

**Process:**
1. NextAuth session callback is triggered on login
2. JWT secret loaded from `process.env.JWT_SECRET` with fallback
3. Token signed using `jsonwebtoken` library with HS256 algorithm
4. Token attached to `session.accessToken`

**Logging Added:**
```javascript
console.log('[NextAuth Session] Generating accessToken for user:', {
  userId, email, role, jwtSecretPresent, jwtSecretLength
});
console.log('[NextAuth Session] Generated accessToken:', {
  tokenLength, tokenPreview, decodedHeader, expiresIn
});
```

**Key Configuration:**
```javascript
jwt.sign({ sub, email, role }, jwtSecret, { expiresIn: '15m' })
// Algorithm: HS256 (default for jwt.sign with HMAC secret)
```

### Token Transmission

**Location:** `apps/web/lib/websocket.ts` line 8-13

**Process:**
1. `getSocket(token)` called with `session.accessToken`
2. Socket.IO client initialized with token in auth object
3. Token transmitted via `socket.handshake.auth.token`

**Logging Added:**
```javascript
console.log('[WebSocket Client] Initializing connection:', {
  url, tokenLength, tokenPreview, authObject: { token: '[REDACTED]' }
});
```

**Key Configuration:**
```javascript
io(url, {
  auth: { token }, // Token passed in auth object, not headers
  reconnection: true
});
```

### Token Reception (Backend - Socket.IO Server)

**Location:** `apps/api/src/modules/events/events.gateway.ts` line 44-101

**Process:**
1. `handleConnection(client)` triggered on new WebSocket connection
2. Token extracted from `client.handshake.auth.token` (primary) or `headers.authorization` (fallback)
3. Token decoded WITHOUT verification to inspect structure
4. Token verified using `JwtService.verifyAsync(token)`
5. User data attached to `client.data.user`

**Logging Added:**
```javascript
console.log('[WS Handshake] Auth object:', { hasAuth, authKeys, hasToken });
console.log('[WS Auth] Token received:', { present, type, length, preview });
console.log('[WS Auth] Decoded token (unverified):', { header, payload });
console.log('[WS Auth] Attempting verification with algorithm: HS256');
// On success:
console.log('[WS Auth] Verification SUCCESS:', { sub, email, role, exp });
// On failure:
console.error('[WS Auth] Verification FAILED:', { message, name, stack });
```

**Key Configuration:**
```javascript
// Extract from handshake
const token = client.handshake.auth?.token ||
              client.handshake.headers?.authorization?.replace('Bearer ', '');
// Verify with JwtService
const payload = await this.jwtService.verifyAsync(token);
```

### Verification Configuration

**Location:** `apps/api/src/modules/auth/auth.module.ts` line 12-27

**Original Configuration (Before Fix):**
```typescript
JwtModule.registerAsync({
  useFactory: (configService) => ({
    secret: configService.get<string>('JWT_SECRET'),
    signOptions: { expiresIn: '15m' }
    // NO verifyOptions - defaults to accepting any algorithm
  })
})
```

**Fixed Configuration (After Investigation):**
```typescript
JwtModule.registerAsync({
  useFactory: (configService) => ({
    secret: configService.get<string>('JWT_SECRET'),
    signOptions: {
      expiresIn: '15m',
      algorithm: 'HS256' // Explicit signing algorithm
    },
    verifyOptions: {
      algorithms: ['HS256'] // CRITICAL: Restrict verification to HS256 only
    }
  })
})
```

**Logging Added:**
```javascript
console.log('[Auth Module] JWT configured:', {
  secretPresent: !!secret,
  secretLength: secret?.length,
  expiresIn,
  algorithm: 'HS256'
});
```

**Backend Startup Log:**
```
[Auth Module] JWT configured: {
  secretPresent: true,
  secretLength: 61,
  expiresIn: '15m',
  algorithm: 'HS256'
}
```

## Configuration Analysis

### Frontend (NextAuth)

**File:** `apps/web/lib/auth.ts`

**JWT_SECRET Source:**
```typescript
const jwtSecret = process.env.JWT_SECRET || 'dev-jwt-secret-change-in-production';
```

**Algorithm:** HS256 (implicit - default for `jwt.sign` with string secret)

**Token Structure:**
- Header: `{ alg: 'HS256', typ: 'JWT' }`
- Payload: `{ sub: userId, email: userEmail, role: userRole, iat, exp }`
- Signature: HMAC-SHA256(header + payload, JWT_SECRET)

### Backend (NestJS)

**File:** `apps/api/src/modules/auth/auth.module.ts`

**JWT_SECRET Source:**
```typescript
const secret = configService.get<string>('JWT_SECRET');
```

**Algorithm:** HS256 (now explicit via signOptions and verifyOptions)

**Verification:** `jwtService.verifyAsync(token)` using configured secret

### Environment Configuration

**File:** `.env` (monorepo root)

**Key Variable:**
```bash
JWT_SECRET=dev-secret-change-in-production-min-32-chars-required-for-jwt
```

**Loading:**
- Frontend: Next.js loads from `.env.local` or `.env` (server-side only)
- Backend: NestJS loads from `.env` via ConfigService

## Root Cause Hypothesis

### Confirmed: JWT_SECRET Mismatch

**Hypothesis:** Frontend (NextAuth) and backend (NestJS) are using different JWT_SECRET values.

**Evidence:**
1. Test with default secret `'dev-jwt-secret-change-in-production'` → Verification FAILED with "invalid signature"
2. Test with .env secret `'dev-secret-change-in-production-min-32-chars-required-for-jwt'` → Verification SUCCESS
3. Backend logs confirm correct secret length (61 characters) matches .env value
4. Frontend has fallback to different default secret

**Mechanism:**
```
Frontend generates token:
  HMAC-SHA256(header + payload, SECRET_A) → signature_A

Backend verifies token:
  HMAC-SHA256(header + payload, SECRET_B) → signature_B

  signature_A ≠ signature_B → "invalid signature" error
```

**Why it happens:**
- NextAuth fallback secret: `'dev-jwt-secret-change-in-production'` (40 chars)
- Expected .env secret: `'dev-secret-change-in-production-min-32-chars-required-for-jwt'` (61 chars)
- If frontend doesn't load JWT_SECRET from .env correctly, it uses fallback
- Backend always loads from .env via ConfigService
- Result: Different secrets → signature mismatch

### Ruled Out: Algorithm Mismatch

**Initial Concern:** Frontend might be generating JWE (encrypted) instead of JWS (signed) tokens, or using different algorithm.

**Ruled Out By:**
- Decoded token header shows `alg: 'HS256'` on both frontend and backend
- No encryption detected (JWE would have different header structure)
- Both using standard JWT format with three base64url-encoded parts

### Ruled Out: Token Not Reaching Backend

**Initial Concern:** Token might not be transmitted correctly via Socket.IO handshake.

**Ruled Out By:**
- Backend logs show `hasAuth: true, hasToken: true`
- Token length matches (212 characters)
- Token preview matches between generation and reception
- Token successfully decodes (structure is valid)

### Ruled Out: Timing/Expiration Issue

**Initial Concern:** Token might expire between generation and verification.

**Ruled Out By:**
- Test tokens created seconds before verification
- Expiration set to 15 minutes (900 seconds)
- Backend logs show future `exp` timestamp
- Error is "invalid signature", not "jwt expired"

## Recommendations for Phase 5.2

### Primary Fix: Ensure Consistent JWT_SECRET Loading

**Frontend Investigation:**
1. Verify `.env` or `.env.local` file exists in `apps/web/` directory
2. Verify `JWT_SECRET` is defined in Next.js environment
3. Confirm Next.js server has access to secret (not client-side)
4. Add startup logging to confirm loaded secret value (length/presence, not full value)

**Backend Validation:**
- Already loading correctly via ConfigService ✓
- Already logging secret presence and length ✓

### Secondary Fix: Remove Fallback Secrets

**Current Code:**
```typescript
const jwtSecret = process.env.JWT_SECRET || 'dev-jwt-secret-change-in-production';
```

**Recommended:**
```typescript
const jwtSecret = process.env.JWT_SECRET;
if (!jwtSecret) {
  throw new Error('JWT_SECRET is not defined - check .env configuration');
}
```

**Rationale:** Fail fast with clear error instead of silently using wrong secret.

### Tertiary: Add Token Validation in Development

**Add to frontend logging:**
```typescript
// After generating token, verify it can be decoded
const decoded = jwt.decode(accessToken, { complete: true });
console.log('[NextAuth Session] Token self-check:', {
  algorithm: decoded?.header?.alg,
  expires: new Date(decoded?.payload?.exp * 1000).toISOString(),
  valid: !!decoded
});
```

## Next Steps

1. **Phase 5.2 Plan 01**: Implement JWT_SECRET consistency fix
   - Verify environment variable loading on frontend
   - Add error handling for missing JWT_SECRET
   - Remove fallback secrets
   - Add startup validation

2. **Phase 5.2 Plan 02**: End-to-end verification
   - Test actual login flow (not just test script)
   - Verify WebSocket connection from browser console
   - Confirm real-time features work (presence, task updates, comments)
   - Validate all Phase 3 real-time functionality

3. **Phase 5.2 Plan 03**: Security hardening
   - Rotate JWT_SECRET to production-grade value
   - Add JWT_SECRET validation (min length, complexity)
   - Document secret management in deployment guide
   - Add monitoring for verification failures

## Appendix: Log Excerpts

### Successful Connection Flow

```
[Auth Module] JWT configured: {
  secretPresent: true,
  secretLength: 61,
  expiresIn: '15m',
  algorithm: 'HS256'
}

========== WebSocket Connection Attempt ==========
[WS Handshake] Auth object: { hasAuth: true, authKeys: [ 'token' ], hasToken: true }
[WS Auth] Token received: { present: true, type: 'string', length: 212 }
[WS Auth] Decoded token (unverified): {
  header: { alg: 'HS256', typ: 'JWT' },
  payload: { sub: 'test-user-id', email: 'test@example.com', role: 'ADMIN' }
}
[WS Auth] Attempting verification with algorithm: HS256
[WS Auth] Verification SUCCESS: { sub: 'test-user-id', email: 'test@example.com' }
[WS Auth] CONNECTED: user test-user-id
```

### Failed Connection Flow

```
========== WebSocket Connection Attempt ==========
[WS Handshake] Auth object: { hasAuth: true, authKeys: [ 'token' ], hasToken: true }
[WS Auth] Token received: { present: true, type: 'string', length: 212 }
[WS Auth] Decoded token (unverified): {
  header: { alg: 'HS256', typ: 'JWT' },
  payload: { sub: 'test-user-id', email: 'test@example.com', role: 'ADMIN' }
}
[WS Auth] Attempting verification with algorithm: HS256
[WS Auth] Verification FAILED: {
  message: 'invalid signature',
  name: 'JsonWebTokenError'
}
[WS Auth] REJECTED: Invalid token
```

## Conclusion

The WebSocket authentication failure is definitively caused by JWT_SECRET mismatch between frontend and backend. The comprehensive logging added in Phase 5.1 Plan 01 provides complete visibility into the token lifecycle and will be invaluable for ongoing debugging.

The fix is straightforward: ensure both applications load the same JWT_SECRET from the shared .env file. The explicit algorithm configuration (`verifyOptions: { algorithms: ['HS256'] }`) added as a security improvement will prevent algorithm confusion attacks.

All real-time features (presence, task updates, comments) are blocked by this authentication issue. Once resolved, Phase 3 functionality should work as designed.
