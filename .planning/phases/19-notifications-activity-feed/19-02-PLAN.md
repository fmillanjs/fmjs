---
phase: 19-notifications-activity-feed
plan: 02
type: execute
wave: 2
depends_on: [19-01]
files_modified:
  - apps/devcollab-api/src/notifications/notifications.module.ts
  - apps/devcollab-api/src/notifications/notifications.service.ts
  - apps/devcollab-api/src/notifications/notifications.controller.ts
  - apps/devcollab-api/src/notifications/dto/mark-read.dto.ts
  - apps/devcollab-api/src/activity/activity.module.ts
  - apps/devcollab-api/src/activity/activity.service.ts
  - apps/devcollab-api/src/activity/activity.controller.ts
  - apps/devcollab-api/src/activity/dto/feed-query.dto.ts
  - apps/devcollab-api/src/comments/comments.service.ts
  - apps/devcollab-api/src/workspaces/workspaces.service.ts
  - apps/devcollab-api/src/posts/posts.service.ts
  - apps/devcollab-api/src/snippets/snippets.service.ts
  - apps/devcollab-api/src/app.module.ts
  - apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts
autonomous: true
requirements: [NOTF-01, NOTF-02, NOTF-03, FEED-01]

must_haves:
  truths:
    - "GET /notifications/unread-count returns { count: N } for authenticated user"
    - "GET /notifications returns a list of up to 50 notifications for the current user, newest first"
    - "PATCH /notifications/:id/read marks a single notification as read"
    - "PATCH /notifications/read-all marks all unread notifications as read"
    - "Posting a comment with @name triggers a Notification row for the mentioned user"
    - "GET /workspaces/:slug/activity returns paginated events with nextCursor"
    - "WorkspacesService.joinWorkspace, PostsService.create, PostsService.update, SnippetsService.create, SnippetsService.update each write an ActivityEvent row"
    - "Meta-test passes with CommentsController, ReactionsController, NotificationsController, ActivityController included"
  artifacts:
    - path: "apps/devcollab-api/src/notifications/notifications.controller.ts"
      provides: "4 notification endpoints (list, unread-count, mark-read, mark-all-read)"
      exports: ["NotificationsController"]
    - path: "apps/devcollab-api/src/notifications/notifications.service.ts"
      provides: "list, unreadCount, markRead, markAllRead methods"
      exports: ["NotificationsService"]
    - path: "apps/devcollab-api/src/activity/activity.controller.ts"
      provides: "GET /workspaces/:slug/activity endpoint"
      exports: ["ActivityController"]
    - path: "apps/devcollab-api/src/activity/activity.service.ts"
      provides: "findFeed with cursor pagination"
      exports: ["ActivityService"]
    - path: "apps/devcollab-api/src/comments/comments.service.ts"
      provides: "extractMentionedNames + notifyMentions helpers called in create + update"
  key_links:
    - from: "apps/devcollab-api/src/comments/comments.service.ts"
      to: "prisma.notification.createMany"
      via: "notifyMentions() called after comment.create() and comment.update()"
      pattern: "notifyMentions"
    - from: "apps/devcollab-api/src/workspaces/workspaces.service.ts"
      to: "prisma.activityEvent.create"
      via: "direct call after workspaceMember.create() in joinWorkspace()"
      pattern: "activityEvent.create"
    - from: "apps/devcollab-api/src/app.module.ts"
      to: "NotificationsModule + ActivityModule"
      via: "imports array"
      pattern: "NotificationsModule"
---

<objective>
Create NotificationsModule (4 endpoints: list, unread-count, mark-read, mark-all-read), ActivityModule (workspace-scoped feed with cursor pagination), wire @mention notification side-effects into CommentsService, wire activity logging into WorkspacesService/PostsService/SnippetsService, update AppModule, and expand the meta-test to cover all 7 controllers.

Purpose: This delivers the complete backend for Phase 19. After this plan, the frontend can poll these endpoints.
Output: 2 new NestJS modules, 14 files created/modified, meta-test expanded.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-notifications-activity-feed/19-RESEARCH.md
@.planning/phases/19-notifications-activity-feed/19-01-SUMMARY.md

@apps/devcollab-api/src/app.module.ts
@apps/devcollab-api/src/comments/comments.service.ts
@apps/devcollab-api/src/workspaces/workspaces.service.ts
@apps/devcollab-api/src/posts/posts.service.ts
@apps/devcollab-api/src/snippets/snippets.service.ts
@apps/devcollab-api/src/workspaces/workspace-ability.factory.ts
@apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotificationsModule + ActivityModule (controllers, services, DTOs)</name>
  <files>
    apps/devcollab-api/src/notifications/notifications.module.ts
    apps/devcollab-api/src/notifications/notifications.service.ts
    apps/devcollab-api/src/notifications/notifications.controller.ts
    apps/devcollab-api/src/notifications/dto/mark-read.dto.ts
    apps/devcollab-api/src/activity/activity.module.ts
    apps/devcollab-api/src/activity/activity.service.ts
    apps/devcollab-api/src/activity/activity.controller.ts
    apps/devcollab-api/src/activity/dto/feed-query.dto.ts
  </files>
  <action>
**Create `apps/devcollab-api/src/notifications/dto/mark-read.dto.ts`:**
Empty DTO (mark-read uses only the :id param, no body needed):
```typescript
export class MarkReadDto {}
```

**Create `apps/devcollab-api/src/notifications/notifications.service.ts`:**
```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../core/database/prisma.service';

@Injectable()
export class NotificationsService {
  constructor(private readonly prisma: PrismaService) {}

  async list(userId: string) {
    return this.prisma.notification.findMany({
      where: { recipientId: userId },
      orderBy: { createdAt: 'desc' },
      take: 50,
      include: {
        actor: { select: { id: true, name: true, email: true } },
        comment: { select: { id: true, postId: true, snippetId: true } },
        workspace: { select: { id: true, slug: true, name: true } },
      },
    });
  }

  async unreadCount(userId: string) {
    const count = await this.prisma.notification.count({
      where: { recipientId: userId, read: false },
    });
    return { count };
  }

  async markRead(id: string, userId: string) {
    const notification = await this.prisma.notification.findFirst({
      where: { id, recipientId: userId },
    });
    if (!notification) throw new NotFoundException('Notification not found');
    return this.prisma.notification.update({
      where: { id },
      data: { read: true },
    });
  }

  async markAllRead(userId: string) {
    const result = await this.prisma.notification.updateMany({
      where: { recipientId: userId, read: false },
      data: { read: true },
    });
    return { updated: result.count };
  }
}
```

**Create `apps/devcollab-api/src/notifications/notifications.controller.ts`:**

CRITICAL — Route order: static segments BEFORE param segments. `unread-count` MUST be before `:id/read`, and `read-all` MUST be before `:id/read`. Both are different HTTP methods here (GET vs PATCH) so the primary concern is the GET routes.

```typescript
import { Controller, Get, Patch, Param } from '@nestjs/common';
import { NotificationsService } from './notifications.service';
import { CheckAbility } from '../common/decorators/check-ability.decorator';
import { CurrentUser } from '../common/decorators/current-user.decorator';
import { JwtPayload } from '../auth/auth.service';

@Controller('notifications')
export class NotificationsController {
  constructor(private readonly notificationsService: NotificationsService) {}

  // STATIC ROUTE FIRST — must be before :id to avoid NestJS matching 'unread-count' as :id
  @CheckAbility('read', 'Notification')
  @Get('unread-count')
  unreadCount(@CurrentUser() user: JwtPayload) {
    return this.notificationsService.unreadCount(user.sub);
  }

  @CheckAbility('read', 'Notification')
  @Get()
  list(@CurrentUser() user: JwtPayload) {
    return this.notificationsService.list(user.sub);
  }

  // STATIC ROUTE FIRST — read-all before :id/read
  @CheckAbility('update', 'Notification')
  @Patch('read-all')
  markAllRead(@CurrentUser() user: JwtPayload) {
    return this.notificationsService.markAllRead(user.sub);
  }

  @CheckAbility('update', 'Notification')
  @Patch(':id/read')
  markRead(@Param('id') id: string, @CurrentUser() user: JwtPayload) {
    return this.notificationsService.markRead(id, user.sub);
  }
}
```

Note: JwtPayload is imported from auth.service.ts — it is exported from that file per the Phase 15 decision (SafeUser/JwtPayload exported to satisfy TS4053). Check the actual export name in auth.service.ts; if it is not exported as `JwtPayload`, use the decorator's inferred type or import from `current-user.decorator.ts`.

**Create `apps/devcollab-api/src/notifications/notifications.module.ts`:**
```typescript
import { Module } from '@nestjs/common';
import { DatabaseModule } from '../core/database/database.module';
import { NotificationsService } from './notifications.service';
import { NotificationsController } from './notifications.controller';

@Module({
  imports: [DatabaseModule],
  controllers: [NotificationsController],
  providers: [NotificationsService],
})
export class NotificationsModule {}
```

**Create `apps/devcollab-api/src/activity/dto/feed-query.dto.ts`:**
```typescript
export class FeedQueryDto {
  cursor?: string;
}
```

**Create `apps/devcollab-api/src/activity/activity.service.ts`:**
```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../core/database/prisma.service';

const PAGE_SIZE = 20;

@Injectable()
export class ActivityService {
  constructor(private readonly prisma: PrismaService) {}

  async findFeed(slug: string, cursor?: string) {
    const workspace = await this.prisma.workspace.findUnique({
      where: { slug },
      select: { id: true, slug: true },
    });
    if (!workspace) throw new NotFoundException('Workspace not found');

    const events = await this.prisma.activityEvent.findMany({
      where: {
        workspaceId: workspace.id,
        ...(cursor ? { createdAt: { lt: new Date(cursor) } } : {}),
      },
      orderBy: { createdAt: 'desc' },
      take: PAGE_SIZE,
      include: {
        actor: { select: { id: true, name: true, email: true } },
      },
    });

    const nextCursor =
      events.length === PAGE_SIZE
        ? events[events.length - 1].createdAt.toISOString()
        : null;

    return { events, nextCursor, workspaceSlug: workspace.slug };
  }
}
```

Note: `workspaceSlug` is included in the response so the frontend can construct entity deep-links (e.g., `/w/${slug}/posts/${entityId}`) without needing to know the slug from another source.

**Create `apps/devcollab-api/src/activity/activity.controller.ts`:**
```typescript
import { Controller, Get, Param, Query } from '@nestjs/common';
import { ActivityService } from './activity.service';
import { CheckAbility } from '../common/decorators/check-ability.decorator';

@Controller('workspaces/:slug/activity')
export class ActivityController {
  constructor(private readonly activityService: ActivityService) {}

  @CheckAbility('read', 'ActivityEvent')
  @Get()
  findFeed(
    @Param('slug') slug: string,
    @Query('cursor') cursor?: string,
  ) {
    return this.activityService.findFeed(slug, cursor);
  }
}
```

**Create `apps/devcollab-api/src/activity/activity.module.ts`:**
```typescript
import { Module } from '@nestjs/common';
import { DatabaseModule } from '../core/database/database.module';
import { ActivityService } from './activity.service';
import { ActivityController } from './activity.controller';

@Module({
  imports: [DatabaseModule],
  controllers: [ActivityController],
  providers: [ActivityService],
})
export class ActivityModule {}
```
  </action>
  <verify>
`cd /home/doctor/fernandomillan/apps/devcollab-api && npx tsc --noEmit`
Expected: 0 TypeScript errors across all new files.
  </verify>
  <done>
8 new files created. `tsc --noEmit` exits 0. NotificationsController has 4 decorated methods in the correct static-before-param order. ActivityController has 1 method. Both modules import DatabaseModule.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire mention notifications + activity logging into existing services, update AppModule, expand meta-test</name>
  <files>
    apps/devcollab-api/src/comments/comments.service.ts
    apps/devcollab-api/src/workspaces/workspaces.service.ts
    apps/devcollab-api/src/posts/posts.service.ts
    apps/devcollab-api/src/snippets/snippets.service.ts
    apps/devcollab-api/src/app.module.ts
    apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts
  </files>
  <action>
**1. Update `apps/devcollab-api/src/comments/comments.service.ts`:**

Add two private helpers AFTER the constructor but BEFORE `create()`. Then call `notifyMentions` at the end of `create()` and `update()`.

Add private helpers:
```typescript
  private extractMentionedNames(content: string): string[] {
    const matches = [...content.matchAll(/@(\w+)/g)];
    return [...new Set(matches.map((m) => m[1]))];
  }

  private async notifyMentions(
    content: string,
    workspaceId: string,
    authorId: string,
    commentId: string,
  ): Promise<void> {
    const names = this.extractMentionedNames(content);
    if (names.length === 0) return;

    // Resolve @names to workspace members — workspace-scoped to prevent cross-workspace mentions
    const mentioned = await this.prisma.user.findMany({
      where: {
        name: { in: names },
        workspaceMemberships: { some: { workspaceId } },
      },
      select: { id: true },
    });

    // Exclude the author (don't notify yourself)
    const recipients = mentioned.map((u) => u.id).filter((id) => id !== authorId);
    if (recipients.length === 0) return;

    // skipDuplicates: true prevents duplicate notifications on comment edit
    await this.prisma.notification.createMany({
      data: recipients.map((recipientId) => ({
        recipientId,
        actorId: authorId,
        type: 'mention',
        commentId,
        workspaceId,
        read: false,
      })),
      skipDuplicates: true,
    });
  }
```

In `create()`, after `return this.prisma.comment.create(...)` — change it to capture the result, call notifyMentions, then return:
```typescript
    // Replace the final return statement with:
    const comment = await this.prisma.comment.create({
      data: {
        content: dto.content,
        authorId,
        postId: dto.postId,
        snippetId: dto.snippetId,
        parentId: dto.parentId,
      },
    });

    // Resolve workspaceId for mention notification
    // workspace is already resolved above (workspaceId check at top of method)
    await this.notifyMentions(dto.content, workspace.id, authorId, comment.id);
    return comment;
```

In `update()`, after the `return this.prisma.comment.update(...)` — change to capture result, call notifyMentions, then return:
```typescript
    // Replace the final return with:
    const comment = await this.prisma.comment.update({
      where: { id },
      data: { content: dto.content },
    });
    await this.notifyMentions(dto.content, workspace.id, requesterId, id);
    return comment;
```

**2. Update `apps/devcollab-api/src/workspaces/workspaces.service.ts`:**

In `joinWorkspace()`, after the `return await this.prisma.workspaceMember.create(...)` block succeeds, add an activity log call. The try/catch wraps the member creation — add the activity log INSIDE the try block, after the member is created:

```typescript
      const member = await this.prisma.workspaceMember.create({
        data: {
          userId,
          workspaceId: invite.workspaceId,
          role: 'Contributor',
        },
      });

      // Log workspace join activity
      await this.prisma.activityEvent.create({
        data: {
          type: 'MemberJoined',
          workspaceId: invite.workspaceId,
          actorId: userId,
          entityId: userId,
          entityType: 'User',
        },
      });

      return member;
```

**3. Update `apps/devcollab-api/src/posts/posts.service.ts`:**

In `create()`, after `return this.prisma.post.create(...)` — capture result, log activity, return:
```typescript
    const post = await this.prisma.post.create({
      data: { ...dto, authorId, workspaceId: workspace.id, status: 'Draft' },
    });

    await this.prisma.activityEvent.create({
      data: {
        type: 'PostCreated',
        workspaceId: workspace.id,
        actorId: authorId,
        entityId: post.id,
        entityType: 'Post',
      },
    });

    return post;
```

In `update()`, after `return this.prisma.post.update(...)` — capture result, log activity, return:
```typescript
    const post = await this.prisma.post.update({ where: { id }, data: dto });

    await this.prisma.activityEvent.create({
      data: {
        type: 'PostUpdated',
        workspaceId: workspace.id,
        actorId: requesterId,
        entityId: id,
        entityType: 'Post',
      },
    });

    return post;
```

**4. Update `apps/devcollab-api/src/snippets/snippets.service.ts`:**

In `create()`, after `return this.prisma.snippet.create(...)` — capture, log, return:
```typescript
    const snippet = await this.prisma.snippet.create({
      data: { ...dto, authorId, workspaceId: workspace.id },
    });

    await this.prisma.activityEvent.create({
      data: {
        type: 'SnippetCreated',
        workspaceId: workspace.id,
        actorId: authorId,
        entityId: snippet.id,
        entityType: 'Snippet',
      },
    });

    return snippet;
```

In `update()`, after `return this.prisma.snippet.update(...)` — capture, log, return:
```typescript
    const snippet = await this.prisma.snippet.update({ where: { id }, data: dto });

    await this.prisma.activityEvent.create({
      data: {
        type: 'SnippetUpdated',
        workspaceId: workspace.id,
        actorId: requesterId,
        entityId: id,
        entityType: 'Snippet',
      },
    });

    return snippet;
```

**5. Update `apps/devcollab-api/src/app.module.ts`:**

Add imports at the top:
```typescript
import { NotificationsModule } from './notifications/notifications.module';
import { ActivityModule } from './activity/activity.module';
```

Add to the `imports` array (after ReactionsModule):
```typescript
    NotificationsModule,
    ActivityModule,
```

**6. Update `apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts`:**

Add the missing Phase 18 controllers (CommentsController, ReactionsController) and the new Phase 19 controllers (NotificationsController, ActivityController).

Add imports:
```typescript
import { CommentsController } from '../../../src/comments/comments.controller';
import { ReactionsController } from '../../../src/reactions/reactions.controller';
import { NotificationsController } from '../../../src/notifications/notifications.controller';
import { ActivityController } from '../../../src/activity/activity.controller';
```

Update ALL_CONTROLLERS array:
```typescript
const ALL_CONTROLLERS = [
  HealthController,
  AuthController,
  WorkspacesController,
  SnippetsController,
  PostsController,
  CommentsController,
  ReactionsController,
  NotificationsController,
  ActivityController,
] as const;
```
  </action>
  <verify>
1. `cd /home/doctor/fernandomillan/apps/devcollab-api && npx tsc --noEmit` — 0 TypeScript errors
2. `cd /home/doctor/fernandomillan && npx vitest run apps/devcollab-api/test/unit/meta/controller-coverage.spec.ts` — all tests pass (each controller method has @CheckAbility or @Public)
3. Start the API: `cd /home/doctor/fernandomillan && docker compose exec devcollab-api node dist/main.js` OR test via `curl -s http://localhost:3003/health` to confirm API still starts (if already running in Docker)
  </verify>
  <done>
`tsc --noEmit` exits 0. Meta-test passes with all 9 controllers covered. AppModule imports NotificationsModule and ActivityModule. CommentsService has notifyMentions helper called in create + update. WorkspacesService/PostsService/SnippetsService write ActivityEvent rows after their primary operations.
  </done>
</task>

</tasks>

<verification>
- `tsc --noEmit` in apps/devcollab-api passes with 0 errors
- Meta-test vitest passes for all 9 controllers
- `GET /notifications/unread-count` returns `{ count: 0 }` for a logged-in user (verify with curl using devcollab_token cookie)
- `GET /workspaces/:slug/activity` returns `{ events: [], nextCursor: null }` for an empty workspace (verify with curl)
</verification>

<success_criteria>
1. NotificationsController has 4 endpoints with correct route order (static before param)
2. ActivityController has 1 endpoint scoped to workspaces/:slug/activity
3. CommentsService.create and CommentsService.update call notifyMentions after the primary DB operation
4. WorkspacesService.joinWorkspace, PostsService.create/update, SnippetsService.create/update each write an ActivityEvent row
5. AppModule includes NotificationsModule and ActivityModule
6. Meta-test covers all 9 controllers and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-notifications-activity-feed/19-02-SUMMARY.md`
</output>
