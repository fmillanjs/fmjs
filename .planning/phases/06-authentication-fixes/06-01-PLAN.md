---
phase: 06-authentication-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/.env.local
  - apps/web/lib/auth.ts
  - .env
autonomous: true

must_haves:
  truths:
    - "Frontend and backend load identical JWT_SECRET from environment"
    - "Application fails fast with clear error if JWT_SECRET is missing"
    - "Application fails fast with clear error if JWT_SECRET is too short"
    - "JWT_SECRET is cryptographically secure (512-bit minimum)"
    - "Secret fingerprints logged on both apps confirm consistency"
  artifacts:
    - path: "apps/web/.env.local"
      provides: "JWT_SECRET variable matching root .env"
      contains: "JWT_SECRET="
      min_lines: 15
    - path: "apps/web/lib/auth.ts"
      provides: "Fail-fast JWT_SECRET validation with length check"
      exports: ["authConfig"]
      min_lines: 230
    - path: ".env"
      provides: "Rotated 512-bit JWT_SECRET"
      contains: "JWT_SECRET="
  key_links:
    - from: "apps/web/.env.local"
      to: "apps/web/lib/auth.ts"
      via: "process.env.JWT_SECRET"
      pattern: "process\\.env\\.JWT_SECRET"
    - from: ".env"
      to: "apps/api/src/modules/auth/auth.module.ts"
      via: "ConfigService.get('JWT_SECRET')"
      pattern: "configService\\.get.*JWT_SECRET"
---

<objective>
Fix JWT_SECRET configuration mismatch preventing WebSocket authentication by ensuring consistent environment variable loading across frontend and backend applications.

Purpose: Unblock all Phase 3 real-time collaboration features (presence, task updates, comments, conflict detection) by resolving the root cause identified in Phase 5.1 investigation - JWT_SECRET mismatch between NextAuth (using fallback) and NestJS (using .env).

Output: Consistent JWT configuration with fail-fast validation, cryptographically secure 512-bit secret, and verified secret fingerprints matching across both applications.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-authentication-fixes/06-RESEARCH.md
@.planning/phases/05.1-authentication-investigation/05.1-01-SUMMARY.md
@.planning/phases/05.1-authentication-investigation/05.1-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generate cryptographically secure JWT_SECRET and add to .env.local</name>
  <files>
    apps/web/.env.local
    .env
  </files>
  <action>
Generate a cryptographically secure 512-bit (64-byte) JWT secret using Node.js crypto module and update both environment files.

**Step 1: Generate new secret**
Run: `node -e "console.log(require('crypto').randomBytes(64).toString('base64'))"`

**Step 2: Update root .env**
Replace existing JWT_SECRET line with newly generated 512-bit secret:
```bash
JWT_SECRET=<new-64-byte-base64-encoded-secret>
```

**Step 3: Add JWT_SECRET to apps/web/.env.local**
Add the EXACT same JWT_SECRET value after line 9 (after NEXTAUTH_URL):
```bash
# JWT (CRITICAL - must match root .env for WebSocket auth)
JWT_SECRET=<same-64-byte-secret>
```

**Verification:**
- Both files contain identical JWT_SECRET value
- Secret is base64-encoded string (approximately 88 characters long for 64 bytes)
- No trailing whitespace or line breaks in secret value

**Why this matters:**
Root cause from Phase 5.1: Next.js doesn't automatically load root .env file. Frontend NextAuth was using fallback secret (40 chars) while backend NestJS used .env secret (61 chars), causing HMAC signature mismatch. This fix ensures both apps load the same secret.
  </action>
  <verify>
Run: `grep "^JWT_SECRET=" .env apps/web/.env.local | cut -d= -f2 | sort -u | wc -l`
Expected output: `1` (both files have identical JWT_SECRET value)

Also verify secret length:
Run: `grep "^JWT_SECRET=" .env | cut -d= -f2 | wc -c`
Expected: ~89 characters (88 base64 chars + newline = 64 bytes)
  </verify>
  <done>
- .env contains rotated 512-bit JWT_SECRET
- apps/web/.env.local contains identical JWT_SECRET value
- Both files verified to have matching secrets (wc -l returns 1)
- Secret length verified as ~88 characters (512 bits)
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove fallback secret and add fail-fast validation to NextAuth</name>
  <files>apps/web/lib/auth.ts</files>
  <action>
Update the NextAuth session callback (around line 204) to remove the dangerous fallback secret and add comprehensive fail-fast validation with secret fingerprint logging.

**Replace this code** (line 204):
```typescript
const jwtSecret = process.env.JWT_SECRET || 'dev-jwt-secret-change-in-production';
```

**With this validation block**:
```typescript
// Fail-fast validation: JWT_SECRET is REQUIRED for WebSocket authentication
const jwtSecret = process.env.JWT_SECRET;

if (!jwtSecret) {
  throw new Error(
    'JWT_SECRET environment variable is required for WebSocket authentication. ' +
    'Add JWT_SECRET to apps/web/.env.local with the same value as the root .env file.'
  );
}

if (jwtSecret.length < 32) {
  throw new Error(
    `JWT_SECRET must be at least 32 characters (256 bits). Current length: ${jwtSecret.length}. ` +
    `Generate a secure secret with: node -e "console.log(require('crypto').randomBytes(64).toString('base64'))"`
  );
}

// Log secret fingerprint for verification (NOT the full secret)
const crypto = require('crypto');
const secretHash = crypto.createHash('sha256').update(jwtSecret).digest('hex');
console.log('[NextAuth Session] JWT Secret validated:', {
  length: jwtSecret.length,
  fingerprint: secretHash.substring(0, 16), // First 16 chars of SHA256 hash
});
```

**Why remove fallback:**
Fallback secrets mask configuration errors (Phase 5.1 root cause). Failing fast with clear error message saves debugging time and prevents production issues.

**Why add validation:**
- Minimum length check prevents weak secrets vulnerable to brute force
- Clear error messages guide developers to correct configuration
- Fingerprint logging allows verification without exposing actual secret

**Note:** This validation runs in the session callback, so it will execute on the first session access after startup. Consider moving to a top-level startup validation if you want earlier failure detection (current placement is acceptable per research findings).
  </action>
  <verify>
Run: `grep -n "process.env.JWT_SECRET ||" apps/web/lib/auth.ts`
Expected: No matches (fallback removed)

Run: `grep -n "throw new Error.*JWT_SECRET environment variable is required" apps/web/lib/auth.ts`
Expected: Match found (validation added)

Run: `grep -n "fingerprint:" apps/web/lib/auth.ts`
Expected: Match found (fingerprint logging added)
  </verify>
  <done>
- Fallback secret removed from auth.ts (no `|| 'dev-jwt-secret...'` pattern exists)
- Fail-fast validation throws clear error if JWT_SECRET is missing
- Fail-fast validation throws clear error if JWT_SECRET is too short (< 32 chars)
- Secret fingerprint logging added (SHA256 hash, not full secret)
- Code compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify secret fingerprints match across frontend and backend</name>
  <files>N/A</files>
  <action>
Start both applications and verify that the secret fingerprints logged on startup match, confirming both apps load the same JWT_SECRET.

**Step 1: Start backend (in one terminal)**
```bash
cd /home/doctor/fernandomillan/apps/api
npm run dev
```

Look for backend log output:
```
[Auth Module] JWT configured: {
  secretPresent: true,
  secretLength: <number>,
  expiresIn: '15m',
  algorithm: 'HS256'
}
```

Note the `secretLength` value.

**Step 2: Start frontend (in another terminal)**
```bash
cd /home/doctor/fernandomillan/apps/web
npm run dev
```

**Step 3: Trigger frontend session callback**
Open browser to http://localhost:3000/login and login as demo1@teamflow.dev / Password123!

Look for frontend log output in web server terminal:
```
[NextAuth Session] JWT Secret validated: {
  length: <number>,
  fingerprint: '<16-char-hash>'
}
```

**Step 4: Compare lengths**
Frontend `length` should match backend `secretLength` (approximately 88 characters for 64-byte base64).

**Step 5: Extract backend fingerprint for comparison**
The backend doesn't currently log fingerprint (it was added in Phase 5.1 investigation but for diagnostic purposes). We can verify consistency by checking that:
1. Both report the same secret length
2. Frontend validation passes (no errors thrown)
3. WebSocket connection succeeds in Plan 02 (full integration test)

**If lengths don't match:**
- Double-check .env and apps/web/.env.local have identical JWT_SECRET values
- Ensure no trailing spaces or newlines in secret values
- Restart both servers to reload environment variables

**Expected outcome:**
- Backend logs: `secretLength: 88` (or similar for 64-byte base64)
- Frontend logs: `length: 88`, `fingerprint: <hash>`
- No validation errors thrown
  </action>
  <verify>
Check logs for matching secret lengths:

Backend terminal should show:
`secretLength: 88` (approximately)

Frontend terminal should show:
`length: 88` (approximately)

Both values should be identical. Minor differences (87-90) are acceptable due to base64 encoding variations.

No error messages about JWT_SECRET missing or being too short.
  </verify>
  <done>
- Backend application starts successfully and logs JWT configuration
- Frontend application starts successfully and logs JWT validation
- Secret lengths match between backend and frontend logs
- No validation errors thrown
- Both applications running without JWT-related errors
  </done>
</task>

</tasks>

<verification>
**Overall Phase Verification:**

1. **Environment files updated:**
   ```bash
   # Both files should have identical JWT_SECRET
   diff <(grep "^JWT_SECRET=" .env | cut -d= -f2) <(grep "^JWT_SECRET=" apps/web/.env.local | cut -d= -f2)
   # Expected: No output (files match)
   ```

2. **Fail-fast validation present:**
   ```bash
   grep -A5 "if (!jwtSecret)" apps/web/lib/auth.ts
   # Expected: Error throwing code visible
   ```

3. **Applications start successfully:**
   - Backend logs JWT configuration without errors
   - Frontend logs JWT validation without errors
   - Secret lengths match

4. **No fallback secrets remain:**
   ```bash
   grep -r "dev-jwt-secret" apps/web/lib/auth.ts
   # Expected: No matches
   ```

**Success criteria:**
- ✓ Consistent JWT_SECRET across both apps
- ✓ Fail-fast validation prevents misconfiguration
- ✓ Cryptographically secure 512-bit secret in use
- ✓ Secret fingerprints confirm consistency
- ✓ No fallback secrets masking configuration errors
</verification>

<success_criteria>
**Phase 6 Plan 01 is complete when:**

1. **Configuration consistency achieved:**
   - .env contains new 512-bit JWT_SECRET
   - apps/web/.env.local contains identical JWT_SECRET
   - Both files verified to match (diff returns no differences)

2. **Fail-fast validation implemented:**
   - Missing JWT_SECRET throws clear error with solution
   - Short JWT_SECRET (< 32 chars) throws clear error with generation command
   - Secret fingerprint logged for verification

3. **Applications operational:**
   - Backend starts and logs JWT configuration
   - Frontend starts and logs JWT validation
   - Secret lengths match between backend and frontend
   - No JWT-related errors in logs

4. **Security hardened:**
   - Fallback secrets removed from codebase
   - 512-bit cryptographically secure secret in use
   - Validation prevents weak or missing secrets

**Ready for Plan 02:** WebSocket authentication should now succeed, enabling Phase 3 real-time features testing.
</success_criteria>

<output>
After completion, create `.planning/phases/06-authentication-fixes/06-01-SUMMARY.md` documenting:
- New JWT_SECRET generation and deployment
- Fail-fast validation implementation
- Secret fingerprint verification results
- Any issues encountered during startup verification
- Readiness for Plan 02 WebSocket integration testing
</output>
