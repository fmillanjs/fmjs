---
phase: 16-workspaces-membership-rbac
plan: "02"
type: execute
wave: 2
depends_on:
  - "16-01"
files_modified:
  - apps/devcollab-api/src/workspaces/workspace-ability.factory.ts
  - apps/devcollab-api/src/workspaces/workspaces.module.ts
  - apps/devcollab-api/src/guards/casl-auth.guard.ts
  - apps/devcollab-api/src/app.module.ts
autonomous: true
requirements:
  - RBAC-01
  - RBAC-02
  - RBAC-03
  - RBAC-04

must_haves:
  truths:
    - "An Admin user on a workspace endpoint receives 200 for manage operations"
    - "A Viewer user on a create endpoint receives 403 ForbiddenException"
    - "A Contributor user receives 200 for create operations and 403 for manage-workspace operations"
    - "Endpoints without a :slug param bypass the ability factory and pass through with @CheckAbility present"
    - "RBAC-04 deny-by-default invariant is still enforced (ForbiddenException without @CheckAbility)"
  artifacts:
    - path: "apps/devcollab-api/src/workspaces/workspace-ability.factory.ts"
      provides: "WorkspaceAbilityFactory: loads membership role from DB, builds CASL ability"
      exports: ["WorkspaceAbilityFactory", "AppAbility"]
    - path: "apps/devcollab-api/src/workspaces/workspaces.module.ts"
      provides: "WorkspacesModule skeleton — imports DatabaseModule, provides and exports WorkspaceAbilityFactory"
      exports: ["WorkspacesModule"]
    - path: "apps/devcollab-api/src/guards/casl-auth.guard.ts"
      provides: "Upgraded async CaslAuthGuard with workspace-scoped ability evaluation"
      exports: ["CaslAuthGuard"]
    - path: "apps/devcollab-api/src/app.module.ts"
      provides: "AppModule importing WorkspacesModule so guard can inject WorkspaceAbilityFactory"
  key_links:
    - from: "apps/devcollab-api/src/guards/casl-auth.guard.ts"
      to: "apps/devcollab-api/src/workspaces/workspace-ability.factory.ts"
      via: "constructor injection"
      pattern: "WorkspaceAbilityFactory"
    - from: "apps/devcollab-api/src/workspaces/workspaces.module.ts"
      to: "apps/devcollab-api/src/core/database/database.module.ts"
      via: "imports: [DatabaseModule]"
      pattern: "DatabaseModule"
    - from: "apps/devcollab-api/src/app.module.ts"
      to: "apps/devcollab-api/src/workspaces/workspaces.module.ts"
      via: "imports: [WorkspacesModule]"
      pattern: "WorkspacesModule"
---

<objective>
Build the CASL workspace ability factory, create the WorkspacesModule skeleton (with factory exported), upgrade CaslAuthGuard to async with workspace-scoped permission evaluation, and wire everything into AppModule.

Purpose: RBAC enforcement at the API guard level — not just presence of @CheckAbility, but actual ability.can() evaluation using the user's workspace membership role. This is the security core of Phase 16.

Output: WorkspaceAbilityFactory (CASL rules per role), WorkspacesModule (skeleton, no controller yet), upgraded async CaslAuthGuard, AppModule importing WorkspacesModule.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-workspaces-membership-rbac/16-RESEARCH.md
@.planning/phases/16-workspaces-membership-rbac/16-01-SUMMARY.md
@apps/devcollab-api/src/guards/casl-auth.guard.ts
@apps/devcollab-api/src/app.module.ts
@apps/devcollab-api/src/common/decorators/check-ability.decorator.ts
@apps/devcollab-api/src/common/decorators/public.decorator.ts
@apps/devcollab-api/src/core/database/database.module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkspaceAbilityFactory and WorkspacesModule skeleton</name>
  <files>
    apps/devcollab-api/src/workspaces/workspace-ability.factory.ts
    apps/devcollab-api/src/workspaces/workspaces.module.ts
  </files>
  <action>
Create `apps/devcollab-api/src/workspaces/workspace-ability.factory.ts`:

```typescript
import { Injectable } from '@nestjs/common';
import { AbilityBuilder, createMongoAbility, MongoAbility } from '@casl/ability';
import { PrismaService } from '../core/database/prisma.service';

export type Action = 'create' | 'read' | 'update' | 'delete' | 'manage';
export type Subject =
  | 'Workspace'
  | 'WorkspaceMember'
  | 'InviteLink'
  | 'Post'
  | 'Snippet'
  | 'Comment'
  | 'all';

export type AppAbility = MongoAbility<[Action, Subject]>;

@Injectable()
export class WorkspaceAbilityFactory {
  constructor(private readonly prisma: PrismaService) {}

  async createForUserInWorkspace(
    userId: string,
    workspaceSlug: string,
  ): Promise<AppAbility | null> {
    const workspace = await this.prisma.workspace.findUnique({
      where: { slug: workspaceSlug },
      select: { id: true },
    });

    if (!workspace) return null;

    const membership = await this.prisma.workspaceMember.findUnique({
      where: {
        userId_workspaceId: { userId, workspaceId: workspace.id },
      },
      select: { role: true },
    });

    if (!membership) return null;

    const { can, cannot, build } = new AbilityBuilder<AppAbility>(createMongoAbility);

    if (membership.role === 'Admin') {
      can('manage', 'all');
    } else if (membership.role === 'Contributor') {
      can('read', 'all');
      can('create', 'Post');
      can('create', 'Snippet');
      can('create', 'Comment');
      can('update', 'Post');
      can('update', 'Snippet');
      can('update', 'Comment');
      cannot('manage', 'Workspace');
      cannot('manage', 'WorkspaceMember');
      cannot('create', 'InviteLink');
    } else if (membership.role === 'Viewer') {
      can('read', 'all');
      cannot('create', 'all');
      cannot('update', 'all');
      cannot('delete', 'all');
    } else {
      cannot('manage', 'all');
    }

    return build();
  }
}
```

Create `apps/devcollab-api/src/workspaces/workspaces.module.ts` (skeleton — controller added in Plan 03):

```typescript
import { Module } from '@nestjs/common';
import { DatabaseModule } from '../core/database/database.module';
import { WorkspaceAbilityFactory } from './workspace-ability.factory';

@Module({
  imports: [DatabaseModule],
  providers: [WorkspaceAbilityFactory],
  exports: [WorkspaceAbilityFactory],
})
export class WorkspacesModule {}
```

Note: WorkspacesController and WorkspacesService are added in Plan 03. The module skeleton is exported now so AppModule can import it and the guard can inject WorkspaceAbilityFactory.
  </action>
  <verify>
Run: `npx tsc --noEmit -p /home/doctor/fernandomillan/apps/devcollab-api/tsconfig.json`
Expected: No TypeScript errors related to the new files.
  </verify>
  <done>
workspace-ability.factory.ts exists with WorkspaceAbilityFactory injectable class. workspaces.module.ts exists exporting WorkspaceAbilityFactory. TypeScript compilation exits 0.
  </done>
</task>

<task type="auto">
  <name>Task 2: Upgrade CaslAuthGuard to async with workspace ability evaluation</name>
  <files>apps/devcollab-api/src/guards/casl-auth.guard.ts</files>
  <action>
Replace the contents of `apps/devcollab-api/src/guards/casl-auth.guard.ts` with the async-upgraded version:

```typescript
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
  ForbiddenException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { JwtService } from '@nestjs/jwt';
import { IS_PUBLIC_KEY } from '../common/decorators/public.decorator';
import { CHECK_ABILITY_KEY } from '../common/decorators/check-ability.decorator';
import { WorkspaceAbilityFactory, Action, Subject } from '../workspaces/workspace-ability.factory';

@Injectable()
export class CaslAuthGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private jwtService: JwtService,
    private workspaceAbilityFactory: WorkspaceAbilityFactory,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) return true;

    const request = context.switchToHttp().getRequest();
    const token = request.cookies?.['devcollab_token'];

    if (!token) {
      throw new UnauthorizedException('No authentication token');
    }

    let payload: { sub: string; email: string };
    try {
      payload = this.jwtService.verify(token);
    } catch {
      throw new UnauthorizedException('Invalid or expired token');
    }

    request.user = payload;

    // Deny-by-default: every non-public endpoint must declare @CheckAbility
    const abilityReq = this.reflector.getAllAndOverride<{ action: string; subject: string }>(
      CHECK_ABILITY_KEY,
      [context.getHandler(), context.getClass()],
    );

    if (!abilityReq) {
      throw new ForbiddenException(
        'Endpoint must declare @CheckAbility — deny-by-default security invariant',
      );
    }

    // Workspace-agnostic routes (no :slug param): authenticated + @CheckAbility is sufficient.
    // The service layer handles further workspace-scoped authorization.
    const workspaceSlug: string | undefined = request.params?.slug;
    if (!workspaceSlug) return true;

    // Workspace-scoped route: build ability from user's membership role and evaluate
    const ability = await this.workspaceAbilityFactory.createForUserInWorkspace(
      payload.sub,
      workspaceSlug,
    );

    if (!ability) {
      throw new ForbiddenException('Not a member of this workspace');
    }

    const allowed = ability.can(abilityReq.action as Action, abilityReq.subject as Subject);
    if (!allowed) {
      throw new ForbiddenException(
        `Forbidden: cannot ${abilityReq.action} ${abilityReq.subject} in this workspace`,
      );
    }

    return true;
  }
}
```

Key changes from Phase 15 guard:
- `canActivate` is now `async` and returns `Promise<boolean>`
- Injects `WorkspaceAbilityFactory` as third constructor parameter
- After @CheckAbility check, extracts `request.params?.slug`
- If slug present: loads ability from factory and calls `ability.can()`
- If slug absent: returns true (workspace-agnostic, service handles authz)
  </action>
  <verify>
Run: `npx tsc --noEmit -p /home/doctor/fernandomillan/apps/devcollab-api/tsconfig.json`
Expected: No TypeScript errors.
  </verify>
  <done>
casl-auth.guard.ts is async, injects WorkspaceAbilityFactory, evaluates ability.can() for workspace-scoped routes. TypeScript exits 0.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire WorkspacesModule into AppModule</name>
  <files>apps/devcollab-api/src/app.module.ts</files>
  <action>
Update `apps/devcollab-api/src/app.module.ts` to import WorkspacesModule. The guard (APP_GUARD) injects WorkspaceAbilityFactory, which is provided and exported by WorkspacesModule. Importing WorkspacesModule at AppModule level makes WorkspaceAbilityFactory available to the guard.

Add import statement: `import { WorkspacesModule } from './workspaces/workspaces.module';`

Add `WorkspacesModule` to the `imports` array after `AuthModule`:

```typescript
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { ConfigModule } from '@nestjs/config';
import { JwtModule } from '@nestjs/jwt';
import { CaslAuthGuard } from './guards/casl-auth.guard';
import { HealthModule } from './health/health.module';
import { DatabaseModule } from './core/database/database.module';
import { AuthModule } from './auth/auth.module';
import { WorkspacesModule } from './workspaces/workspaces.module';

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    JwtModule.registerAsync({
      global: true,
      useFactory: () => ({
        secret: process.env.DEVCOLLAB_JWT_SECRET || 'devcollab-dev-secret',
        signOptions: { expiresIn: '7d', algorithm: 'HS256' },
        verifyOptions: { algorithms: ['HS256'] },
      }),
    }),
    DatabaseModule,
    HealthModule,
    AuthModule,
    WorkspacesModule,
  ],
  providers: [
    {
      provide: APP_GUARD,
      useClass: CaslAuthGuard,
    },
  ],
})
export class AppModule {}
```

No circular dependency: WorkspacesModule imports DatabaseModule (not AppModule). AppModule imports WorkspacesModule. One-directional dependency chain.
  </action>
  <verify>
Run: `npx tsc --noEmit -p /home/doctor/fernandomillan/apps/devcollab-api/tsconfig.json`
Expected: Zero TypeScript errors.

Also verify the guard still runs the meta-test:
`cd /home/doctor/fernandomillan/apps/devcollab-api && npx vitest run test/unit/meta/controller-coverage.spec.ts 2>&1 | tail -5`
Expected: All tests pass (guard change is backward-compatible — no new controllers yet).
  </verify>
  <done>
AppModule imports WorkspacesModule. TypeScript exits 0. Vitest meta-test still passes (existing controllers unaffected by guard upgrade).
  </done>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit -p apps/devcollab-api/tsconfig.json` exits 0
2. Files exist: `ls apps/devcollab-api/src/workspaces/` shows workspace-ability.factory.ts and workspaces.module.ts
3. Guard is async: `grep "async canActivate" apps/devcollab-api/src/guards/casl-auth.guard.ts`
4. AppModule imports WorkspacesModule: `grep "WorkspacesModule" apps/devcollab-api/src/app.module.ts`
5. Meta-test passes: `cd apps/devcollab-api && npx vitest run test/unit/meta/controller-coverage.spec.ts`
</verification>

<success_criteria>
- WorkspaceAbilityFactory exists with Admin/Contributor/Viewer CASL rules
- WorkspacesModule skeleton exports WorkspaceAbilityFactory
- CaslAuthGuard is async, injects WorkspaceAbilityFactory, checks ability.can() for :slug routes
- AppModule imports WorkspacesModule
- TypeScript compilation exits 0
- Existing meta-test (controller-coverage) still passes
</success_criteria>

<output>
After completion, create `.planning/phases/16-workspaces-membership-rbac/16-02-SUMMARY.md`
</output>
