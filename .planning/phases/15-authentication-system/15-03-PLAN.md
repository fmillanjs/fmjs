---
phase: 15-authentication-system
plan: 03
type: execute
wave: 2
depends_on:
  - 15-01
  - 15-02
files_modified:
  - apps/devcollab-api/src/app.module.ts
  - apps/devcollab-api/src/core/database/database.module.ts
  - apps/devcollab-api/src/core/database/prisma.service.ts
  - apps/devcollab-api/src/auth/auth.module.ts
  - apps/devcollab-api/src/auth/auth.controller.ts
  - apps/devcollab-api/src/auth/auth.service.ts
  - apps/devcollab-api/src/auth/strategies/jwt.strategy.ts
  - apps/devcollab-api/src/auth/dto/signup.dto.ts
  - apps/devcollab-api/src/auth/dto/login.dto.ts
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04

must_haves:
  truths:
    - "POST /auth/signup with valid email+password creates a user with bcrypt-hashed password and returns a devcollab_token httpOnly cookie"
    - "POST /auth/login with correct credentials returns a devcollab_token httpOnly cookie and user object"
    - "POST /auth/logout clears the devcollab_token cookie"
    - "GET /auth/me with a valid cookie returns the current user; without cookie returns 401"
    - "devcollab-api boots without DI errors (JwtModule global: true resolves CaslAuthGuard dependency)"
    - "AuthService.signup rejects duplicate emails with 409 ConflictException"
    - "AuthService.login rejects wrong password with 401 UnauthorizedException"
  artifacts:
    - path: "apps/devcollab-api/src/core/database/prisma.service.ts"
      provides: "NestJS PrismaService wrapping @devcollab/database singleton"
      contains: "PrismaService"
    - path: "apps/devcollab-api/src/auth/auth.controller.ts"
      provides: "POST /auth/signup, /auth/login, /auth/logout, GET /auth/me endpoints"
      contains: "AuthController"
    - path: "apps/devcollab-api/src/auth/auth.service.ts"
      provides: "signup and login business logic with bcrypt"
      contains: "AuthService"
    - path: "apps/devcollab-api/src/auth/strategies/jwt.strategy.ts"
      provides: "Passport JWT strategy reading from devcollab_token cookie"
      contains: "JwtStrategy"
    - path: "apps/devcollab-api/src/app.module.ts"
      provides: "AppModule with JwtModule global: true, ConfigModule, DatabaseModule, AuthModule"
      contains: "JwtModule"
  key_links:
    - from: "apps/devcollab-api/src/auth/auth.service.ts"
      to: "apps/devcollab-api/src/core/database/prisma.service.ts"
      via: "PrismaService injection via constructor"
      pattern: "prisma\\.user\\.(findUnique|create)"
    - from: "apps/devcollab-api/src/auth/auth.controller.ts"
      to: "apps/devcollab-api/src/auth/auth.service.ts"
      via: "AuthService injection, @Res({ passthrough: true }) cookie setting"
      pattern: "passthrough: true"
    - from: "apps/devcollab-api/src/app.module.ts"
      to: "apps/devcollab-api/src/guards/casl-auth.guard.ts"
      via: "JwtModule global: true makes JwtService available to APP_GUARD"
      pattern: "global: true"
---

<objective>
Build the complete DevCollab auth feature: DatabaseModule with PrismaService, AuthModule with signup/login/logout/me endpoints, JwtStrategy, DTOs, and the updated AppModule wiring everything together.

Purpose: This plan delivers the four auth requirements in a single cohesive feature. Depends on Plan 01 (password column in DB) and Plan 02 (decorators + upgraded guard). When this plan completes, the auth flow is end-to-end functional at the API level.
Output: A running devcollab-api that supports full signup → login → session → logout flows using httpOnly JWT cookies.
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-authentication-system/15-RESEARCH.md
@.planning/phases/15-authentication-system/15-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DatabaseModule + PrismaService and update AppModule with JwtModule + AuthModule</name>
  <files>
    apps/devcollab-api/src/core/database/database.module.ts
    apps/devcollab-api/src/core/database/prisma.service.ts
    apps/devcollab-api/src/app.module.ts
  </files>
  <action>
    **File 1: `apps/devcollab-api/src/core/database/prisma.service.ts`** — Create new file:
    ```typescript
    import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
    import { prisma } from '@devcollab/database';

    @Injectable()
    export class PrismaService implements OnModuleInit, OnModuleDestroy {
      private client = prisma;

      async onModuleInit() {
        await this.client.$connect();
      }

      async onModuleDestroy() {
        await this.client.$disconnect();
      }

      get user() {
        return this.client.user;
      }
    }
    ```

    Note: This wraps the `@devcollab/database` singleton (`export const prisma` from packages/devcollab-database/src/client.ts) in a NestJS injectable. The `get user()` accessor delegates queries to the Prisma client. This pattern allows `AuthService` to be tested by mocking `PrismaService`.

    **File 2: `apps/devcollab-api/src/core/database/database.module.ts`** — Create new file:
    ```typescript
    import { Module } from '@nestjs/common';
    import { PrismaService } from './prisma.service';

    @Module({
      providers: [PrismaService],
      exports: [PrismaService],
    })
    export class DatabaseModule {}
    ```

    **File 3: `apps/devcollab-api/src/app.module.ts`** — Replace entirely:
    ```typescript
    import { Module } from '@nestjs/common';
    import { APP_GUARD } from '@nestjs/core';
    import { ConfigModule } from '@nestjs/config';
    import { JwtModule } from '@nestjs/jwt';
    import { CaslAuthGuard } from './guards/casl-auth.guard';
    import { HealthModule } from './health/health.module';
    import { DatabaseModule } from './core/database/database.module';
    import { AuthModule } from './auth/auth.module';

    @Module({
      imports: [
        ConfigModule.forRoot({ isGlobal: true }),
        JwtModule.registerAsync({
          global: true,
          useFactory: () => ({
            secret: process.env.DEVCOLLAB_JWT_SECRET || 'devcollab-dev-secret',
            signOptions: { expiresIn: '7d', algorithm: 'HS256' },
            verifyOptions: { algorithms: ['HS256'] },
          }),
        }),
        DatabaseModule,
        HealthModule,
        AuthModule,
      ],
      providers: [
        {
          provide: APP_GUARD,
          useClass: CaslAuthGuard,
        },
      ],
    })
    export class AppModule {}
    ```

    CRITICAL: `global: true` in `JwtModule.registerAsync` makes `JwtService` available throughout the entire DI context, including the `CaslAuthGuard` registered as `APP_GUARD`. Without `global: true`, NestJS throws a dependency injection error on startup for `CaslAuthGuard`.

    The `useFactory` reads `process.env.DEVCOLLAB_JWT_SECRET` directly (ConfigModule is available because it's declared before JwtModule in imports array and is isGlobal: true).
  </action>
  <verify>
    1. `ls apps/devcollab-api/src/core/database/` shows `database.module.ts` and `prisma.service.ts`.
    2. `grep "global: true" apps/devcollab-api/src/app.module.ts` — shows JwtModule global registration.
    3. `grep "DatabaseModule" apps/devcollab-api/src/app.module.ts` — shows import.
    4. `grep "AuthModule" apps/devcollab-api/src/app.module.ts` — shows import.
    5. `grep "PrismaService" apps/devcollab-api/src/core/database/prisma.service.ts` — shows class definition.
  </verify>
  <done>DatabaseModule and PrismaService created; AppModule updated with JwtModule (global), ConfigModule, DatabaseModule, AuthModule; CaslAuthGuard dependency injection will resolve at startup.</done>
</task>

<task type="auto">
  <name>Task 2: Create AuthModule with DTOs, JwtStrategy, AuthService, and AuthController</name>
  <files>
    apps/devcollab-api/src/auth/dto/signup.dto.ts
    apps/devcollab-api/src/auth/dto/login.dto.ts
    apps/devcollab-api/src/auth/strategies/jwt.strategy.ts
    apps/devcollab-api/src/auth/auth.service.ts
    apps/devcollab-api/src/auth/auth.controller.ts
    apps/devcollab-api/src/auth/auth.module.ts
  </files>
  <action>
    Create files in this order (later files depend on earlier ones):

    **File 1: `apps/devcollab-api/src/auth/dto/signup.dto.ts`**:
    ```typescript
    export class SignupDto {
      email!: string;
      password!: string;
      name?: string;
    }
    ```

    **File 2: `apps/devcollab-api/src/auth/dto/login.dto.ts`**:
    ```typescript
    export class LoginDto {
      email!: string;
      password!: string;
    }
    ```

    No class-validator decorators for now — plain DTO classes keep this plan focused on auth logic. Validation can be added in Phase 16 when a global ValidationPipe is set up.

    **File 3: `apps/devcollab-api/src/auth/strategies/jwt.strategy.ts`**:
    ```typescript
    import { ExtractJwt, Strategy } from 'passport-jwt';
    import { PassportStrategy } from '@nestjs/passport';
    import { Injectable, UnauthorizedException } from '@nestjs/common';
    import { ConfigService } from '@nestjs/config';
    import { Request as RequestType } from 'express';

    export interface JwtPayload {
      sub: string;
      email: string;
    }

    @Injectable()
    export class JwtStrategy extends PassportStrategy(Strategy, 'jwt-devcollab') {
      constructor(private readonly configService: ConfigService) {
        super({
          jwtFromRequest: ExtractJwt.fromExtractors([
            (req: RequestType): string | null => {
              if (req?.cookies?.['devcollab_token']) {
                return req.cookies['devcollab_token'] as string;
              }
              return null;
            },
          ]),
          ignoreExpiration: false,
          secretOrKey: configService.getOrThrow<string>('DEVCOLLAB_JWT_SECRET'),
        });
      }

      validate(payload: JwtPayload): { id: string; email: string } {
        if (!payload?.sub) {
          throw new UnauthorizedException('Invalid token payload');
        }
        return { id: payload.sub, email: payload.email };
      }
    }
    ```

    **File 4: `apps/devcollab-api/src/auth/auth.service.ts`**:
    ```typescript
    import {
      Injectable,
      UnauthorizedException,
      ConflictException,
    } from '@nestjs/common';
    import { JwtService } from '@nestjs/jwt';
    import * as bcrypt from 'bcrypt';
    import { PrismaService } from '../core/database/prisma.service';
    import { SignupDto } from './dto/signup.dto';
    import { LoginDto } from './dto/login.dto';

    interface SafeUser {
      id: string;
      email: string;
      name: string | null;
    }

    @Injectable()
    export class AuthService {
      constructor(
        private readonly prisma: PrismaService,
        private readonly jwtService: JwtService,
      ) {}

      async signup(dto: SignupDto): Promise<{ user: SafeUser; token: string }> {
        const existing = await this.prisma.user.findUnique({
          where: { email: dto.email.toLowerCase() },
        });
        if (existing) {
          throw new ConflictException('Email already registered');
        }

        const hashedPassword = await bcrypt.hash(dto.password, 12);
        const user = await this.prisma.user.create({
          data: {
            email: dto.email.toLowerCase(),
            name: dto.name ?? null,
            password: hashedPassword,
          },
        });

        const token = this.jwtService.sign({ sub: user.id, email: user.email });
        return {
          user: { id: user.id, email: user.email, name: user.name },
          token,
        };
      }

      async login(dto: LoginDto): Promise<{ user: SafeUser; token: string }> {
        const user = await this.prisma.user.findUnique({
          where: { email: dto.email.toLowerCase() },
        });
        if (!user || !user.password) {
          throw new UnauthorizedException('Invalid credentials');
        }

        const valid = await bcrypt.compare(dto.password, user.password);
        if (!valid) {
          throw new UnauthorizedException('Invalid credentials');
        }

        const token = this.jwtService.sign({ sub: user.id, email: user.email });
        return {
          user: { id: user.id, email: user.email, name: user.name },
          token,
        };
      }
    }
    ```

    **File 5: `apps/devcollab-api/src/auth/auth.controller.ts`**:
    ```typescript
    import {
      Controller,
      Post,
      Get,
      Body,
      Res,
      HttpCode,
      HttpStatus,
    } from '@nestjs/common';
    import { Response } from 'express';
    import { AuthService } from './auth.service';
    import { Public } from '../common/decorators/public.decorator';
    import { CurrentUser } from '../common/decorators/current-user.decorator';
    import { CheckAbility } from '../common/decorators/check-ability.decorator';
    import { SignupDto } from './dto/signup.dto';
    import { LoginDto } from './dto/login.dto';

    @Controller('auth')
    export class AuthController {
      constructor(private readonly authService: AuthService) {}

      @Public()
      @Post('signup')
      async signup(
        @Body() dto: SignupDto,
        @Res({ passthrough: true }) res: Response,
      ) {
        const { user, token } = await this.authService.signup(dto);
        this.setAuthCookie(res, token);
        return { user };
      }

      @Public()
      @Post('login')
      @HttpCode(HttpStatus.OK)
      async login(
        @Body() dto: LoginDto,
        @Res({ passthrough: true }) res: Response,
      ) {
        const { user, token } = await this.authService.login(dto);
        this.setAuthCookie(res, token);
        return { user };
      }

      @Public()
      @Post('logout')
      @HttpCode(HttpStatus.OK)
      logout(@Res({ passthrough: true }) res: Response) {
        res.clearCookie('devcollab_token', { httpOnly: true, sameSite: 'strict' });
        return { message: 'Logged out' };
      }

      @CheckAbility('read', 'User')
      @Get('me')
      me(@CurrentUser() user: { sub: string; email: string }) {
        return { user };
      }

      private setAuthCookie(res: Response, token: string): void {
        res.cookie('devcollab_token', token, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
          maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
        });
      }
    }
    ```

    CRITICAL: All of signup, login, logout are decorated with `@Public()` — these are the routes users call to GET their JWT, so the guard must not block them. The `me` endpoint uses `@CheckAbility('read', 'User')` — this is the first non-public protected endpoint and validates the full guard logic end-to-end.

    CRITICAL: `@Res({ passthrough: true })` NOT `@Res()` — without `passthrough: true`, NestJS stops managing the response lifecycle and the return value `{ user }` is ignored.

    **File 6: `apps/devcollab-api/src/auth/auth.module.ts`**:
    ```typescript
    import { Module } from '@nestjs/common';
    import { PassportModule } from '@nestjs/passport';
    import { AuthController } from './auth.controller';
    import { AuthService } from './auth.service';
    import { JwtStrategy } from './strategies/jwt.strategy';
    import { DatabaseModule } from '../core/database/database.module';

    @Module({
      imports: [PassportModule, DatabaseModule],
      controllers: [AuthController],
      providers: [AuthService, JwtStrategy],
    })
    export class AuthModule {}
    ```

    Note: `JwtModule` is NOT imported here — it's registered globally in `AppModule`. `PassportModule` is needed for `PassportStrategy` to work. `DatabaseModule` is imported to provide `PrismaService`.
  </action>
  <verify>
    1. `ls apps/devcollab-api/src/auth/` shows: auth.controller.ts, auth.module.ts, auth.service.ts, dto/, strategies/.
    2. `ls apps/devcollab-api/src/auth/dto/` shows: signup.dto.ts, login.dto.ts.
    3. `ls apps/devcollab-api/src/auth/strategies/` shows: jwt.strategy.ts.
    4. `grep "passthrough: true" apps/devcollab-api/src/auth/auth.controller.ts` — confirms cookie response pattern.
    5. `grep "@Public()" apps/devcollab-api/src/auth/auth.controller.ts` — shows 3 matches (signup, login, logout).
    6. `grep "@CheckAbility" apps/devcollab-api/src/auth/auth.controller.ts` — shows 1 match (me endpoint).
    7. `grep "bcrypt.hash" apps/devcollab-api/src/auth/auth.service.ts` — confirms password hashing.
    8. `grep "ConflictException" apps/devcollab-api/src/auth/auth.service.ts` — confirms duplicate email check.
    9. Build verification: `cd apps/devcollab-api && npx nest build` (or equivalent TypeScript check) — no compilation errors.
  </verify>
  <done>AuthModule complete with signup/login/logout/me endpoints; bcrypt password hashing; httpOnly cookie set/cleared; @Public() on all auth entry points; @CheckAbility('read','User') on /auth/me; devcollab-api builds without TypeScript errors.</done>
</task>

</tasks>

<verification>
After both tasks, perform these end-to-end checks if devcollab-postgres is running:

1. Start API: confirm no DI injection errors in startup log
2. `curl -s http://localhost:3003/health` → `{"status":"ok"}` (confirms guard still passes @Public)
3. `curl -s -X POST http://localhost:3003/auth/signup -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"Test123!"}' -c /tmp/cookies.txt` → 201 with `{"user":{...}}` and Set-Cookie: devcollab_token
4. `curl -s -X POST http://localhost:3003/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"Test123!"}' -c /tmp/cookies.txt` → 200 with `{"user":{...}}`
5. `curl -s http://localhost:3003/auth/me -b /tmp/cookies.txt` → 200 with user data (confirms @CheckAbility guard works)
6. `curl -s http://localhost:3003/auth/me` (no cookie) → 401
7. `curl -s -X POST http://localhost:3003/auth/logout -b /tmp/cookies.txt` → 200 with `{"message":"Logged out"}`

If database is not running, verify by TypeScript compilation only (no DI errors means all imports resolve correctly).
</verification>

<success_criteria>
- `apps/devcollab-api/src/core/database/` has database.module.ts and prisma.service.ts
- `apps/devcollab-api/src/auth/` has auth.module.ts, auth.controller.ts, auth.service.ts, dto/signup.dto.ts, dto/login.dto.ts, strategies/jwt.strategy.ts
- `apps/devcollab-api/src/app.module.ts` imports JwtModule (global: true), ConfigModule, DatabaseModule, AuthModule
- POST /auth/signup creates user with hashed password and returns httpOnly cookie
- POST /auth/login validates bcrypt hash and returns httpOnly cookie
- POST /auth/logout clears cookie
- GET /auth/me returns user data when valid cookie present, 401 when absent
- devcollab-api TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/15-authentication-system/15-03-SUMMARY.md`
</output>
