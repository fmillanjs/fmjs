---
phase: 07.1-phase-3-gap-closure-real-time-collaboration-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/modules/events/events.gateway.ts
  - apps/web/hooks/use-real-time-tasks.ts
  - apps/web/hooks/use-real-time-comments.ts
  - apps/web/hooks/use-project-presence.ts
autonomous: false
gap_closure: true

must_haves:
  truths:
    - "User sees live task creation updates when another user creates a task (Test 2)"
    - "User sees live comment updates when another user adds a comment (Test 5)"
    - "User sees presence indicators showing active viewers on project page (Test 6)"
    - "Redis pub/sub distributes WebSocket events correctly across sessions"
  artifacts:
    - path: "apps/api/src/modules/events/events.gateway.ts"
      provides: "Redis adapter enabled with async initialization"
      contains: "server.adapter(createAdapter(pubClient, subClient))"
      min_lines: 350
    - path: "apps/web/hooks/use-real-time-tasks.ts"
      provides: "Task event listeners with debugging logs"
      contains: "console.log('[Real-time]"
      min_lines: 50
  key_links:
    - from: "apps/api/src/modules/events/events.gateway.ts"
      to: "Redis pub/sub"
      via: "createAdapter(pubClient, subClient)"
      pattern: "server\\.adapter\\(createAdapter"
    - from: "apps/api/src/modules/events/listeners/task.listener.ts"
      to: "WebSocket rooms"
      via: "server.to(room).emit()"
      pattern: "server\\.to\\(.*\\)\\.emit"
---

<objective>
Re-enable Redis adapter and add comprehensive WebSocket debugging to fix session isolation preventing multi-user real-time collaboration

Purpose: Tests 2, 5, 6, 7 fail because Redis adapter is disabled (line 36-40 of events.gateway.ts). Without Redis adapter, WebSocket events cannot broadcast across different sessions even on single server. This CRITICAL gap blocks all multi-user real-time features.

Output: Redis adapter operational with async initialization, comprehensive debugging logs to verify room join and event flow, all cross-session real-time features functional
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-phase-3-verification/07-VERIFICATION.md
@.planning/phases/07.1-phase-3-gap-closure-real-time-collaboration-fixes/07.1-RESEARCH.md
@apps/api/src/modules/events/events.gateway.ts
@apps/web/hooks/use-real-time-tasks.ts
@apps/web/hooks/use-real-time-comments.ts
@apps/web/hooks/use-project-presence.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Re-enable Redis adapter with async initialization</name>
  <files>apps/api/src/modules/events/events.gateway.ts</files>
  <action>
Re-enable the Redis adapter in afterInit() method (lines 36-40 are currently commented out).

Implementation:
1. Uncomment Redis client creation lines
2. Add async connection waiting before setting adapter (CRITICAL - adapter breaks if set before Redis clients connect)
3. Add error handling for Redis connection failures
4. Update console log to confirm Redis adapter is enabled

Pattern (from research):
```typescript
async afterInit(server: Server) {
  const pubClient = new Redis(process.env.REDIS_URL || 'redis://localhost:6380');
  const subClient = pubClient.duplicate();

  // CRITICAL: Wait for both clients to connect before setting adapter
  await Promise.all([
    new Promise(resolve => pubClient.on('connect', resolve)),
    new Promise(resolve => subClient.on('connect', resolve))
  ]);

  server.adapter(createAdapter(pubClient, subClient));
  console.log('WebSocket server initialized with Redis adapter enabled');
}
```

Why: Research finding "Redis adapter is DISABLED in events.gateway.ts (line 36-40), which means events only broadcast within a single server instance. Without Redis adapter, WebSocket events cannot broadcast across sessions even on a single server." This is the root cause of 80% of verification failures.

DO NOT change any other WebSocket logic in this task - only uncomment and fix the Redis adapter initialization.
  </action>
  <verify>
1. Start API server: `cd apps/api && npm run dev`
2. Check logs for "WebSocket server initialized with Redis adapter enabled"
3. Monitor Redis: `docker exec -it redis redis-cli CLIENT LIST` - should show 2 connections from API server
4. Create task in browser Tab A, verify Redis activity: `docker exec -it redis redis-cli MONITOR` shows PUBLISH commands
  </verify>
  <done>
- Redis adapter enabled in afterInit() with proper async initialization
- Server logs confirm "Redis adapter enabled"
- Redis CLI shows 2 client connections (pub + sub)
- Redis MONITOR shows PUBLISH commands when WebSocket events fire
  </done>
</task>

<task type="auto">
  <name>Task 2: Add WebSocket debugging logs to verify room join and event flow</name>
  <files>
    apps/api/src/modules/events/events.gateway.ts
    apps/web/hooks/use-real-time-tasks.ts
    apps/web/hooks/use-real-time-comments.ts
    apps/web/hooks/use-project-presence.ts
  </files>
  <action>
Add comprehensive debugging logs to trace WebSocket event flow from server broadcast to client receipt.

Server-side (events.gateway.ts):
1. In handleJoinProject handler (~line 140), after client.join(roomName):
   - Log room join confirmation: `console.log('[Room] Client ${client.id} (user: ${userId}) joined ${roomName}')`
   - Log all rooms client is in: `console.log('[Room] Client rooms:', Array.from(client.rooms))`
   - Use fetchSockets() to verify room membership: `const sockets = await this.server.in(roomName).fetchSockets(); console.log('[Room] Total sockets in ${roomName}:', sockets.length)`
   - Return socket count in response: `return { event: 'joined', data: { projectId, room: roomName, socketCount: sockets.length } }`

2. In handlePresenceRequest handler (~line 170):
   - Add log before fetchSockets: `console.log('[Presence] Request for room:', roomName)`
   - Log results: `console.log('[Presence] Found ${sockets.length} sockets in ${roomName}')`

Client-side (hooks):
1. use-real-time-tasks.ts - Add logs in event handlers:
   - task:created: `console.log('[Real-time Tasks] Received task:created:', payload.task.id, 'from user:', payload.userId)`
   - task:updated: `console.log('[Real-time Tasks] Received task:updated:', payload.task.id, 'self-update:', payload.userId === currentUserId)`

2. use-real-time-comments.ts - Add logs in event handlers:
   - comment:created: `console.log('[Real-time Comments] Received comment:created:', payload.comment.id, 'from user:', payload.userId)`

3. use-project-presence.ts - Add logs:
   - presence:join: `console.log('[Presence] User joined:', payload.user.name)`
   - presence:update: `console.log('[Presence] Active users count:', payload.users.length)`

Why: Research recommendation "WebSocket debugging requires systematic verification (connection → authentication → room join → event broadcast → client receipt)". These logs will immediately reveal if Tab B (incognito) joins rooms correctly and receives events.

IMPORTANT: These are temporary debugging logs. Mark with [DEBUG] prefix for easy removal later.
  </action>
  <verify>
1. Start dev servers: `npm run dev` (monorepo root)
2. Open browser Tab A (normal), navigate to project board
3. Open console - verify logs show "[Room] Client joined project:..." and socket count
4. Open incognito Tab B, log in as different user, navigate to same project
5. Verify Tab B console shows room join with socketCount=2
6. Create task in Tab A - verify Tab B console shows "[Real-time Tasks] Received task:created"
7. Add comment in Tab A - verify Tab B console shows "[Real-time Comments] Received comment:created"
8. Verify presence indicators update in both tabs
  </verify>
  <done>
- Server logs show room join confirmations with socket counts
- Client consoles show real-time event receipt with userId filtering
- Cross-session testing (Tab A → Tab B) shows event propagation in console logs
- Debugging logs provide visibility into WebSocket event flow for troubleshooting
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Redis adapter re-enabled with async initialization and comprehensive WebSocket debugging logs across server and client. This addresses the CRITICAL session isolation gap preventing multi-user real-time collaboration.
  </what-built>
  <how-to-verify>
**Prerequisites:**
1. Start all services: `npm run dev` from monorepo root
2. Verify Redis healthy: `docker ps` shows redis container running

**Test Scenario (from Phase 7 Verification):**

**Test 2: Real-Time Task Creation Updates (FAILED → should now PASS)**
1. Browser Tab A (normal mode):
   - Navigate to http://localhost:3000/teams/demo-workspace/projects/marketing-campaign
   - Open browser console
   - Verify logs show: "[Room] Client joined project:..." with socketCount
2. Browser Tab B (incognito mode):
   - Log in as different user (or same user, different session)
   - Navigate to same project URL
   - Open browser console
   - Verify logs show: "[Room] Client joined project:..." with socketCount=2
3. In Tab A: Create new task "Test Real-Time Sync"
4. Expected in Tab B:
   - Console shows: "[Real-time Tasks] Received task:created: ... from user: ..."
   - UI updates automatically - new task appears without refresh
   - Timeline: Should appear within 1 second

**Test 5: Real-Time Comment Updates (FAILED → should now PASS)**
1. In Tab A: Open task detail, add comment "Testing comments sync"
2. Expected in Tab B (with same task open):
   - Console shows: "[Real-time Comments] Received comment:created"
   - Comment appears in UI without refresh

**Test 6: Presence Indicators (FAILED → should now PASS)**
1. Verify both tabs show presence indicator at top of project page
2. Expected: Indicator shows "2 users viewing" or avatar icons for both users
3. Close Tab B
4. Expected in Tab A: Presence count drops to 1 user

**Redis Pub/Sub Verification:**
1. Terminal: `docker exec -it redis redis-cli MONITOR`
2. Create task in Tab A
3. Expected: See PUBLISH commands like `PUBLISH "socket.io#/#project:...#" ...`

**Pass Criteria:**
- ✓ Task created in Tab A appears in Tab B without refresh (Test 2 PASS)
- ✓ Comments sync in real-time across sessions (Test 5 PASS)
- ✓ Presence indicators show both users (Test 6 PASS)
- ✓ Console logs show event propagation from Tab A → Redis → Tab B
- ✓ Redis MONITOR shows PUBLISH activity for WebSocket events

**Failure Scenarios:**
- If Task B never shows new task: Check Redis adapter initialization in server logs
- If Redis MONITOR shows no PUBLISH: Adapter not enabled or events not firing
- If PUBLISH seen but Tab B doesn't update: Room join issue - check socket count in logs
- If console errors appear: Note exact error message for gap closure revision
  </how-to-verify>
  <resume-signal>
Respond with:
- "approved" if all 3 tests (2, 5, 6) now PASS
- "test X failed: [description]" with console logs if any test still fails
- "redis error: [description]" if Redis adapter or pub/sub issues found
  </resume-signal>
</task>

</tasks>

<verification>
## Success Verification

After plan execution:
- [ ] Redis adapter enabled in events.gateway.ts afterInit()
- [ ] Server logs confirm "Redis adapter enabled" on startup
- [ ] Redis CLI shows 2 client connections (pub + sub)
- [ ] Room join handlers log socket counts and room membership
- [ ] Client hooks log event receipt with userId and payload details
- [ ] Manual testing (checkpoint) confirms Tests 2, 5, 6 now PASS
- [ ] Redis MONITOR shows PUBLISH activity when events fire
- [ ] Cross-session real-time sync works: Tab A → Tab B updates automatically

## Gap Closure Verification

Phase 7 verification gaps addressed:
- Test 2 (Task creation sync): FAIL → PASS (Redis adapter enables cross-session broadcasting)
- Test 5 (Comments sync): FAIL → PASS (Same root cause as Test 2)
- Test 6 (Presence indicators): FAIL → PASS (Same root cause as Test 2)
- Test 7 (Conflict detection): PARTIAL - Addressed in Plan 02 (logic fixes)
- Test 4 (False conflicts): FAIL → Addressed in Plan 02 (self-update filtering)

This plan addresses the CRITICAL session isolation gap identified as root cause for 80% of Phase 3 verification failures.
</verification>

<success_criteria>
## Observable Truths Achieved

1. User in Tab A creates task → User in Tab B (different session) sees task appear without refresh
2. User in Tab A adds comment → User in Tab B sees comment appear in real-time
3. Two users viewing same project → Both see presence indicator showing "2 users viewing"
4. Redis pub/sub distributes events → Redis MONITOR shows PUBLISH commands
5. WebSocket rooms functional → Server logs show correct socket counts per room
6. Event propagation traceable → Console logs show event flow from Tab A through Redis to Tab B

## Requirements Satisfied

- REAL-02 (Live task updates across all connected clients): 2/8 → 5/8 after this plan
- REAL-03 (Live comment updates): 0/8 → 1/8 after this plan
- REAL-04 (Presence indicators showing active users): 0/8 → 1/8 after this plan
- REAL-07 (Redis pub/sub for horizontal scaling): Already satisfied, now functionally verified

## Anti-Patterns Avoided

- Storing Redis adapter result (synchronous emit required)
- Setting adapter before Redis clients connect (breaks silently)
- Broadcasting without room join verification (events lost)
- Missing event propagation visibility (debugging logs added)
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-phase-3-gap-closure-real-time-collaboration-fixes/07.1-01-SUMMARY.md` using the standard SUMMARY.md template.

Include:
- Redis adapter configuration details
- Room join verification approach
- Debugging log locations for future troubleshooting
- Manual test results from checkpoint (which tests passed/failed)
- Any unexpected findings during Redis adapter re-enablement
</output>
