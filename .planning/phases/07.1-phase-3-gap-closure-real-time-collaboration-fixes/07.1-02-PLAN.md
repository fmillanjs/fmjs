---
phase: 07.1-phase-3-gap-closure-real-time-collaboration-fixes
plan: 02
type: execute
wave: 2
depends_on: ["07.1-01"]
files_modified:
  - apps/web/hooks/use-real-time-tasks.ts
  - apps/api/src/modules/tasks/tasks.service.ts
  - apps/web/components/ui/conflict-warning.tsx
autonomous: false
gap_closure: true

must_haves:
  truths:
    - "User does NOT see false conflict warnings when moving their own task (Test 4 fix)"
    - "User DOES see conflict warning when another user modifies same task concurrently (Test 7 fix)"
    - "Optimistic UI updates revert automatically on server conflict response"
  artifacts:
    - path: "apps/web/hooks/use-real-time-tasks.ts"
      provides: "Self-update filtering before conflict detection"
      contains: "payload.userId === currentUserId"
      min_lines: 60
    - path: "apps/api/src/modules/tasks/tasks.service.ts"
      provides: "Version-based optimistic concurrency control"
      contains: "version: { increment: 1 }"
      min_lines: 200
    - path: "apps/web/components/ui/conflict-warning.tsx"
      provides: "Conflict warning UI component"
      exports: ["ConflictWarning"]
  key_links:
    - from: "apps/web/hooks/use-real-time-tasks.ts"
      to: "currentUserId comparison"
      via: "userId filter before version check"
      pattern: "payload\\.userId === currentUserId"
    - from: "apps/api/src/modules/tasks/tasks.service.ts"
      to: "prisma.task.updateMany"
      via: "version field in where clause"
      pattern: "version:.*expectedVersion"
---

<objective>
Fix conflict detection logic to eliminate false positive warnings for same user and properly detect concurrent edits from different users

Purpose: Tests 4 and 7 reveal conflict detection has fundamental logic errors. Test 4 shows false warnings ("another user is moving it") when same user drags task back. Test 7 shows legitimate concurrent edits don't trigger conflict UI. Root cause: version check happens before userId filter, and server may not validate version field correctly.

Output: Conflict detection that filters self-updates before version comparison, server-side version validation throwing 409 on conflicts, conflict warning UI displaying on legitimate conflicts only
</objective>

<execution_context>
@/home/doctor/.claude/get-shit-done/workflows/execute-plan.md
@/home/doctor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-phase-3-verification/07-VERIFICATION.md
@.planning/phases/07.1-phase-3-gap-closure-real-time-collaboration-fixes/07.1-RESEARCH.md
@apps/web/hooks/use-real-time-tasks.ts
@apps/api/src/modules/tasks/tasks.service.ts
@packages/database/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix self-update filtering in real-time task hooks</name>
  <files>apps/web/hooks/use-real-time-tasks.ts</files>
  <action>
Fix the self-update filtering logic to prevent false conflict warnings when same user updates tasks.

Current Issue: Line 47 has filtering for task:updated but implementation may not work correctly, causing false conflict warnings (Test 4: "another user is moving it but its only me").

Implementation:
1. Review current task:updated handler (~line 45-55)
2. Ensure userId filter happens BEFORE any version comparison logic
3. Add early return if payload.userId === currentUserId
4. Add console log for debugging: `console.log('[Real-time] Self-update filtered for task', payload.task.id)`

Pattern from research:
```typescript
const handleTaskUpdated = useCallback((payload: TaskEventPayload) => {
  // CRITICAL: Filter self-updates FIRST, before any conflict detection
  if (payload.userId === currentUserId) {
    console.log('[Real-time] Ignoring self-update for task', payload.task.id);
    return; // User already has optimistic update
  }

  // Update from OTHER user - apply to local state
  setTasks(tasks.map((t) => (t.id === payload.task.id ? payload.task : t)));
}, [currentUserId, tasks]);
```

IMPORTANT: Do NOT filter task:created events - client needs server-assigned ID and timestamps. Only filter task:updated and task:deleted events.

Why: Research finding "Self-update filtering (FIX REQUIRED) - Current Issue: use-real-time-tasks.ts line 47 filters task:updated by userId, but conflict detection logic doesn't properly distinguish same-user actions."

Verify filtering is consistent for:
- task:updated
- task:status_changed (drag-drop updates)
- task:deleted
  </action>
  <verify>
1. Open apps/web/hooks/use-real-time-tasks.ts
2. Verify all event handlers check `payload.userId === currentUserId` before processing
3. Search for any version comparison logic - ensure it comes AFTER userId filter
4. Run TypeScript compiler: `cd apps/web && npm run type-check`
  </verify>
  <done>
- task:updated handler filters self-updates before applying changes
- task:status_changed handler filters self-updates for drag-drop
- task:deleted handler filters self-updates
- Console logs added for debugging self-update filtering
- No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement version-based optimistic concurrency control in tasks.service.ts</name>
  <files>apps/api/src/modules/tasks/tasks.service.ts</files>
  <action>
Implement proper optimistic concurrency control using the version field to detect concurrent edits and return 409 Conflict when version mismatch occurs.

Research context: Task model already has `version Int @default(0)` field in schema.prisma. Need to use Prisma's updateMany with version in where clause for atomic update.

Implementation:
1. Find update() method in tasks.service.ts (likely around line 80-120)
2. Add expectedVersion parameter to method signature: `update(id: string, updateTaskDto: UpdateTaskDto, userId: string, expectedVersion?: number)`
3. If expectedVersion provided, use updateMany pattern:
```typescript
// Attempt atomic update with version check
const result = await this.prisma.task.updateMany({
  where: {
    id,
    version: expectedVersion  // Only update if version matches
  },
  data: {
    ...updateTaskDto,
    version: { increment: 1 },  // Atomic increment
    updatedAt: new Date()
  }
});

// Conflict detection
if (result.count === 0) {
  // Version mismatch = concurrent edit detected
  throw new ConflictException({
    message: 'Task was modified by another user',
    code: 'CONCURRENT_MODIFICATION',
    expectedVersion,
    currentVersion: (await this.prisma.task.findUnique({ where: { id } }))?.version
  });
}
```
4. After successful update, fetch and return full task with relations
5. Emit task.updated event with userId for WebSocket broadcasting

Pattern from research: "Optimistic Concurrency Control with Version Field - Use version field to detect concurrent edits and prevent lost updates."

Why: Without version validation, server accepts all updates regardless of staleness, allowing lost updates and not triggering conflict warnings.

Note: This change is backward compatible - if expectedVersion not provided, falls back to regular update without version check.
  </action>
  <verify>
1. Open apps/api/src/modules/tasks/tasks.service.ts
2. Verify update() method uses updateMany with version in where clause
3. Verify ConflictException thrown when result.count === 0
4. Run TypeScript compiler: `cd apps/api && npm run build`
5. Run unit tests if they exist: `cd apps/api && npm test tasks.service`
  </verify>
  <done>
- update() method accepts expectedVersion parameter
- Uses Prisma updateMany with version in where clause for atomic operation
- Throws ConflictException (409) when version mismatch detected
- Returns detailed error with expected and current version numbers
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create or enhance conflict warning UI component</name>
  <files>apps/web/components/ui/conflict-warning.tsx</files>
  <action>
Create or enhance conflict warning UI component to display when 409 Conflict response received from API.

Check if component exists at apps/web/components/ui/conflict-warning.tsx. If not, create it. If exists, enhance to match requirements.

Implementation:
1. Create ConflictWarning component accepting props:
   - taskId: string
   - message: string (e.g., "Another user modified this task")
   - onReload: () => void (reload task from server)
   - onDismiss: () => void (dismiss warning, keep local changes)

2. UI design:
   - Yellow/amber banner with warning icon (use Lucide AlertTriangle)
   - Clear message: "Another user modified this task while you were editing"
   - Two action buttons:
     - "Reload" (primary) - fetches latest from server, discards local changes
     - "Keep My Changes" (secondary) - dismisses warning, user keeps working (may overwrite)
   - Auto-dismiss after 10 seconds if no action taken

3. Tailwind classes for accessibility:
   - bg-amber-50 text-amber-900 (light mode) - meets WCAG 4.5:1 contrast
   - dark:bg-amber-900/20 dark:text-amber-200 (dark mode)
   - border-l-4 border-amber-500 for visual emphasis

4. Export component for use in task detail page and Kanban board

Pattern from research: "Conflict detection and resolution - System detects concurrent edits and shows clear conflict resolution UI to user"

Example structure:
```tsx
import { AlertTriangle, RefreshCw, X } from 'lucide-react';

interface ConflictWarningProps {
  taskId: string;
  message: string;
  onReload: () => void;
  onDismiss: () => void;
}

export function ConflictWarning({ message, onReload, onDismiss }: ConflictWarningProps) {
  return (
    <div className="flex items-center gap-3 rounded-lg border-l-4 border-amber-500 bg-amber-50 p-4 text-amber-900 dark:bg-amber-900/20 dark:text-amber-200">
      <AlertTriangle className="h-5 w-5 flex-shrink-0" />
      <div className="flex-1">
        <p className="font-medium">{message}</p>
        <p className="text-sm opacity-90">Choose to reload the latest version or keep your changes.</p>
      </div>
      <div className="flex gap-2">
        <button onClick={onReload} className="flex items-center gap-1 rounded bg-amber-600 px-3 py-1.5 text-sm font-medium text-white hover:bg-amber-700">
          <RefreshCw className="h-4 w-4" />
          Reload
        </button>
        <button onClick={onDismiss} className="rounded border border-amber-300 px-3 py-1.5 text-sm font-medium hover:bg-amber-100 dark:border-amber-700 dark:hover:bg-amber-900/40">
          Keep My Changes
        </button>
      </div>
    </div>
  );
}
```

Why: Test 7 shows "Concurrent edits trigger conflict detection UI" is not working. Need visible, actionable conflict resolution UI when 409 response received.
  </action>
  <verify>
1. Open apps/web/components/ui/conflict-warning.tsx
2. Verify component exports ConflictWarning with required props
3. Check color contrast with WebAIM checker: bg-amber-50 text-amber-900 should be 4.5:1 minimum
4. Run TypeScript compiler: `cd apps/web && npm run type-check`
5. Test component renders: Add to any page temporarily and verify visual appearance
  </verify>
  <done>
- ConflictWarning component created or enhanced at apps/web/components/ui/conflict-warning.tsx
- Component accepts taskId, message, onReload, onDismiss props
- UI uses amber/yellow color scheme with WCAG-compliant contrast ratios
- Two action buttons provided: Reload (primary), Keep My Changes (secondary)
- Component exported for use in task views
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Conflict detection logic fixes including self-update filtering (client-side), version-based optimistic concurrency control (server-side), and conflict warning UI component. This addresses false positive warnings (Test 4) and false negative detection (Test 7).
  </what-built>
  <how-to-verify>
**Prerequisites:**
1. Complete Plan 01 first (Redis adapter must be enabled)
2. Start all services: `npm run dev` from monorepo root
3. Open two browser tabs with same project, different users if possible

**Test 4: False Conflict Warnings (FAILED → should now PASS)**
1. Browser Tab A:
   - Navigate to project board with Kanban view
   - Drag task "Design System" from TODO to IN_PROGRESS
   - Verify optimistic update (task moves immediately)
2. In same Tab A: Drag same task back from IN_PROGRESS to TODO
3. Expected:
   - Task moves smoothly without warning
   - NO conflict warning appears
   - Console shows: "[Real-time] Ignoring self-update for task ..."
4. **Pass Criteria:** No "another user is moving it" warning for same user's actions

**Test 7: Actual Conflict Detection (FAILED → should now PASS)**
Setup requires simulating concurrent edit:
1. Browser Tab A: Open task detail page for task "API Documentation"
2. Browser Tab B (incognito, different user): Open same task detail page
3. Tab A: Start editing task title, change to "REST API Documentation" but DON'T save yet
4. Tab B: Quickly edit same task title to "GraphQL API Documentation" and click Save
5. Tab B: Verify save succeeds (task title updates)
6. Tab A: Now click Save (attempting to save stale version)
7. Expected:
   - API returns 409 Conflict error
   - Amber conflict warning banner appears in Tab A
   - Banner message: "Another user modified this task while you were editing"
   - Two buttons visible: "Reload" and "Keep My Changes"
   - Clicking "Reload" fetches latest version from server (shows "GraphQL API Documentation")
   - Clicking "Keep My Changes" dismisses warning, allows user to force save
8. **Pass Criteria:** Conflict warning appears on actual concurrent edit, provides clear resolution options

**Test 8: Optimistic UI Rollback (UNCERTAIN → should now verify)**
1. Tab A: Stop API server (Ctrl+C in terminal running `npm run dev`)
2. Tab A: Drag task between columns
3. Expected:
   - Optimistic update shows task in new column immediately
   - After ~5 seconds, API call times out
   - Task reverts to original column (rollback)
   - Toast/error message appears: "Failed to update task"
4. Restart API server: `npm run dev`
5. **Pass Criteria:** Optimistic updates revert on API failure

**Additional Verification:**
- Check browser console for "[Real-time] Ignoring self-update" logs when dragging tasks
- Verify no React errors or warnings appear
- Test conflict warning styling in both light and dark mode
- Verify WCAG contrast: amber banner text readable on background

**Failure Scenarios:**
- If Test 4 still shows false warnings: Check userId comparison in use-real-time-tasks.ts
- If Test 7 doesn't show conflict UI: Check ConflictException in tasks.service.ts, verify 409 status
- If conflict UI doesn't appear: Check if ConflictWarning component imported and used in task views
- If optimistic rollback doesn't work: Check error handling in update mutation
  </how-to-verify>
  <resume-signal>
Respond with:
- "approved" if Tests 4, 7, and 8 all PASS
- "test X failed: [description]" with specific failure details
- "conflict ui issue: [description]" if warning banner doesn't appear or has UX problems
- "rollback issue: [description]" if optimistic updates don't revert on error
  </resume-signal>
</task>

</tasks>

<verification>
## Success Verification

After plan execution:
- [ ] use-real-time-tasks.ts filters self-updates before version comparison
- [ ] tasks.service.ts validates version field with updateMany pattern
- [ ] ConflictException (409) thrown on version mismatch
- [ ] ConflictWarning component exists and renders correctly
- [ ] Manual testing (checkpoint) confirms Tests 4, 7, 8 PASS
- [ ] No false conflict warnings for same user actions
- [ ] Actual concurrent edits trigger conflict UI with resolution options
- [ ] Optimistic updates revert on API failure

## Gap Closure Verification

Phase 7 verification gaps addressed:
- Test 4 (False conflicts): FAIL → PASS (self-update filtering before version check)
- Test 7 (Conflict detection): FAIL → PASS (version-based OCC with 409 responses)
- Test 8 (Optimistic rollback): UNCERTAIN → PASS (error handling with state revert)

This plan addresses the HIGH priority conflict detection logic errors.
</verification>

<success_criteria>
## Observable Truths Achieved

1. User drags their own task multiple times → No false "another user" warnings appear
2. Two users edit same task simultaneously → Conflict warning appears for second save
3. Conflict warning provides actionable choices → User can reload or keep changes
4. API failure during update → UI reverts optimistic change automatically
5. Console logs show self-update filtering → "[Real-time] Ignoring self-update" appears

## Requirements Satisfied

- REAL-06 (Conflict detection and resolution): 0/8 → 1/8 after this plan
- REAL-05 (Optimistic UI updates with rollback): Partial → Complete after this plan
- REAL-02 (Live task updates): Improved (fewer false positives in conflict detection)

## Anti-Patterns Avoided

- Version check before userId filter (causes false positives)
- Storing intermediate state during optimistic update (breaks rollback)
- Filtering task:created events (client needs server-assigned ID)
- Missing user feedback on conflicts (no visible UI)
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-phase-3-gap-closure-real-time-collaboration-fixes/07.1-02-SUMMARY.md` using the standard SUMMARY.md template.

Include:
- Self-update filtering implementation details
- Version-based OCC pattern used in tasks.service.ts
- Conflict warning UI component design and color choices
- Manual test results from checkpoint (which scenarios passed/failed)
- Any edge cases discovered during conflict detection testing
</output>
