# Phase 07.1: Phase 3 Gap Closure - Real-Time Collaboration Fixes - Research

**Researched:** 2026-02-16
**Domain:** WebSocket debugging, real-time collaboration fix patterns, accessibility remediation
**Confidence:** HIGH

## Summary

This research focuses on **debugging and fixing** the specific gaps identified in Phase 7 verification, not building new real-time architecture. The infrastructure exists and partially works (WebSocket authentication PASS, drag-drop in same session PASS, Redis infrastructure healthy). The critical failures are:

1. **Session isolation** - Tab B (incognito) not receiving events broadcast to project rooms
2. **Conflict detection logic errors** - False positives (same user) and false negatives (actual conflicts)
3. **UI/UX issues** - White-on-white text, "unknown user" display

Root cause hypothesis from verification: WebSocket room join or event broadcasting issue prevents cross-session synchronization. The Redis adapter is currently **disabled** (line 36-40 of events.gateway.ts: "temporarily disabled due to Socket.IO v4 API changes"), which means events only broadcast within a single server instance.

**Primary recommendation:** Re-enable and properly configure Redis adapter first (Priority 1), then fix conflict detection logic (Priority 2), then remediate accessibility violations (Priority 3).

## Standard Stack

### Core (Already Installed)
| Library | Version | Purpose | Status |
|---------|---------|---------|--------|
| Socket.IO | v4.x | WebSocket server/client with room management | ✓ Installed, authentication works |
| @socket.io/redis-adapter | Latest | Redis pub/sub adapter for horizontal scaling | ✓ Installed but **DISABLED** |
| ioredis | Latest | Redis client (pub/sub) | ✓ Installed, Redis container healthy |
| socket.io-client | v4.x | Client library for Next.js frontend | ✓ Installed, connects successfully |

### Supporting (For Gap Closure)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @playwright/test | Latest | WebSocket integration testing | Testing cross-session real-time sync |
| WebAIM Contrast Checker | N/A (web tool) | WCAG compliance validation | Verifying color contrast fixes |

### No New Libraries Needed
The gap closure requires **configuration fixes and logic corrections**, not new dependencies. All required libraries are already installed.

**Installation:**
```bash
# No new packages needed - all dependencies already installed
# Verify Redis adapter is available:
cd apps/api && npm list @socket.io/redis-adapter
```

## Architecture Patterns

### Pattern 1: Redis Adapter Setup (FIX REQUIRED)
**What:** Redis pub/sub adapter enables event broadcasting across multiple Socket.IO server instances (and multiple browser sessions connecting to the same instance).

**Current Issue:** Adapter is disabled (events.gateway.ts line 36-40), preventing cross-session broadcasting even on single server.

**Correct Implementation:**
```typescript
// Source: https://socket.io/docs/v4/redis-adapter/
import { createAdapter } from '@socket.io/redis-adapter';
import { Redis } from 'ioredis';

async afterInit(server: Server) {
  const pubClient = new Redis(process.env.REDIS_URL || 'redis://localhost:6380');
  const subClient = pubClient.duplicate();

  // CRITICAL: Wait for both clients to connect before setting adapter
  await Promise.all([
    new Promise(resolve => pubClient.on('connect', resolve)),
    new Promise(resolve => subClient.on('connect', resolve))
  ]);

  server.adapter(createAdapter(pubClient, subClient));
  console.log('WebSocket server initialized with Redis adapter');
}
```

**Why This Matters:** Without Redis adapter, `server.to(room).emit()` only broadcasts to sockets connected to the current server instance. Since incognito tabs create separate sessions, they may not receive events even on single-server setups.

### Pattern 2: Room Membership Verification (DEBUGGING)
**What:** Verify clients actually joined project rooms before assuming events will reach them.

**When to use:** Debugging "events not received" issues.

**Example:**
```typescript
// Source: https://socket.io/docs/v4/server-api/
@SubscribeMessage('join:project')
async handleJoinProject(client: Socket, payload: { projectId: string }) {
  const roomName = `project:${projectId}`;
  await client.join(roomName);

  // DEBUGGING: Verify room join succeeded
  const socketsInRoom = await this.server.in(roomName).fetchSockets();
  console.log(`[Room Debug] ${roomName} now has ${socketsInRoom.length} sockets:`,
    socketsInRoom.map(s => ({ id: s.id, userId: s.data.user?.id }))
  );

  // Alternative: Check socket's rooms directly
  console.log(`[Socket Debug] Client ${client.id} is in rooms:`, Array.from(client.rooms));

  return { event: 'joined', data: { projectId, room: roomName } };
}
```

**Warning Signs:**
- `client.rooms` doesn't contain expected room name
- `fetchSockets()` returns 0 or fewer sockets than expected
- Room join happens AFTER async DB query completes (socket may disconnect before join)

### Pattern 3: Self-Update Filtering (FIX REQUIRED)
**What:** Prevent WebSocket events from same user triggering duplicate UI updates or false conflict warnings.

**Current Issue:** use-real-time-tasks.ts line 47 filters `task:updated` by userId, but conflict detection logic doesn't properly distinguish same-user actions.

**Correct Pattern:**
```typescript
// Source: Real-time collaboration best practices
// Client-side listener (use-real-time-tasks.ts)
const handleTaskUpdated = (payload: TaskEventPayload) => {
  // FILTER: Ignore events from current user - they already have optimistic update
  if (payload.userId === currentUserId) {
    console.log('[Real-time] Ignoring self-update for task', payload.task.id);
    return;
  }

  // Update from OTHER user - apply to local state
  setTasks(tasks.map((t) => (t.id === payload.task.id ? payload.task : t)));
};

// EXCEPTION: task:created should NOT filter self-updates
// Reason: Server-assigned fields (id, createdAt) need to replace optimistic placeholders
const handleTaskCreated = (payload: TaskEventPayload) => {
  setTasks((current) => {
    // Prevent duplicates but allow server confirmation
    if (current.some((t) => t.id === payload.task.id)) {
      return current; // Already exists
    }
    return [...current, payload.task];
  });
};
```

**Why Different for Created vs Updated:**
- `created`: Client needs server-assigned ID, may have optimistic placeholder
- `updated`: Client already has latest state from optimistic update, server echo is redundant

### Pattern 4: Optimistic Concurrency Control with Version Field
**What:** Use version field to detect concurrent edits and prevent lost updates.

**Current Implementation:** Task model has `version Int @default(0)` field (schema.prisma).

**Correct Update Pattern:**
```typescript
// Source: https://github.com/prisma/prisma/issues/4988
async updateTask(id: string, data: UpdateTaskDto, currentVersion: number) {
  const result = await this.prisma.task.updateMany({
    where: {
      id,
      version: currentVersion  // CRITICAL: Only update if version matches
    },
    data: {
      ...data,
      version: { increment: 1 }  // Atomic increment
    }
  });

  if (result.count === 0) {
    // Version mismatch = concurrent edit detected
    throw new ConflictException('Task was modified by another user');
  }

  return this.prisma.task.findUnique({ where: { id } });
}
```

**Conflict Detection Logic:**
```typescript
// Client-side: Detect version mismatch from server response
try {
  await updateTask(taskId, updates, currentVersion);
} catch (error) {
  if (error.status === 409) {  // Conflict
    // Show conflict UI: "Another user modified this task. Reload to see changes?"
    setShowConflictWarning(true);
  }
}
```

**Current Bug:** Conflict warnings appear for same user's actions, suggesting version check happens before userId filter.

**Fix:** Version check should ONLY compare server version vs client version, NOT trigger on self-updates.

### Pattern 5: WCAG Color Contrast Compliance
**What:** WCAG AA requires 4.5:1 contrast for normal text, 3:1 for large text (18pt+).

**Current Issue:** White text on white background (accessibility failure).

**Fix Pattern:**
```typescript
// Source: https://webaim.org/articles/contrast/
// Tailwind CSS with accessible color system

// BAD (fails WCAG):
<div className="bg-white text-white">Text</div>  // 1:1 ratio = FAIL

// GOOD (passes WCAG AA):
<div className="bg-white text-slate-900">Text</div>      // ~17:1 ratio = AAA
<div className="bg-slate-900 text-white">Text</div>      // ~17:1 ratio = AAA
<div className="bg-blue-500 text-white">Text</div>       // ~8:1 ratio = AAA
<div className="bg-slate-100 text-slate-700">Text</div>  // ~5.8:1 ratio = AA

// Dark mode (with selector strategy):
<div className="bg-white text-slate-900 dark:bg-slate-900 dark:text-white">
  Text
</div>
```

**Testing:**
- Use WebAIM Contrast Checker: https://webaim.org/resources/contrastchecker/
- Required ratios: 4.5:1 (normal text), 3:1 (large text), 3:1 (UI components)
- Test both light and dark modes if implemented

### Anti-Patterns to Avoid

1. **Broadcasting to `socket.to(room).emit()` without verifying room join**
   - **Why it's bad:** Silent failure - no error, events just don't reach clients
   - **Fix:** Add logging to verify `client.join(room)` succeeded, use `fetchSockets()` to confirm

2. **Storing Redis adapter result and using async**
   - **Why it's bad:** `socket.to(room)` mutates the socket object, storing reference breaks it
   - **Fix:** Always use `server.to(room).emit()` synchronously, never store intermediate result

3. **Filtering `task:created` events by userId**
   - **Why it's bad:** Client never receives server-assigned ID, optimistic UI can't update
   - **Fix:** Only filter `updated`/`deleted` events, allow `created` to update optimistic placeholders

4. **Registering event listeners inside `connect` handler**
   - **Why it's bad:** Duplicate handlers on every reconnection, causing multiple UI updates
   - **Fix:** Register listeners once outside `connect`, use cleanup in `useEffect` return

5. **Using socket ID for user identification**
   - **Why it's bad:** Socket IDs regenerate on reconnection, breaking user tracking
   - **Fix:** Use userId from JWT payload stored in `client.data.user`, join `user:${userId}` room

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| WebSocket connection management | Custom reconnection logic | Socket.IO built-in `reconnection` options | Handles exponential backoff, connection recovery, heartbeat |
| Pub/sub message distribution | Custom Redis channels | @socket.io/redis-adapter | Handles room mapping, socket ID tracking, namespace isolation |
| Optimistic concurrency | Custom timestamp comparison | Prisma version field with `updateMany` + `increment` | Atomic operation prevents race conditions |
| Color contrast validation | Manual hex math | WebAIM Contrast Checker | Accounts for gamma correction, WCAG formula complexities |
| Conflict-free data types | Custom merge logic | Consider CRDTs (future) if conflicts become frequent | Mathematically proven convergence, used by Google Docs |

**Key insight:** WebSocket debugging requires systematic verification (connection → authentication → room join → event broadcast → client receipt) rather than guessing. Use browser DevTools Network tab (WS frames) and server-side logging at each step.

## Common Pitfalls

### Pitfall 1: Redis Adapter Disabled = No Cross-Session Broadcasting
**What goes wrong:** Events broadcast to project rooms don't reach clients in different browser sessions (even on same server).

**Why it happens:** Without Redis adapter, Socket.IO stores room membership in-memory only. Separate sessions may connect to same server but events don't propagate without adapter's pub/sub mechanism.

**How to avoid:**
- Re-enable Redis adapter in `afterInit()`
- Wait for Redis clients to connect before setting adapter
- Test with `redis-cli MONITOR` to verify events are published

**Warning signs:**
- Test 2 FAIL: Task created in Tab A doesn't appear in incognito Tab B
- Test 5 FAIL: Comments don't sync across sessions
- Test 6 FAIL: Presence indicators don't show other users
- Redis container healthy but no Pub/Sub activity in `redis-cli MONITOR`

**Verification:**
```bash
# Terminal 1: Monitor Redis pub/sub
docker exec -it redis redis-cli MONITOR

# Terminal 2: Create task in Tab A
# Expected: See PUBLISH commands in Terminal 1

# Tab B (incognito): Should receive event and update UI
# If no PUBLISH seen = Redis adapter not active
# If PUBLISH seen but Tab B doesn't update = Room join issue
```

### Pitfall 2: Room Join Before Authentication Complete
**What goes wrong:** Client tries to join project room before JWT validation completes, join silently fails.

**Why it happens:** Async authentication in `handleConnection()` may not finish before `join:project` message arrives.

**How to avoid:**
- Ensure `handleConnection()` waits for JWT verification before allowing messages
- Add guard in `join:project` handler: check `client.data.user` exists
- Emit `authenticated` event to client when JWT validation completes

**Warning signs:**
- Client console shows "join:project" emitted but no "joined" response
- Server logs show join:project handler called with undefined `client.data.user`
- `fetchSockets()` returns 0 sockets in room immediately after join

### Pitfall 3: Self-Update Filter Causing False Conflicts
**What goes wrong:** User drags task, sees "another user is moving it" warning for their own action.

**Why it happens:** Conflict detection compares version fields before checking if update is from same user.

**How to avoid:**
- Filter self-updates BEFORE version comparison
- Conflict detection should only trigger on updates from **other users** with stale versions
- Client should ignore WebSocket events where `payload.userId === currentUserId` for update/delete

**Warning signs:**
- Test 4 FAIL: Moving task back triggers conflict warning
- False positives: Same user sees conflict messages
- False negatives: Different users with stale data don't see warnings (Test 7 FAIL)

**Fix Pattern:**
```typescript
// Server: Always include userId in event payload
this.gateway.server.to(`project:${projectId}`).emit('task:updated', {
  task: updatedTask,
  userId: actorId,  // CRITICAL: Include who made the change
  version: updatedTask.version
});

// Client: Filter before conflict check
const handleTaskUpdated = (payload) => {
  if (payload.userId === currentUserId) {
    return; // Self-update, already applied optimistically
  }

  // Now check for version conflict
  const localTask = tasks.find(t => t.id === payload.task.id);
  if (localTask && localTask.version > payload.version) {
    console.warn('Received stale update, ignoring');
    return;
  }

  setTasks(tasks.map(t => t.id === payload.task.id ? payload.task : t));
};
```

### Pitfall 4: White-on-White Text (WCAG Violation)
**What goes wrong:** Text is literally invisible to users, severe accessibility failure.

**Why it happens:** Tailwind classes like `text-white` applied without checking parent background, or dark mode toggle not properly scoping color changes.

**How to avoid:**
- Use Tailwind's dark mode with `dark:` prefix consistently
- Never use `text-white` on `bg-white` (or same for any color)
- Test both light and dark modes with WebAIM Contrast Checker
- Use semantic color tokens (`text-foreground`, `bg-background`) instead of direct colors

**Warning signs:**
- User reports "can't see text"
- Text selection reveals invisible text
- WCAG audit tools flag contrast ratio < 3:1

**Remediation:**
```bash
# Find all potentially problematic class combinations
grep -r "bg-white.*text-white" apps/web/
grep -r "text-white.*bg-white" apps/web/

# Fix pattern:
# Before: <div className="bg-white text-white">
# After:  <div className="bg-white text-slate-900 dark:bg-slate-900 dark:text-white">
```

### Pitfall 5: Event Listener Cleanup Missing
**What goes wrong:** Old event handlers fire multiple times, causing duplicate UI updates or stale state references.

**Why it happens:** React `useEffect` registers listeners on every render without proper cleanup, or cleanup only happens on unmount.

**How to avoid:**
- Always return cleanup function from `useEffect` that calls `socket.off()`
- Include all dependencies in `useEffect` dependency array
- Use functional state updates `setTasks(prev => ...)` to avoid stale closures

**Warning signs:**
- UI updates twice for single event
- Console shows duplicate log messages
- Memory leak warnings in React DevTools
- Stale data (old userId, old projectId) in event handlers

**Fix Pattern:**
```typescript
// CORRECT: Cleanup on dependency change
useEffect(() => {
  if (!socket || !projectId) return;

  const handleTaskCreated = (payload) => { /* ... */ };

  socket.on('task:created', handleTaskCreated);

  return () => {
    socket.off('task:created', handleTaskCreated);  // CRITICAL: Cleanup
  };
}, [socket, projectId, currentUserId]);  // Re-register when deps change
```

## Code Examples

Verified patterns from official sources:

### WebSocket Room Debugging
```typescript
// Source: https://socket.io/docs/v4/server-instance/
// Verify room membership after join
@SubscribeMessage('join:project')
async handleJoinProject(client: Socket, payload: { projectId: string }) {
  const roomName = `project:${projectId}`;
  await client.join(roomName);

  // DEBUGGING: Log room membership
  console.log(`[Room] Client ${client.id} joined ${roomName}`);
  console.log(`[Room] Client rooms:`, Array.from(client.rooms));

  const socketsInRoom = await this.server.in(roomName).fetchSockets();
  console.log(`[Room] Total sockets in ${roomName}:`, socketsInRoom.length);

  // Emit confirmation with room details
  return {
    event: 'joined',
    data: { projectId, room: roomName, socketCount: socketsInRoom.length }
  };
}
```

### Browser DevTools WebSocket Inspection
```
// Source: https://firefox-source-docs.mozilla.org/devtools-user/network_monitor/inspecting_web_sockets/
// Chrome DevTools:
1. Open Network tab
2. Filter by "WS" (WebSocket)
3. Click on WebSocket connection
4. View "Messages" tab
5. Green = Sent (client → server)
6. White = Received (server → client)

// Verify:
- "join:project" message sent with correct projectId
- "joined" response received
- "task:created" messages appear when task created in other tab
- "presence:join" events show other users joining

// If messages missing:
- Check "Headers" tab for 101 Switching Protocols
- Verify auth token in request headers
- Look for disconnect/error messages
```

### Redis Pub/Sub Monitoring
```bash
# Source: https://socket.io/docs/v4/redis-adapter/
# Terminal: Monitor all Redis pub/sub activity
docker exec -it redis redis-cli MONITOR

# Expected output when task created:
# PUBLISH "socket.io#/#project:abc123#" "{\"type\":\"task:created\",...}"

# Expected output when client joins room:
# SUBSCRIBE "socket.io#/#project:abc123#"

# If no PUBLISH/SUBSCRIBE seen:
# 1. Redis adapter not enabled
# 2. Redis connection failed
# 3. Events not being emitted to rooms

# Verify Redis clients connected:
docker exec -it redis redis-cli
> CLIENT LIST
# Should show 2 connections from API server (pub + sub)
```

### Conflict Detection with Version Field
```typescript
// Source: https://github.com/prisma/prisma/discussions/24993
// Server: Task update with optimistic concurrency
async updateTask(id: string, data: UpdateTaskDto, userId: string) {
  // 1. Read current task
  const currentTask = await this.prisma.task.findUnique({ where: { id } });
  if (!currentTask) throw new NotFoundException();

  // 2. Attempt atomic update with version check
  const updated = await this.prisma.task.updateMany({
    where: {
      id,
      version: data.expectedVersion  // Client sends current version
    },
    data: {
      ...data,
      version: { increment: 1 },
      updatedAt: new Date()
    }
  });

  // 3. Conflict detection
  if (updated.count === 0) {
    // Version mismatch = concurrent edit
    throw new ConflictException({
      message: 'Task was modified by another user',
      currentVersion: currentTask.version,
      expectedVersion: data.expectedVersion
    });
  }

  // 4. Fetch and return updated task
  const task = await this.prisma.task.findUnique({
    where: { id },
    include: { assignee: true, project: true }
  });

  // 5. Emit event with userId for client-side filtering
  this.eventEmitter.emit('task.updated', {
    entityId: id,
    actorId: userId,
    task,
    projectId: task.projectId
  });

  return task;
}
```

### Client-Side Optimistic Update with Rollback
```typescript
// Source: https://blog.openreplay.com/optimistic-updates-make-apps-faster/
const updateTaskStatus = async (taskId: string, newStatus: string) => {
  const originalTasks = tasks;
  const currentVersion = tasks.find(t => t.id === taskId)?.version || 0;

  // 1. Optimistic update
  setTasks(tasks.map(t =>
    t.id === taskId
      ? { ...t, status: newStatus, version: currentVersion + 1 }
      : t
  ));

  try {
    // 2. Send to server with current version
    await api.patch(`/api/tasks/${taskId}`, {
      status: newStatus,
      expectedVersion: currentVersion
    });

    // 3. Success - optimistic update was correct
  } catch (error) {
    if (error.status === 409) {
      // 4. Conflict - rollback and show warning
      setTasks(originalTasks);
      setConflictWarning({
        taskId,
        message: 'Another user modified this task',
        action: 'reload'
      });
    } else {
      // 5. Other error - rollback
      setTasks(originalTasks);
      toast.error('Failed to update task');
    }
  }
};
```

### WCAG Accessible Color Palette
```typescript
// Source: https://webaim.org/resources/contrastchecker/
// Tailwind config with WCAG AA compliant colors

// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        // Semantic tokens for accessibility
        background: 'hsl(0 0% 100%)',           // White
        foreground: 'hsl(222.2 84% 4.9%)',     // Near-black (17:1 ratio)

        primary: 'hsl(221.2 83.2% 53.3%)',     // Blue (4.5:1 on white)
        'primary-foreground': 'hsl(210 40% 98%)',

        secondary: 'hsl(210 40% 96.1%)',       // Light gray
        'secondary-foreground': 'hsl(222.2 47.4% 11.2%)',  // Dark gray (12:1)

        muted: 'hsl(210 40% 96.1%)',
        'muted-foreground': 'hsl(215.4 16.3% 46.9%)',  // Mid-gray (4.6:1)

        destructive: 'hsl(0 84.2% 60.2%)',     // Red (4.5:1 on white)
        'destructive-foreground': 'hsl(210 40% 98%)',

        border: 'hsl(214.3 31.8% 91.4%)',      // Light border (3.1:1)
      },
    },
  },
  darkMode: 'selector',  // Use dark: prefix with .dark class
};

// Usage:
<div className="bg-background text-foreground">  {/* 17:1 ratio */}
  <Button className="bg-primary text-primary-foreground">  {/* AAA */}
    Click me
  </Button>
</div>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| socket.io-redis package | @socket.io/redis-adapter | v7.0.0 (2021) | Must provide own Redis clients, no auto-creation |
| Class strategy for dark mode | Selector strategy | Tailwind 3.4.1 (2023) | More control, use `dark:` prefix |
| Manual version comparison | Prisma updateMany + increment | Prisma 5.0.0 (2023) | Atomic operation, prevents race conditions |
| Google Docs uses OT | Modern editors use CRDTs | 2020-2024 | Better offline support, peer-to-peer sync |
| HTTP long-polling fallback | WebSocket-first with upgrade | Socket.IO v4 (2021) | Faster initial connection, better performance |

**Deprecated/outdated:**
- `socket.io-redis` package: Renamed to `@socket.io/redis-adapter`, old package unmaintained
- `io.adapter.rooms` direct access: Use `fetchSockets()` for cross-server room queries
- Dark mode `media` strategy: Replaced by `selector` strategy for programmatic control
- Manual timestamp-based conflict detection: Use version fields with atomic increment

## Open Questions

1. **Why was Redis adapter disabled?**
   - What we know: Comment says "Socket.IO v4 API changes"
   - What's unclear: v4 has been stable since 2021, API is unchanged
   - Recommendation: Re-enable with current pattern, test thoroughly, check for any NestJS-specific integration issues

2. **Should we implement CRDTs instead of version-based OCC?**
   - What we know: Current version field works for simple updates, CRDTs handle complex concurrent edits
   - What's unclear: Frequency of actual conflicts, whether complexity is justified
   - Recommendation: Stick with version field for v1.0, consider CRDTs if conflict warnings become common

3. **Is dark mode implemented?**
   - What we know: Color contrast issues reported (white-on-white)
   - What's unclear: Whether dark mode exists, or just broken light mode
   - Recommendation: Audit all text/background combinations, ensure minimum 4.5:1 ratio regardless of theme

4. **Does presence:request use callbacks or promises?**
   - What we know: use-project-presence.ts line 33 uses callback pattern
   - What's unclear: Socket.IO v4 supports both, which is more reliable
   - Recommendation: Test current callback approach, switch to acknowledgment pattern if issues persist

## Sources

### Primary (HIGH confidence)
- [Socket.IO v4 Redis Adapter Documentation](https://socket.io/docs/v4/redis-adapter/) - Setup and configuration
- [Socket.IO Troubleshooting Connection Issues](https://socket.io/docs/v4/troubleshooting-connection-issues/) - Debugging patterns
- [Socket.IO Rooms Documentation](https://socket.io/docs/v3/rooms/) - Room management and verification
- [Socket.IO Server API](https://socket.io/docs/v4/server-api/) - fetchSockets(), adapter.rooms
- [WCAG 2.1 Contrast Requirements](https://www.w3.org/WAI/WCAG22/Understanding/contrast-minimum.html) - Official W3C standard
- [WebAIM Contrast Checker](https://webaim.org/resources/contrastchecker/) - Validation tool
- [Prisma Optimistic Concurrency Discussion](https://github.com/prisma/prisma/issues/4988) - Version field pattern

### Secondary (MEDIUM confidence)
- [Firefox WebSocket Inspector Docs](https://firefox-source-docs.mozilla.org/devtools-user/network_monitor/inspecting_web_sockets/) - DevTools debugging
- [Playwright WebSocket Testing](https://dzone.com/articles/playwright-for-real-time-applications-testing-webs) - Integration test strategies
- [Building Collaborative Editing: OT vs CRDTs](https://medium.com/@sohail_saifi/building-collaborative-editing-the-battle-between-operational-transform-and-crdts-fdceb63c54ac) - Conflict resolution approaches
- [Optimistic UI Patterns](https://blog.openreplay.com/optimistic-updates-make-apps-faster/) - Client-side update strategies
- [Tailwind Dark Mode Documentation](https://tailwindcss.com/docs/dark-mode) - Accessibility with theme switching

### Tertiary (LOW confidence - requires validation)
- [Socket.IO Multi-Tab Management](https://medium.com/@lalrishav.14/prerequisite-basic-knowledge-of-node-express-passport-and-socket-io-f4b0c3c4be4b) - User/session patterns
- [Socket.IO Room Broadcasting Issues](https://github.com/socketio/socket.io/issues/3949) - Community troubleshooting
- [Real-Time Collaboration Conflict Resolution](https://tryhoverify.com/blog/conflict-resolution-in-real-time-collaborative-editing/) - High-level patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already installed, official docs reviewed
- Architecture patterns: HIGH - Verified with official Socket.IO docs, Prisma issues, WCAG standards
- Pitfalls: HIGH - Directly match Phase 7 verification failures, root causes identified
- Code examples: HIGH - Sourced from official documentation and verified GitHub issues
- Color accessibility: HIGH - WCAG standards are authoritative, WebAIM is industry standard

**Research date:** 2026-02-16
**Valid until:** 2026-03-16 (30 days - stable technologies, unlikely to change)

**Key Insight:** This is NOT a "research how to build real-time features" phase - it's "research how to DEBUG the existing implementation". The infrastructure exists and partially works. The Redis adapter being disabled is the likely root cause of 80% of failures (Tests 2, 5, 6, 7). Re-enable it first, then fix conflict detection logic, then remediate UI/UX.
